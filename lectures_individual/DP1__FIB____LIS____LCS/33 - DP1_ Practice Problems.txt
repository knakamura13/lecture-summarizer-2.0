At this point, I suggest you try some practice dynamic programming problems. There are a lot of great practice problems in the Dasgupta book. Let me suggest a few problems for you. Now, these are problems from the textbook Algorithms by Dasgupta, Papadimitriou, Vazirani. This problem 6.1, which is about finding a contiguous sequence of maximum sum. Now, note a contiguous subsequence is the same as a substring. Now, whenever I sign you a homework problem, I'm always going to tell you some little blurb about what the problem is about, so you can identify it. Because, some of the online versions of this textbook have different numbering. So, you should always make sure it's the correct problem, if you have an online version. The next problem is 6.2 where you're planning a trip and you want to figure out the hotel stops to minimize the penalty. Problem 6.3 is about yuck Donald's. In 6.4, you're given a string and you wanted to see if you can break up that string into a set of words. Now, 6.11 is longest common subsequence. We already did that in this lecture, but for practice, you might try the variant where you did the longest common substring. It's useful to look at how dynamic programming solutions vary. What's the difference when you have substring versus subsequences? Once again, at this point, you should be able to do these practice problems: 6.1, 6.2, 6.3, 6.4, and 6.11, or this variant of 6.11 where you do substrings instead of subsequences. Let me give you a quick summary of the approach we used for designing a dynamic programming algorithm. And you can implement this approach when you try these practice problems. The first step is to define the subproblem in words. How do you do that? Well, you'd take the same problem, the original problem, on a prefix of the input. So, the subproblem should be of the same form as the original problem, but instead of being an input of length N try it on a prefix of the input. So, an input of length I. The second step is to define a recurrence relation. If you have a one dimensional table, then you wanna express T of I or the Ith entry of this one dimensional table in terms of smaller subproblems, T 1 through T I minus 1. This is what we did for LCS, though in that case, it was a two dimensional table. Now, when we did LIS, Longest Increasing Subsequence, we were unable to do this. And what we needed to do was strengthen the subproblem. So, we had to go back and redefine the subproblem. So, we've strengthen the subproblem by adding the constraint. Typically, we add the constraint that the last element, element I, is required to be included in this solution to this subproblem. So, for LIS, we said, LFI was the longest increasing subsequence in the prefix of the input of size I. But the last element A I had to be included in that solution. Now, one thing to keep in mind is typically, when we add in this constrain, and the final output is no longer the last element in the table, but instead we're going to have to do a max or a min. But we're going to have to go over the whole table and look for the best, the optimal solution in the table. Now, I want to show you how I solve these practice problems. So, I'm going to show you how I approach this problem 6.1. But to get the most out of it, I suggest that you try the problem first, and then if you're having difficulty, you can watch the next slide to see how to solve it.