Finally we can describe our Bloom filter data structure. The basic data structure is simply a binary array a 0-1 array of size little n. So we have this binary array. We don't have any linked lists hanging off it at all. It's just a binary array of size n, that's the whole data structure. We're going to start off by setting h to all zeros. So all of the n bits are set to zero. As before, we're going to use a random hash function which maps elements of the universe of possible passwords into our hash table of size little n. How do we insert an element x of possible password into our dictionary x of unacceptable passwords? First off we compute is hash value, then we set the bit in this array to one at that hash value. So we compute H_of_x and we set H, capital H at H_of_x to be one. Now it might already be one, in which case we're not doing anything. So the bits only change from zeros to ones. We never change them back from ones to zeros. That's one of the limitations on this data structure. There is no easy way to implement deletions, because we never change bits from ones to zeros, we only change them from zero to ones. Now how do we do a query? How do we check whether an element x is in our dictionary s? Where we compute x hash value, and we check the array. The bit had that hash value and we see whether it's one or zero. If the bit at this hash value is one, then we output yes. We believe it is in the dictionary s. If it's zero, then we're guaranteed that it no it's not in the dictionary. Because if it's zero that means we definitely did not insert it. If it's one, then we think, we might have inserted it but we're not sure. Somebody else might have been inserted at that hash value, and we have no way of checking whether it's x was inserted at the hash values or somebody else was inserted at the hash value. Because we're not maintaining a linked list at this point. Let me repeat this point about how false positives can arise. We have some element x which we do a query on. It's not in our dictionary of unacceptable passwords, but there is some other element y which is in our dictionary of unacceptable passwords. And these two elements, x and y, have the same hash value. h_of_x equals h_of_y. So when we inserted y into our dictionary, then we set this bit at this point to one. So then when we do the query on x, this bit looks is 1. So we think or as far as we know, x might be in our dictionary. So we have to output yes because it might be there. But in fact it is no because it was not inserted but somebody else was inserted with the same hash value. That's how false positives arise. Now this scheme is not going to perform very well. How can we improve it? Well we can try to use our power of two choices idea that we used before in our traditional hashing scheme. So what are we going to do? Well instead of using one hash function, we're going to use two hash functions. Now in the traditional balls and bins example, there was a big gain from going from one hash function to two hash functions, but then going from two to three or three to four, was not much of a gain. But here, this is a slightly different setting and there'll be a big gain possibly going from one to two but even for two to three there might be a gain. And it's not clear how many hash functions to use and we're going to try to optimize that choice of number hash functions. So we're going to allow, instead of two hash functions, we're going to allow k hash functions. So we want to generalize this scheme to allow k hash functions and then we're going to go back and figure out what is the optimal choice of k, the number of hash functions. So let's look at the more robust setting where we allow k hash functions, and how do we modify this data structure to accommodate k hash functions.