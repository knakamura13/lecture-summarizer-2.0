Now let's look at the recipe for designing a dynamic programming algorithm. The first step, is to define the sub-problem in words. To see what I mean by this, let's look back at the simple example of Fibonacci numbers. In that example, our sub-problem definition was F of I is the I Fibonacci number. The second step in our recipe, is to state a recursive relation. We want to express the solution to the I sub-problem in terms of smaller sub-problems. So for the instance of Fibonacci numbers, we want to express F of I in terms of F one, through F I minus one. Because if you recall our dynamic programming algorithm for computing the Fibonacci numbers, we computed F 1 up to F I minus 1, so those will be stored in our table, and then we can use those to compute F of I. Now for the case of the Fibonacci numbers, it was straightforward to express F of I in terms of smaller sub-problems. Namely F of I is the sum of the previous two Fibonacci numbers. Now, let's figure out how to follow this recipe for the longest increasing sub-sequence problem. Now, let's follow the first step in our recipe. We want to define the sub problem in words. Our first attempt is always going to be, to use the identical problem on a prefix of the input. In this case, that means we're going to look at the longest increasing sub-sequence on the first I elements of the input array. Therefore, we're going to make a new function L, which is the length of the longest increasing sub-sequence on the first I elements of the input. Now, we want to figure out how to express L of I in terms of L one through L I minus one smaller subproblems. To do this, let's take a look back at our earlier example, and see if we can gain some intuition.