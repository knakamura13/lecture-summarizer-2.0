Before moving on to a more sophisticated example, let's recap a few key issues. I want to stress one important point about Dynamic Programming algorithms. Our algorithm had no recursion inside of it. We used the recursive nature of the problem to design our Dynamic Programming Algorithm, but the algorithm itself has no recursion inside of it. Now, there is an alternative approach to Dynamic Programming. In this approach, you use a hash table or some other similar structure to keep track of which sub-problems that have already been solved, so that you don't recompute those problems. Now, we're not going to use this at all in our course. This approach is called memoization. Try to say that five times, I can't and therefore we're not going to use it in this class. But actually, the real reason why we're not using it, is because the goal of this unit is to learn dynamic programming. Therefore, to avoid any confusion we're going to say no recursion in our algorithms. Dynamic programming has several advantages over memoization or similar techniques. Some might say the algorithms themselves are more beautiful. Certainly, they're faster because they have less overhead from avoiding recursion. And finally, it's much simpler to analyze the running time of Dynamic Programming Algorithms, dynamic programming is widely used. At first, students often find it challenging, but what we find is that with enough practice the dynamic programming algorithms start to seem similar to each other. At that point it will click and hopefully it'll seem easy to design a dynamic programming after that. To get to that point, what do you need to do? Practice, practice, practice. Do a lot of practice problems and then it will click and you'll find dynamic programming easy. We're going to do some in class, you're going to do something during the homework and then do a lot on your own. There's a lot of practice dynamic programming problems out there in the textbook and other online resources that you can find. You do enough practice, you ace the topic.