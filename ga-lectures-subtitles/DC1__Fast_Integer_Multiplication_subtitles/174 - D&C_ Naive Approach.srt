1
00:00:00,000 --> 00:00:03,295
 Let's get back to our original problem multiplying n-bit integers.

2
00:00:03,295 --> 00:00:06,870
 And let's look at the straightforward divide and conquer approach for this problem.

3
00:00:06,870 --> 00:00:12,450
 The input to the problem are two integers x and y which are both n-bits long.

4
00:00:12,450 --> 00:00:15,520
 And for simplicity, we're going to assume that n is a power of 2.

5
00:00:15,520 --> 00:00:18,695
 This is a common assumption in divide and conquer algorithms.

6
00:00:18,695 --> 00:00:21,090
 It allows us to get rid of floors and ceilings in

7
00:00:21,090 --> 00:00:24,715
 our algorithm description and in the analysis of the running time.

8
00:00:24,715 --> 00:00:27,750
 And our goal is to compute the product, x times y.

9
00:00:27,750 --> 00:00:30,630
 We want to look at our running times in terms of n. N is

10
00:00:30,630 --> 00:00:33,770
 the number of bits for these two integers x and y.

11
00:00:33,770 --> 00:00:37,440
 It's the space required to represent these two numbers.

12
00:00:37,440 --> 00:00:39,845
 Now what's the standard divide and conquer idea?

13
00:00:39,845 --> 00:00:41,885
 Think about merge sort. What do you do?

14
00:00:41,885 --> 00:00:43,175
 You break the input,

15
00:00:43,175 --> 00:00:44,850
 the n numbers that you're trying to sort,

16
00:00:44,850 --> 00:00:46,285
 you break them into two halves.

17
00:00:46,285 --> 00:00:48,515
 The left half and the right half.

18
00:00:48,515 --> 00:00:51,655
 Then you recursively solve the problem on the two halves.

19
00:00:51,655 --> 00:00:54,540
 So for merge sort, that means sort the left half and sort

20
00:00:54,540 --> 00:00:57,725
 the right half and then you combine the answers together.

21
00:00:57,725 --> 00:00:59,160
 You merge them together.

22
00:00:59,160 --> 00:01:04,175
 Now, how do we apply that same idea here for multiplying these two n-bit integers?

23
00:01:04,175 --> 00:01:06,150
 How do we break the input into two halves?

24
00:01:06,150 --> 00:01:09,135
 Well, we can't break it into x separately from y.

25
00:01:09,135 --> 00:01:12,445
 So what do we do instead? We break x into two halves.

26
00:01:12,445 --> 00:01:18,180
 The left half of x and the right half of x and similarly for y. X is n-bit number,

27
00:01:18,180 --> 00:01:19,920
 how do we break it into two halves?

28
00:01:19,920 --> 00:01:24,250
 Well, we looked at the first n over 2 bits and the last n over 2 bits.

29
00:01:24,250 --> 00:01:28,199
 And we take these first n over 2 bits and we call that a new number, x_l.

30
00:01:28,199 --> 00:01:30,240
 That's the left side of x.

31
00:01:30,240 --> 00:01:32,465
 And we take the last n over 2 bits.

32
00:01:32,465 --> 00:01:33,705
 And that's another number.

33
00:01:33,705 --> 00:01:36,750
 x_r, corresponding to the right side of x.

34
00:01:36,750 --> 00:01:38,855
 Similarly for y, we do the same thing.

35
00:01:38,855 --> 00:01:42,645
 Take the first n over 2 bits and the last n over 2 bits.

36
00:01:42,645 --> 00:01:45,580
 So we're going to break x into the first n over 2 bits.

37
00:01:45,580 --> 00:01:46,915
 That's going to be this new number

38
00:01:46,915 --> 00:01:50,285
 x_l and we're going to break it into the last n over 2 bits.

39
00:01:50,285 --> 00:01:51,990
 That's going to be this number x_r.

40
00:01:51,990 --> 00:01:56,590
 Similarly for y, we're going to break it into the first n over 2 bits, call that y_l.

41
00:01:56,590 --> 00:01:59,385
 And the last n over 2 bits, call that y_r.

42
00:01:59,385 --> 00:02:02,490
 Let's look at this specific example to see what this partition

43
00:02:02,490 --> 00:02:06,090
 of x into two halves is going to signify.

44
00:02:06,090 --> 00:02:08,460
 Let's look at x equal to 182.

45
00:02:08,460 --> 00:02:13,270
 In binary, this is 1011 0110.

46
00:02:13,270 --> 00:02:15,450
 This is 8-bits long. So we're going to break it into

47
00:02:15,450 --> 00:02:18,325
 the first 4 bits and the last 4 bits.

48
00:02:18,325 --> 00:02:21,460
 This is the first 4 bits, that's going to be x_l.

49
00:02:21,460 --> 00:02:24,230
 The last 4 bits are going to be x_r.

50
00:02:24,230 --> 00:02:27,660
 So x_l equals 1011 in binary.

51
00:02:27,660 --> 00:02:30,190
 In decimal, that corresponds to 11,

52
00:02:30,190 --> 00:02:34,455
 x_r is 0110 in binary which is 6.

53
00:02:34,455 --> 00:02:37,270
 How does 182 relate to 11 and 6?

54
00:02:37,270 --> 00:02:44,740
 Well, notice 182 is the same as 11 times 2 to the 4, 16 plus 6.

55
00:02:44,740 --> 00:02:47,760
 And in general, x satisfies.

56
00:02:47,760 --> 00:02:52,005
 We take this number x_l and we multiply it by 2 to the n over 2.

57
00:02:52,005 --> 00:02:53,680
 That corresponds to shifting it,

58
00:02:53,680 --> 00:02:57,160
 n over 2 times and then we add in x_r.

59
00:02:57,160 --> 00:02:57,160
 Which means add in these n over 2 bits.

