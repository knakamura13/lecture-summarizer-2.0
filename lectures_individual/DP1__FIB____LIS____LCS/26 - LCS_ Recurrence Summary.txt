Let's recap the recurrence that the L Y J satisfies. Now we're looking at the case with the two strings are non-empty. So I has at least one and J is at least one. Now we had two cases here. We had the case X I is not equal to the Y J, the last characters are different, and we have the case where the last characters are the same. In the case where they are the same, we had the simple recurrence. We depend on X I Y J, and therefore get a plus one for that, and then we take the optimal solution to the smaller sub-problem with one less character in each string. Now in the case where they are not equal, we took the best of two scenarios. We either drop the last character from X, or we drop the last character from Y. And we take the larger of these two solutions, and we also had the base cases, where one of the two strings was empty, in which case the length is 0. Finally, now we can state our dynamic programming algorithm. The pseudocode for the algorithm. And now, notice we have a two dimensional table now. L is a two dimensional array. How are we going to fill it up? We're going to fill it up row by row. And now when we're looking at this entry L I J, what are the entries that we're going to need for it? We're going to need either this diagonal. It's right here, L I-1J-1, which will be there because we filled in the previous row, or we'll need the entry just above, or we'll need the entry just to the left. So we're just gonna look at these three entries, which will all be there, because we are filling it up row by row. So earlier in this row will be completed and the previous row will be completed. And now we can go ahead and state our dynamic programming algorithm.