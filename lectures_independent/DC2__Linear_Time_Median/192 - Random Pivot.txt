What's an easy scheme to find a good pivot? Well, if I have no idea what to do, what should I do? I might as well act randomly. So in our case, what does that mean? That means let P be a random element of A, choose a random element of A and said that to be the pivot P. Now, what's the probability that P is a good pivot? Let's look at our thought experiment from before. So let's look at the sorted array A. We're not actually sorting A. We're just looking at the sorted version of A for the purposes of analyzing the probability that P is good. We have the median element. We have the n over four smallest, and we have the 3n/4 smallest and over four smallest. What are our good pivots? Everybody in here is a good pivot. How many good pivots are there? There is exactly n over two good pivots. So, what's the probability a random element is a good pivot? I can order this however I won. The fact is, exactly n over two of these elements are good pivots and there's exactly n choices. So the probability a random element is a good pivot is the number of choices which lead to a good pivot divided by the total number of choices. The number of good pivots is n over two and the total number of choices is n. Simplifying this, we get one half, exactly half the elements are good pivots. So, no matter how you order this array A, we've got a probability exactly a half of finding a good pivot. Now, given a proposed element as a pivot, how can I check whether it's a good pivot or not. Well, I can just bend order and time and I can break partition A into those elements smaller, equal, or bigger than P. And if I keep track of their sizes as I go along then I can easily check in order and time whether this proposed pivot P is good or not. What happens if it's a bad pivot? What should I do in that case? Well, I can rerun this experiment again. So, I choose a new random element of A and then I check whether it's a good pivot or not. If it's still a bad pivot, then I run the experiment again and I keep going until I find a good pivot. Once I find a good pivot, I use it. In expectation, how many times am I going to have to repeat this experiment until I find a good pivot? This is like flipping a coin. If it ends up with tails, then I'll say that's a good pivot. If it ends up with heads, that's a bad pivot. I got probability exactly a half of finding a good pivot. So I got probably exactly a half of ending in tails. I keep flipping the coin until I get tails. Once I get one tails, that's a good pivot and I start my experiment. How many times am I going to have to flip the coin until I get A tails? In expectation, twice. So it's going to take me O(n) expected time to find a good pivot. So the expected runtime of the whole algorithm is going to be O(n). So this is a reasonable algorithm. But all I have guaranteed is that the expected runtime is O(n). I want an algorithm who's guaranteed worst case runtime is O(n). So, how can we guarantee to find a good pivot in O(n) time? That's the task we're going to try to tackle now.