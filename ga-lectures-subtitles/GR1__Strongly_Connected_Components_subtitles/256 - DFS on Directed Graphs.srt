1
00:00:00,000 --> 00:00:03,693
 We saw how to determine the connected components for an undirected graph,

2
00:00:03,693 --> 00:00:06,420
 now let's take a look at directed graphs.

3
00:00:06,420 --> 00:00:10,590
 How do we determine the connectivity properties for a directed graph?

4
00:00:10,590 --> 00:00:13,509
 Once again we're going to use a DFS based approach,

5
00:00:13,509 --> 00:00:14,827
 but now for directed graphs,

6
00:00:14,827 --> 00:00:17,835
 we're going to need additional information from the DFS.

7
00:00:17,835 --> 00:00:19,440
 The additional info that we use are

8
00:00:19,440 --> 00:00:24,325
 the preorder or postorder numbers for the tree or forest of explorer the edges.

9
00:00:24,325 --> 00:00:28,480
 The algorithm is going to be a slight variant of DFS that we saw just before,

10
00:00:28,480 --> 00:00:32,170
 so let's look at that previous algorithm and just modify it a little bit.

11
00:00:32,170 --> 00:00:36,640
 Here's a DFS algorithm for figuring out the connected components of an undirected graph.

12
00:00:36,640 --> 00:00:38,580
 Our basic algorithm is going to be the same,

13
00:00:38,580 --> 00:00:41,580
 but we no longer need to keep track of the connected component number,

14
00:00:41,580 --> 00:00:43,284
 so let's remove those lines.

15
00:00:43,284 --> 00:00:47,545
 This line, this line and this line.

16
00:00:47,545 --> 00:00:49,375
 We can drop these three lines.

17
00:00:49,375 --> 00:00:53,610
 So I've removed those three lines which talked about the connected component number.

18
00:00:53,610 --> 00:00:57,790
 Now I want to add in lines which take care of the preorder and postorder numbers.

19
00:00:57,790 --> 00:01:00,568
 In order to keep track of the preorder and postorder numbers,

20
00:01:00,568 --> 00:01:02,365
 we're going to add in the clock.

21
00:01:02,365 --> 00:01:04,660
 The preorder number for a vertex Z,

22
00:01:04,660 --> 00:01:08,470
 is going to be the value of the clock when we first visit vertex Z,

23
00:01:08,470 --> 00:01:11,260
 and the postorder number is going to be the value of

24
00:01:11,260 --> 00:01:14,750
 the clock at the time when we finished exploring vertex Z.

25
00:01:14,750 --> 00:01:16,925
 So we looked at all edges out of Z.

26
00:01:16,925 --> 00:01:19,135
 First we need to initialize the clock to one.

27
00:01:19,135 --> 00:01:20,915
 When we first visit a vertex Z,

28
00:01:20,915 --> 00:01:22,660
 we can store as preorder number,

29
00:01:22,660 --> 00:01:24,830
 which is the current value of the clock.

30
00:01:24,830 --> 00:01:27,825
 After we do this, we need to increment the clock.

31
00:01:27,825 --> 00:01:30,425
 Finally when we finish exploring vertex Z,

32
00:01:30,425 --> 00:01:34,790
 then we can set its postorder number to be the current value of the clock.

33
00:01:34,790 --> 00:01:37,420
 And then once again we have to increment the value of the clock.

34
00:01:37,420 --> 00:01:40,385
 That gives as DFS undirected graphs.

35
00:01:40,385 --> 00:01:44,285
 Now we want to see the properties of these preorder and postorder numbers.

36
00:01:44,285 --> 00:01:46,320
 And actually for our connectivity algorithms,

37
00:01:46,320 --> 00:01:48,445
 we're simply going to use the postorder numbers.

38
00:01:48,445 --> 00:01:49,735
 And to be perfectly honest,

39
00:01:49,735 --> 00:01:53,320
 I'm not even sure where preorder numbers come into play.

40
00:01:53,320 --> 00:01:55,635
 The only application I know of for preorder numbers

41
00:01:55,635 --> 00:01:59,035
 are in order to try to trick you on exams or homeworks.

42
00:01:59,035 --> 00:01:59,035
 But just in case I kept the preorder number in here in the algorithm.

