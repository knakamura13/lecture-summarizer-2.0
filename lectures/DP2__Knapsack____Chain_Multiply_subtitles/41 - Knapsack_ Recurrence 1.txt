To summarize, K of i is the max value we can obtain using a subset of the first i objects. And we're trying to find a recurrence which expresses K of i, the solution to the i's subproblem in terms of smaller subproblems. So let's go back and look at our earlier example and see if we get some idea for a recursive relation. In our earlier example, the objects had values 15, the object 1, 10, the object 2, 8 for object 3 and, 1 for object 4. And their weights were 15, 12, and 5. Now, let's look at this one dimensional table K that we're trying to find a recursive relation for. Now let's look at our one dimensional table K, in this example and see if we can figure out a recursive relation for the solutions of K of i in terms of smaller subproblems. So let's fill it in for this example. Let's start with K-1. In this case we're looking at a subset of object 1. So either we use object 1 or we use the empty set. Clearly using object 1 is better because it fits in a backpack and has total value 15. So K of 1 is 15. In this case. Now let's look at K of two, i equals two. In this case we're looking at a subset of objects 1 and 2. So either we use both objects in this case they have total weight 27. So they don't fit in the backpack so we can't use both objects. We can use either object 1 or object 2 or neither. And in this case in this example it's better to use object 1. Now let's go to i equals 3. What's the optimal solution for i equals 3. Well in this case we want to use objects 2 and 3. They have total weight 22. And this is our optimal solution to the entire problem as we saw before and that has total value which is a team. Now note this solution is obtained by using subsets 2 and 3 whereas our earlier subproblems, their solution was obtained by using object 1 only. Now the question is can we obtain this K of 3 which in this case is 18 using K of 1 and K of 2. But K of 3 is obtained by taking a sub optimal solution to i equals 2. We don't want to use the optimal solution because that doesn't allow us to add in object 3 into the backpack. There's not enough spare capacity available so we need to take a sub optimal solution to i equals 2. The key is that that sub optimal solution to i equals 2 has enough spare capacity to allow us to add in object 3. What we really want to do is we want to take the optimal solution to i equals 2 where the total capacity available is in most the total capacity in the original subproblem minus the weight from using object 3. If we're going to add object 3 to our solution then that takes weight W3. And then our capacity available goes down by W3. And we want to take the optimal solution to that smaller subproblem which is i equals 2 in this case and we want to look at the optimal solution with this capacity with the smaller capacity. In this case that capacity is 12. And if we take the optimal solution for i equals 2 with total capacity 12 than object 1 no longer fits and only object 2 fits in there. So the optimal solution will be just using object 2 and add the total value we obtain from that is 10. So this will have total value 10 and therefore we can append on object 3 onto it and we get the solution 2 and 3 and we get the total value 18. What we see from this example is that this definition of the subproblem does not suffice. We're not able to express K of 3 in terms of K-1 and K-2 because the solution to K of 3 does not y- build upon the solution to K- i equals 1 and 1 equals 2. Instead it uses a sub optimal solution 2, i equals 2. What is that suboptimal solution? That suboptimal solution has limited capacity available. It has limited capacity available in order to allow us to later add in object 3 and obtain a better solution for i equals 3. This points us in the right direction because what we need to do is limit the capacity available for these subproblems. So in some sense we want to take a prefix of the objects, 1 through i, and we want to take a prefix of the capacity available. This is going to lead us to our second attempt for the design of a dynamic programming algorithm for this problem. We're going to define the subproblems so that it considers a prefix of the objects and it varies the capacity available.