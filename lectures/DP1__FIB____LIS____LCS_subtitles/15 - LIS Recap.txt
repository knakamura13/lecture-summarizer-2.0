This completes the formulation of our dynamic programming algorithm, and the analysis of its running time. But now, let's go back and take a look at some important aspects of our algorithm design. What was the first step in our recipe for designing a dynamic programming algorithm? It was to define the sub-problem in words. In this case, define alibi in words. Our initial attempt was to use a prefix of the input, to find the length of the longest increasing sub-sequence on the first I elements of the array. Then, our second step in our recipe is to find a recurrence relation that the solutions' sub-problems satisfy. In that case, for that definition, we were unable to do so. So what did we do? We went back and we reformulated our sub-problem definition. We added an extra condition into it, and then we were able to write a recurrence for the sub-problems. Now, the intuition for why we wanted to strengthen the sub-problem definition. It goes back to, if you recall perhaps from a discrete math class way long ago, when you were trying to prove some statement by induction, how did you go about it? Well, you would first state an inductive hypothesis. Usually, the inductive hypothesis is of the same form as the statement that you're trying to prove. Then you try to prove that hypothesis using induction, but sometimes you run into difficulties. And what do you do? You go back and you alter your inductive hypothesis. Typically, what you do is you try to strengthen your inductive hypothesis by adding extra conditions in. That's exactly what we did here, we added the extra condition, that the sub-problem has to include a i itself. Okay? And then, you strengthen the inductive hypothesis and you prove that stronger statement. And that's what we're doing here. We're giving you an algorithm for this stronger problem. We're finding, in length, the longest increasing sub-sequence with the specific character at the end. Using that solution to that stronger problem, we can then solve the weaker problem, where we don't care, what is the ending character. So, a lot of the intuition for what we're doing in dynamic programming, comes from some ideas from induction proofs.