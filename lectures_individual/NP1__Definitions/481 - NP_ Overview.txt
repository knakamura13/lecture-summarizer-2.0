How do we prove that a problem is computationally difficult? Meaning that it is hard to devise an efficient algorithm to solve it for all inputs. To do this, we'll prove that the problem will then be complete. In this section, we'll look at the definition of the class NP and what exactly it means for a problem to be NP-complete. We'll first detail the notion of a reduction. We've actually seen several examples of reductions in this class before. For example, we reduced the two-set problem to the strongly connected components problem. We'll formalize this concept of reduction. Then we'll see what it means that a problem is NP-complete and how to prove that it is NP-complete. We'll look at a bunch of examples of NP-completeness proofs: 3SAT; Graph Problems for example Independent sets, Clique, and Vertex cover; and the classic Knapsack problem. Finally, we'll see Alan Turing's proof that the halting problem is not just computationally difficult but, in fact, it's not solvable in general. Formally, it's undecidable