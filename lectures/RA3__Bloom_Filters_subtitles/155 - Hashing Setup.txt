Now, let's turn our attention back to hashing, which is our main focus. It will be useful to keep a running example in mind to motivate our various hashing schemes. The example we'll use is unacceptable passwords. We want to maintain a database of unacceptable passwords. For example, these might be words that are in the dictionary. Now the setting is, that a user will enter a proposed password and our system should quickly respond if that proposed password is acceptable or not. So we need to quickly check whether the proposed password is in the database of unacceptable passwords or not. Now let's formalize our setting a little bit more precisely. We have a huge set U which is the universe of possible passwords. Now this is an enormous set. For example, if we simply look at passwords as strings or words of length A, then this set is of size 52 to the A, hence this set U is too large to maintain. Instead, we're going to maintain a subset of this universe, which will denote a subset S. S will contain the set of unacceptable passwords. The main operation our data structure needs to perform are queries. So for an element X in our universe. So X is a proposed password in this setting. Is X in this subset S? So is X an unacceptable password? Now we want to build a data structure or hashing scheme, which answers these queries quickly. Let's first look at how the traditional hashing scheme known as chain hashing, works in this setting. Now in order to maintain this set S, we're going to use a hash table H of size N, little N. In chain hashing, this table H is an array of linked lists. We're going to use a hash function little H which maps elements in U two elements and H. So each of the possible passwords is mapped to one of these N bins by little H. Now to insert an element into this subset S we simply find its hash value, then we go to that bin and then we add the element onto the linked list at that particular location. And then to do a query, we simply go to the hash value and we look at the linked list to check whether it's there or not. For each element of the universe, little H of X maps to one of these N bins. Now we're going to analyze random hash functions. So we're going to assume that H of X maps to a random bin. Moreover, we'll assume this choice, this random map, is independent of all other hashes. So where H of X maps to is independent of where any other element of the universe maps to. So this little H is a completely random hash function. Now if you think of this hash table as bins and you think of these elements in S as balls then what this hash function is doing is its assigning these balls into random bins. So it's reminiscent of our balls into bins problem that we analyzed before. Now it will be useful to have a little bit of notation before we move on. This set U is huge, and we'll denote its size by capital N. The hash table, we'll denote its size by little N. Now capital N, as in RSA, will be exponential size in little N, and we'll use little M to denote the size of this database, capital S, that we're maintaining. And once again, capital N is much bigger than little N, and typically our hash table size is at least the size of the database we're maintaining. So little N is at least size M, and our goal of course is to try to maintain this database as not much larger than little M.