let's go ahead and look at how we do this insertion we want to insert this element X into our dictionary of unacceptable passwords first thing we do is compute these two hash values so we compute H 1 of X and H 2 of X think of our balls and bins analogy we have this ball ax and what we've done is we've chosen two random bins H 1 of X and H 2 of X which bin do we add the ball ax into we added into the least loaded at all of these two bins what is the load of the bin it's the size of the linked list we can maintain the size of each of these linked lists so that we can quickly determine which of these two is least loaded and then we can add in X into that appropriate linked list and then we can increment the size of that linked list so this can all be done in order one time for an insertion next question is how do we do a query how do we check whether an element Y up proposed password Y is in our dictionary of unacceptable passwords we start off the same as an assertion we compute the two hash values H one of Y and H 2 of Y these are the two possible locations for Y we have no way of determining which of these two locations it might be in if at all because we have no way of determining what the dictionary looked like at the time that we inserted Y if we did insert Y so what do we do we check both bins we check the linked list at h1 of Y and we check the linked list at h2 of Y and we look for Y in both of these linked lists so we check the linked list at H of H 1 of Y and we check the linked list at H of H 2 of Y and we look in both of these linked lists for the element Y if it's in either of these linked lists then we know that Y is in the dictionary if it's in either of these linked lists then we know that Y was never inserted into a dictionary of unacceptable passwords so how long does it take to do a query or the query time now depends on the load at this location and the load at this location so if we have an upper bound on the maximum load then the query time is twice the maximum load now if M equals n so the size of our date dictionary of unacceptable passwords and the size of our hash table are the same then what we know from our balls and pinion analogy is that the query time the max load is gonna be order log log and in this scenario so just changing from one hash function to a pair of hash functions and using this scheme then our query time goes down dramatically from order log n to order log log n and there's no extra cost in terms of the space though there is a question about how we maintain this hash function H especially if it's a truly random hash function in practice we can't store a truly random hash function instead we use pseudo random hash functions so we use a hash function which we obtain from a library such as ran or D ran 48 but for the purposes as an analysis it's convenient to consider a truly random hash function so that we can do this nice analysis such as how we obtain the order log and max load for the M equals n case for the simple case of one hash function we skipped the analysis for the case of the balls and bins example where we did the two choices where we had each ball going to the best of two random bins in that case we we claimed that the max load is order log log n that analysis is reasonable to do but it's much more complicated so we skipped it in this lecture