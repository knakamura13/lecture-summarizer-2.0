We've seen how to use the DFS algorithm to solve connectivity problems in undirected and directed graphs. Let's quickly remind you of some other common algorithms for exploring graphs. As opposed to DFS, which is depth first search, BFS is breadth first search. BFS explores the graph in layers. The input to the BFS algorithm is similar to the DFS algorithm. It's an undirected or directed graph G in adjacency list representation. But BFS has an additional input parameter. We specify a start vertex which we denote as little s. BFS returns the distance for every vertex from the start vertex little s. The graph G is unweighted, so the distance is defined as the minimum number edges to get from vertex s to vertex v. Now if there is no path from s to v, then this distance is defined as infinite. Now how do we get such a path of minimum length? Well, BFS also returns this previous array, which one can use to construct a path of minimum length from s to v. Now what's the running time of the BFS algorithm? BFS, like DFS, is linear time, so the running time is order n plus m, where n is the number of vertices in the graph G, and m is the number of edges in the graph G. Dijkstra's algorithm is a sort of more sophisticated version of BFS. It solves a similar problem as BFS, but instead, it considers a weighted version of the graph G. As in the BFS algorithm, the input to Dijkstra's algorithm is a graph G. It could be directed or undirected, and we have a specified start vertex, little s. But Dijkstra's algorithm has an additional input parameter. We were given a weight, a length for every edge, and this length has to be positive. What is the output of Dijkstra's algorithm? Well, it is the weighted analog of the BFS output, so it outputs this array dist and dist(v) is the length of the shortest path from s to v. Now one of the key requirements of Dijkstra's algorithm is that these edge lengths are positive. If you want to know how to deal with negative edge lengths, then you should refer to our dynamic programming lecture, DP3. Dijkstra's algorithm uses the BFS framework with the min-heap data structure. The min-heap data structure is often called the priority queue. Each operation in the min-heap data structure takes order log and time, so we get an additional log and factor on the BFS running time, and hence, the total runtime of Dijkstra's algorithm is order n plus m times logn. Now there are other variants of Dijkstra's algorithm with different data structures that they utilize. We'll always refer to the following the min-heap data structure in this class. And for concreteness, in this class we'll say the running time of Dijkstra's algorithm is order n plus m times logn. I assume that many of you have seen BFS and Dijkstra's many times in the past. If you need a quick review, I suggest you look at chapter four of the textbook.