Let's look at the basic idea for that dynamic programming algorithm we're going to construct. First, let's go back and look at the Bellman-Ford algorithm. The basic idea of this algorithm. This was the algorithm where we had a single start vertex and we're looking at the shortest path from that single start vertex, s, to all other vertices. Now, in that dynamic programming algorithm, what we did is we conditioned on the number of edges in length of the path. Obviously, we're going to try to do something different here. What else can we condition on instead of the number of edges? Actually, if you think of our basic dynamic programming approach that we always try, we try prefix of the input. Okay? What is the input here? The input here is the graph, or, one important aspect is the vertices of the graph. So, can we try a prefix of the vertices of the graph? Let's try to formalize that. First off, let's order the vertices, one through n. So, it just assigning numbers to the vertices one, two, up to n. How we do that doesn't matter. Okay? Just the point is, that now we can index the vertices by numbers one through n and we're often doing this anyways, implicitly because we have a table where we have a single one dimensional array for the vertices and we're indexing them by their numbers. Okay? The important thing now is that now we can look at a prefix of the vertices. So, we want to solve the same all pairs shortest path problem, where we only allow a prefix of the vertices to be used. So, we're going to condition on the intermediate vertices that are allowed to be used in the past that we consider. And we're going to go back and use prefixes as we've done them in many problems and we're going to use prefixes of the vertex then, okay? So, let's formalize this more precisely. So, we're going to have three parameters. First parameter is going to be the prefix of the vertex set that we consider. So, we're going to use the variable i for the prefix of the vertex set that we consider. This prefix is going to vary from zero, for the empty set, up to n. And for given i, we're going to consider the set of intermediate vertices one through i. That's going to be the set of allowable vertices to be used as intermediate vertices on the paths that we consider. Now, the other two parameters that we need are the start vertex and the end vertex. And we want to do all pairs, shortest path. So we want to find- try all possible start vertices and all possible end vertices. So let's use s for the start vertex and let's use t for the end vertex. And now, we want to vary s and t over all possible choices. So, we want to try each one through n. So s and t both vary between one and n and we want to try all n square choices for s and t. Finally, let's define our dynamic programming subproblem in words. It's going to be a three dimensional table, now. D of i, s, t, it's going to be the length of the shortest path from s to t. And now, how does i work in? Well, we're going to condition on the set of intermediate vertices that are allowed to be used. Now, the perimeter, i, tells us the prefix of the vertex set which are allowed to be used as intermediate vertices. So that we only consider paths from s to t, where a subset possibly empty set or possibly the whole thing, and we're not saying anything about the ordering of these intermediate vertices, but the only intermediate vertices that can be used on the path from s to t are one through i. And we're going to vary i from zero to n. When i equals n, that means we allow all vertices to be intermediate vertices on the path, so we're considering all paths. So then d of n, s, t, tells us the length of the shortest path from s to t. So, now, let's go ahead and try to find a recurrence for this subproblem definition that we just defined.