Now, let's go ahead and detail the pseudocode for our dynamic programming algorithm to compute the minimum cost for multiplying these and matrices. Recall the input to the problem are the sizes. These n+1 numbers representing the sizes of the N matrices. M zero, M one, up to Mn. Let's start with the base case which corresponds to diagonal entering. The cost for these diagonal entries is zero since there's no computation to be done. Now, we're going to use our width parameter S. We already did the case where the width is zero. So we're going to start with one and go up two with n-1 which is our final solution. Then we have a parameter i which corresponds to the row. Notice that the rows are getting truncated at the end. Let's look at our matrix just to see what we mean by this. Our diagonal as these entries. And then, when we do the off diagonal, I'm going to start at this entry one, two and is going to end at this entry n-1. So it doesn't go down to the bottom row, okay? So that's why it stops at n-s. Once it tell you the index i and it tell you the width, then that defines the index j which is the end of the substring. Therefore, we let j, b, i + s. Now we're going to compute the entry c, i, j. We're going to take a min and we're going to vary over L and keep track of the current min so far. So we're going to initialize the min, the value, the current minimum to infinity. If using infinity makes you uncomfortable you can think of setting this to some huge number. Now, we're going to vary over the choices for the split at L. Recall L can vary between i and j -1. Now, for that split at L let's look at the cost, let's define a variable cur which is the current cost for the current index L. Because Mi -1 ml mj to combine the left and right subtrees. C(i,l) for the left subtree and C(l+1,j) for the right subtree. And we want to compare this to the current best. So the current best is larger than this value cur, then we're going to reset the current best to this current value. Then, the for loop. This is in this for loop, this is in this for loop. We have a bunch of nested for loops. Finally, what we return, our final answer is the top right of our matrix. We return this entry (C(1,n)) which corresponds to the cost, the minimum cost for computing the product of the matrices A1 through An. That completes our dynamic programming algorithm. Now let's take a look at the running time. We have this base case computation which takes order and time. Now, we have this first for loop which is of size order n. Then, we have another nested for loop which is the size at most n. And now we have another for loop which is of size at most n, again. And then within these for loops, it takes order one time for this computation. So we have three nested for loops of size order n each. So the total run time is order n q total time. So that completes our chain multiply dynamic programming algorithm. And the key thing here was that we, instead of using prefixes we had to move on to substrings for the subproblem definition. And then, how we filled in the table was a little bit more complicated. Usually, it's straightforward to fill in the table, we'd go row by row. But for this, when we were using substrings we have to go from the diagonal and then work our way up to the top right.