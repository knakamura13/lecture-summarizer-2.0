That completes the description and the analysis of our algorithm. But before we move on, I want to look at a particular example to illustrate the cleverness of the approach. So, let's take this example. X equals 182 and Y equals 154. If I write 182 in binary, it's 10110110. And 154 in binary is 10011010. Our approach breaks up X into the two halves, XL and XR. And similarly, we have YL and YR. XL is 1011, which is 11 in decimal, and XR corresponds to 6, YL corresponds to 9 and YR corresponds to 10. Now what our algorithm does is it first computes XL times YL, which is 11 times nine which is 99. Then we compute XR times YR which is 6 times 10, which is 60. Finally, we get the non-trivial weird idea. We take XL plus XR, which is 11 plus 6, and we multiply that by 9 plus 10. That gives us 17 times 19, which equals 323. How from this number 182, which can be broken up into 11 and 6, somehow we're working with 17? We combine these two, then we get 182 times 154. That equals 99 times two to the n. In this case, n equals eight. So, two to the eight is 256. Then we take 323 minus 99 minus 60, and we multiply that by two to the four, which is 16. Finally, we add in the last term, 60. And if you plug that into your calculator, that exactly equals 28,028, which is exactly 182 times 154. And the amazing part is this 17 and this 19. How do we get those? That's a very non-intuitive part. That completes the description of this faster multiplication of n-bit integers. There are similar ideas for multiplying matrices, that's referred to as Strassen's algorithm. You can look in the textbook to learn about Strassen's algorithm. I'm going to skip it because algebra gets a bit messy for that. Next we're going to look at linear-time median algorithm. It's a very clever divide and conquer approach.