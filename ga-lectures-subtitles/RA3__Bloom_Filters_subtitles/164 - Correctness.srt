1
00:00:00,000 --> 00:00:03,980
 Let's take a look at the correctness of this algorithm for our queries.

2
00:00:03,980 --> 00:00:06,870
 Suppose x was inserted into our database s,

3
00:00:06,870 --> 00:00:10,390
 and we do a query on x. What do we output?

4
00:00:10,390 --> 00:00:12,600
 Well, when we inserted x into the database,

5
00:00:12,600 --> 00:00:14,610
 we set all of these k bits to one.

6
00:00:14,610 --> 00:00:15,630
 So when we do a query,

7
00:00:15,630 --> 00:00:19,060
 we're guaranteed that all of these bits are set to one,

8
00:00:19,060 --> 00:00:20,410
 and so we're going to output Yes,

9
00:00:20,410 --> 00:00:23,365
 because none of the bits ever change from ones to zeros.

10
00:00:23,365 --> 00:00:25,560
 Bits only change from zeros to one.

11
00:00:25,560 --> 00:00:30,460
 It's a one directional process.So if x was inserted into the database,

12
00:00:30,460 --> 00:00:31,860
 when we do a query on x,

13
00:00:31,860 --> 00:00:33,135
 we always output Yes.

14
00:00:33,135 --> 00:00:34,880
 It is in the database.

15
00:00:34,880 --> 00:00:38,385
 Now, suppose x was not inserted into the database and we do a query on x.

16
00:00:38,385 --> 00:00:40,770
 Sometimes, we might say yes,

17
00:00:40,770 --> 00:00:42,795
 we believe it's in the database.

18
00:00:42,795 --> 00:00:45,525
 In which case, we get a false positive.

19
00:00:45,525 --> 00:00:46,695
 We falsely say that,

20
00:00:46,695 --> 00:00:48,525
 yes, it's in the database.

21
00:00:48,525 --> 00:00:49,920
 How can this occur?

22
00:00:49,920 --> 00:00:54,975
 This can occur if all of the k bits were set to one by other insertions.

23
00:00:54,975 --> 00:00:57,750
 So for each of the k bits of x,

24
00:00:57,750 --> 00:00:59,630
 so take the ith bit.

25
00:00:59,630 --> 00:01:01,715
 So this is hi of x.

26
00:01:01,715 --> 00:01:04,005
 There is some element, z,

27
00:01:04,005 --> 00:01:08,580
 which was inserted into the database s and one of the k bits for

28
00:01:08,580 --> 00:01:13,385
 z exactly matches the ith bit of x.

29
00:01:13,385 --> 00:01:14,655
 Which of the k bits for z?

30
00:01:14,655 --> 00:01:16,955
 Let's say the Jth bit for z.

31
00:01:16,955 --> 00:01:21,630
 So the Jth bit for z matches the ith for x.

32
00:01:21,630 --> 00:01:25,590
 In other words, h_i of x as the ith for x,

33
00:01:25,590 --> 00:01:28,590
 matches the jth bit of z.

34
00:01:28,590 --> 00:01:31,920
 So h_i of x equals h_j of z.

35
00:01:31,920 --> 00:01:36,110
 This means that when z was inserted into the database we did the insert of z.

36
00:01:36,110 --> 00:01:40,195
 Then we set this bit which matches the ith bit of x to one.

37
00:01:40,195 --> 00:01:43,060
 And if this is true for every bit of x,

38
00:01:43,060 --> 00:01:46,320
 so all the k bits of x are set to one by

39
00:01:46,320 --> 00:01:50,510
 some other insertion then we're going to get a false positive on x.

40
00:01:50,510 --> 00:01:54,300
 So this scheme has this extra robustness or redundancy.

41
00:01:54,300 --> 00:01:56,220
 In order to get a false positive,

42
00:01:56,220 --> 00:02:01,170
 we need all of these k bits to be set to one by some other insertions,

43
00:02:01,170 --> 00:02:04,555
 whereas the previous scheme only had one bit which we're checking.

44
00:02:04,555 --> 00:02:09,620
 Now we have k bits which need to get set to one in order to get a false positive.

45
00:02:09,620 --> 00:02:15,185
 So it seems like things improve that the false positive rate goes down as k increases.

46
00:02:15,185 --> 00:02:18,810
 But in fact there's an optimal choice of k. If k gets too large,

47
00:02:18,810 --> 00:02:22,125
 the false positive rate starts to shoot up again. Why is that?

48
00:02:22,125 --> 00:02:23,405
 Well if k is huge,

49
00:02:23,405 --> 00:02:28,135
 then for every insertion you're setting k bits to one.

50
00:02:28,135 --> 00:02:31,155
 So you're setting many bits to one if k is huge.

51
00:02:31,155 --> 00:02:33,495
 So that means that for each of these and insertions,

52
00:02:33,495 --> 00:02:35,310
 each of these elements in s,

53
00:02:35,310 --> 00:02:36,540
 they have many bits,

54
00:02:36,540 --> 00:02:39,810
 many choices of j which are set to one.

55
00:02:39,810 --> 00:02:42,405
 So it's more likely if k is big,

56
00:02:42,405 --> 00:02:47,250
 that one of these k bits is going to match up with one of the bits of x.

57
00:02:47,250 --> 00:02:48,420
 So if k is too large,

58
00:02:48,420 --> 00:02:51,105
 every insertion is setting too many bits to one.

59
00:02:51,105 --> 00:02:53,670
 If k is small, then when we're checking it,

60
00:02:53,670 --> 00:02:55,830
 when we're doing the query on x,

61
00:02:55,830 --> 00:02:57,915
 we're checking too few bits.

62
00:02:57,915 --> 00:03:00,150
 So there's some optimal choice of k,

63
00:03:00,150 --> 00:03:02,520
 not too large and not too small.

64
00:03:02,520 --> 00:03:06,600
 What we want to do now is more precisely analyze these false positives.

65
00:03:06,600 --> 00:03:09,205
 What's the probability of a false positive?

66
00:03:09,205 --> 00:03:12,420
 We want to look at it as a function of k and then we can figure out

67
00:03:12,420 --> 00:03:16,605
 the optimal choice of k in order to minimise the false positive rate.

68
00:03:16,605 --> 00:03:19,920
 And then we can compare and see what that false positive rate

69
00:03:19,920 --> 00:03:19,920
 looks like to see whether this is a good data structure to use

