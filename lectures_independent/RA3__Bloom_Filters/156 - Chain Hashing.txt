Once again, in the traditional hashing scheme, chain hashing, H or hash table is an array of linked lists. H is an array of size N, and H of I, the Ith element of H, is a linked list of elements in our subset S which map to I. So, in other words, H of I is a linked list of those elements. So, those unacceptable passwords whose hash value is exactly I. Let's look at the query time. How long does it take us to answer a query of the form? Is X in a subset S, that we're maintaining. Now, in order to answer this query, what we have to do is look at the hash table at the index I, which is H of X, and then we have to go through that entire linked list and check whether X is in there in that linked list or not. So, the time it takes us, is proportional to this size of this linked list. What's the size of this linked list? It's the load at this bin. If we think of the elements of S as balls, these are getting assigned to bins, which are their hash values. The time it takes us to answer a query is proportional to the load size at the hash value. Let's introduce some notation. Let M be the size of our dictionary of unacceptable passwords, and let little n, be the size of our hash table. So, in our balls in bins analogy, little m is the number of balls that we're throwing in, and little n is the number of bins. Now, if m equals n, so the number of balls is the same as the number of bins. This is the toy problem that we analyzed before, and what we saw is that the max load is order log n, with high probability. Of course, in the worst case it might be, order n or n might be the max load, but that's an unlikely event. With high probability, the max load is going to be order log n, which means in the query time in the worst case, it's going to be order log n with high probability. Now, when n is huge, then order log n might be too slow for us. So how can we achieve faster query time? Well, one way is to try to increase the size of our hash table. In order to decrease this max load from order log n to order one, so that the query time will be order one constant time queries. We're going to have to increase the size of the hash table from order m to order m squared. Now, that's quite a large price to pay. So let's see if there are simpler ways to achieve reductions in the query time. Now, our intuition for the following scheme is comes from the balls and bins example from before. This is a simple scheme that we use right now. We're sending n balls into n bins. Each ball is going into a random bin. What do we use to improve that balls and bins scheme, to improve the max load? Well, we use the two choice scheme, and what we saw is that the max load goes down to order log log n, when we allow each ball to go to the least loaded of two random bins. So, let's try and use a similar scheme now for hashing.