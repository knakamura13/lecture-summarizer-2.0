1
00:00:00,000 --> 00:00:04,420
 How can we find whether a graph has a negative way cycle or not?

2
00:00:04,420 --> 00:00:06,865
 Let's go back and look at our earlier example.

3
00:00:06,865 --> 00:00:14,010
 Here's our earlier example on six vertices and it has a negative weight Cycle A B C A,

4
00:00:14,010 --> 00:00:16,050
 which is of length negative one.

5
00:00:16,050 --> 00:00:18,300
 So, what's going to happen for our algorithm,

6
00:00:18,300 --> 00:00:21,990
 Bellman Ford algorithm that we just defined on this example?

7
00:00:21,990 --> 00:00:25,035
 Let's look at the Bellman Ford algorithm on this example.

8
00:00:25,035 --> 00:00:26,520
 We're going to have a two dimensional table.

9
00:00:26,520 --> 00:00:30,250
 The columns the columns of the tables are going to be the vertices of the graph.

10
00:00:30,250 --> 00:00:31,845
 There are six vertices of the graph,

11
00:00:31,845 --> 00:00:33,180
 S, A, B, C,

12
00:00:33,180 --> 00:00:37,360
 D, E. The rows of the table are going to correspond to the path lengths we consider.

13
00:00:37,360 --> 00:00:40,000
 We're going to start with the base case, I equals 0.

14
00:00:40,000 --> 00:00:43,815
 In the base case we have D of 0S as 0,

15
00:00:43,815 --> 00:00:46,075
 and the other entries are infinite.

16
00:00:46,075 --> 00:00:49,240
 Our algorithm can fill up the table from I equals 1,

17
00:00:49,240 --> 00:00:52,555
 I equals 2, I equals 3, I equals 4, I equals 5.

18
00:00:52,555 --> 00:00:55,140
 The current algorithm is going to finish at I equals 5,

19
00:00:55,140 --> 00:00:57,585
 which is N minus 1 in this example.

20
00:00:57,585 --> 00:01:01,410
 But let's do one more row of the table and see what happens.

21
00:01:01,410 --> 00:01:03,870
 Now, let's go ahead and fill in the table by hand.

22
00:01:03,870 --> 00:01:05,251
 In this particular example,

23
00:01:05,251 --> 00:01:07,090
 the column for S is going to stay 0,

24
00:01:07,090 --> 00:01:10,637
 since there's no edges into S. Now let's look at the row I equals 1.

25
00:01:10,637 --> 00:01:14,160
 There's a path using one edge from S to A.

26
00:01:14,160 --> 00:01:15,760
 That's of length 5.

27
00:01:15,760 --> 00:01:19,665
 All of the vertices are inaccessible by at most one edge.

28
00:01:19,665 --> 00:01:22,240
 So their length stays infinite.

29
00:01:22,240 --> 00:01:26,130
 Now for I equals 2 we update the length to B to be 8.

30
00:01:26,130 --> 00:01:31,960
 The other vertices stay infinite and A stays 5.

31
00:01:31,960 --> 00:01:36,320
 For I equals 3 we can update the path length to C,

32
00:01:36,320 --> 00:01:41,565
 which is it going to be of length 2 using the path from B minus 6.

33
00:01:41,565 --> 00:01:47,875
 In addition we can update the path length to D. The path to B is A plus 4,12.

34
00:01:47,875 --> 00:01:50,195
 And the other vertices are going to stay the same.

35
00:01:50,195 --> 00:01:53,015
 Now for I equals 4, we can update the path length to E

36
00:01:53,015 --> 00:01:57,450
 going through C which is of length 2 plus 5.

37
00:01:57,450 --> 00:02:02,045
 That gives us a path of length 7 to E. Now the other interesting thing is,

38
00:02:02,045 --> 00:02:04,860
 that there's a path to A itself.

39
00:02:04,860 --> 00:02:13,091
 So we can go to C of length 2 and then we can go back along this edge from C to A,

40
00:02:13,091 --> 00:02:15,210
 which is of length 2.

41
00:02:15,210 --> 00:02:19,950
 And then we get a new path to A going along this cycle,

42
00:02:19,950 --> 00:02:21,585
 which is of length 4.

43
00:02:21,585 --> 00:02:23,435
 So that's a shorter path to A.

44
00:02:23,435 --> 00:02:30,660
 The path length to A went down from 5 - 4 using this cycle as negative weight cycle.

45
00:02:30,660 --> 00:02:32,910
 And the other Bursey stay the same.

46
00:02:32,910 --> 00:02:37,055
 Now let's continue. Notice, now we can update the path length to B,

47
00:02:37,055 --> 00:02:42,005
 because A's distance went down from 5 - 4.

48
00:02:42,005 --> 00:02:46,730
 So now the path length to B using A goes down to 7.

49
00:02:46,730 --> 00:02:48,800
 And the other vertices stay the same.

50
00:02:48,800 --> 00:02:52,660
 Now since the path length to B went down, actually,

51
00:02:52,660 --> 00:02:57,530
 we can update the path length to D and also to C. The path length to C now

52
00:02:57,530 --> 00:03:03,010
 goes down to 1 and the path length to D goes down to 11,

53
00:03:03,010 --> 00:03:07,230
 7 - B plus 4 and the other vertices stay the same.

54
00:03:07,230 --> 00:03:09,930
 Notice that when there is a negative weight cycle,

55
00:03:09,930 --> 00:03:14,700
 then every row is going to be different from the previous row.

56
00:03:14,700 --> 00:03:18,070
 It's going to be the next step on this cycle.

57
00:03:18,070 --> 00:03:21,350
 And that next vertex on that cycle is going to

58
00:03:21,350 --> 00:03:24,530
 have shorter path length than it previously had.

59
00:03:24,530 --> 00:03:26,240
 So A is going to decrease,

60
00:03:26,240 --> 00:03:27,665
 and then B is going to decrease,

61
00:03:27,665 --> 00:03:29,770
 and then C is going to decrease, and then A is going to decrease,

62
00:03:29,770 --> 00:03:32,114
 then B and C and A and so on.

63
00:03:32,114 --> 00:03:34,250
 So every row is going to be different.

64
00:03:34,250 --> 00:03:36,050
 So normally if there's no negative weight cycle,

65
00:03:36,050 --> 00:03:41,635
 then notice our algorithm was going to stop at the case I equals N minus 1,

66
00:03:41,635 --> 00:03:43,884
 which is I equals 5 in this example,

67
00:03:43,884 --> 00:03:48,323
 because every path used a vertex at most once.

68
00:03:48,323 --> 00:03:53,510
 So the maximum path length was at most five edges and minus one edges,

69
00:03:53,510 --> 00:03:56,570
 but if there's a negative weight cycle then what we're going to

70
00:03:56,570 --> 00:04:00,075
 have is that I equals N is going to be different.

71
00:04:00,075 --> 00:04:02,795
 It's going to be smaller than I equals N minus 1,

72
00:04:02,795 --> 00:04:06,495
 because every row is going to shrink further.

73
00:04:06,495 --> 00:04:09,590
 So if there's no negative weight cycle and we can stop here.

74
00:04:09,590 --> 00:04:13,220
 But if there is a negative weight cycle then what we're going to notice is that,

75
00:04:13,220 --> 00:04:18,580
 I equals N is going to be different from I equals N minus one.

76
00:04:18,580 --> 00:04:20,930
 So how do we detect a negative weight cycle?

77
00:04:20,930 --> 00:04:26,010
 We compare these two rows and if I equals N is different

78
00:04:26,010 --> 00:04:31,985
 from I equals N minus 1 then that shows us that there is a negative weight cycle.

79
00:04:31,985 --> 00:04:33,837
 So how do we check that there's a negative weight cycle?

80
00:04:33,837 --> 00:04:40,620
 We check if the entry D of NZ is smaller strictly smaller than D of N minus 1Z.

81
00:04:40,620 --> 00:04:43,850
 For some Z, some vertex Z.

82
00:04:43,850 --> 00:04:50,990
 So the- the row I equals N is different from the row I equals N minus 1 in some entry Z.

83
00:04:50,990 --> 00:04:55,050
 If that is the case then there is a negative weight cycle and it involves Z.

84
00:04:55,050 --> 00:04:56,410
 And actually we can backtrack,

85
00:04:56,410 --> 00:05:02,715
 we can see that that cycle involved is vertex C and then we can see it involves B and A.

86
00:05:02,715 --> 00:05:05,660
 So we can detect that cycle, C, B, A.

87
00:05:05,660 --> 00:05:08,340
 But our check is just we take our algorithm from before,

88
00:05:08,340 --> 00:05:09,420
 our Bellman Ford algorithm,

89
00:05:09,420 --> 00:05:15,735
 which ran from I equals 1 to N minus 1 and instead we run it from I equals 1

90
00:05:15,735 --> 00:05:22,500
 to N and we check if the row I equals N is different from I equals N minus 1.

91
00:05:22,500 --> 00:05:23,770
 If it is different,

92
00:05:23,770 --> 00:05:26,060
 then we found a negative weight cycle.

93
00:05:26,060 --> 00:05:31,145
 If it's not different, then we output the row I equals N minus 1 or the row I equals N,

94
00:05:31,145 --> 00:05:33,660
 because they're both the same and that gives us

95
00:05:33,660 --> 00:05:36,525
 the shortest path length from s to every other vertex.

96
00:05:36,525 --> 00:05:42,240
 So that completes the dynamic programming algorithm known as Bellman Ford for finding

97
00:05:42,240 --> 00:05:44,960
 the shortest path from a single source

98
00:05:44,960 --> 00:05:48,800
 vertex and it allows positive and negative weight edges.

99
00:05:48,800 --> 00:05:50,640
 And if there is negative weight edges,

100
00:05:50,640 --> 00:05:50,640
 it can detect whether or not there is a negative weight cycle.

