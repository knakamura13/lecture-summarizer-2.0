So in the repeated squaring algorithm, we start off the same. We compute X_mod_N and let's store the answer as a_one. Then we compute X_squared_mod_N. How do we get X_squared? Well, a_one is X_mod_N, so we take a_one_squared_mod_N. So far it's the same as the other algorithm. Now we're going to skip X_cubed and we're going to go to X_to_the_fourth. How do we get X_to_the_fourth? We take the previous solution, let's call it a_two and we square that. A_two is congruent to X_squared_mod_N, so if we take X_squared and we square that, then we get X_to_the_fourth. Then we take that solution and let's call it a_four. Now to compute X_to_eighth_mod_N, you take the previous solution and we square that. That gives us X_to_the_fourth_squared which is X_to_the_eighth_mod_N. And we repeat. What do we end up with? We end up with X raised to the powers of two. Then what do we do? We look at the binary representation of Y and then we can use the appropriate powers of two and we can get X_to_the_Y_mod_N. Let's look at a specific example so you illustrate the idea better.