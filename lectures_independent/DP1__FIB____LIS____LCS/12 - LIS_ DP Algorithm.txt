Now, let's date the pseudocode for the dynamic programming algorithm for the longest increasing subsequence problem. And I kept the recurrence from the previous slide about the L of i in terms of smaller subproblems as a sort of crib notes for ourselves. Here's a pseudocode for our dynamic programming algorithm for the LIS problem. The input is a1 through an. Our solutions are in one dimensional array L and we're going to fill the table L from bottom up. So we're going to start at index i equals 1 and go up to i equals n. So we're going to have a single for loop for i going from 1 to n. Now our subproblem formulation requires that ai is included in the solution for L of i plus one term. Therefore, we start by setting L of i equal to 1. And then we're going to do the max over j. So we're going to have another for loop which varies j from 1 to i minus 1. Now we need to check that aj is strictly smaller than ai. If aj is strictly smaller than ai, then we need to check if the solution we can obtain by appending ai onto the end of the solution ending at aj is longer than our current best solution. So if aj is strictly smaller than ai, and our current best solution L of i is strictly smaller than the new solution, we can obtain by appending ai onto the end of L of j. In this case we want to update our current best solution, which is now the solution that we obtained by appending ai onto the end of the solution that ends at aj. Now we've given an algorithm which defines our table L. But what is the solution that we're trying to output from this algorithm? For the case of Fibonacci numbers, it was the last entry in the table. In this case, the last entry of the table is the longest increasing subsequence ending at an. That's not necessarily the solution that we're trying to obtain. We're trying to find the longest increasing subsequence regardless of where it ends at. So what we need to do is try to look through L and find out maximum entry in the entire one dimensional array. So let's go ahead and do that. We'll make a variable max, which will maintain the index with the largest entry of the table. We'll start max at 1 and then we'll go through the entries at the table to see if we find a larger entry than the current max. This for loop simply finds the largest entry of the table and stores the index for that entry in the variable max. Finally, what do we return? We return the entry at index max. This completes the formulation of our dynamic programming algorithm. Now let's take a look at the running time of our algorithm.