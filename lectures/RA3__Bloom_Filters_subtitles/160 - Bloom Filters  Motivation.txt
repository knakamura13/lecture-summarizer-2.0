Now we can finally describe Bloom filters. Let's keep in mind this running example from before the case of unacceptable passwords. We're going to describe a new data structure that has faster queries. Recall in the traditional hashing scheme that we previously described, the query time was order log in for the simple scheme or order log log in for the more advanced scheme which used the power of two choices that are ideal. Here we're going to achieve query time order one. So constant query time, and this is guaranteed. Recall that the other query times were probabilistic statements. So with high probability the query time was order log in or order log log in. In the worst case it was order N. But here it's guaranteed to always be constant query time. This data structure will be very simple and it will use less space than before. There are no linked lists or anything like that. It will just be a simple binary array. Now there are a lot of benefits. It's simpler, less space, faster queries. Now there must be some cost for this simplicity and this faster time. So what is the cost, what is the tradeoff for this scheme? Well, this scheme is not always correct. Occasionally, there are false positives, and this happens with some probability that we'll analyze. We'll try to figure out what is this probability of false positives occurring. What exactly do we mean by false positive? We have an element X which is not in our dictionary of unacceptable passwords. So this is an acceptable password, but our algorithm occasionally says, yes this X is in the dictionary. In this setting false positives are acceptable. Why? Because we have an acceptable password but we say that the password is unacceptable. It's in our dictionaries. So we falsely say that the password is in our dictionary of unacceptable passwords. So somebody types in a password and we say, no that's not allowed. Ideally, it should have been allowed, but we said that, no is not allowed. So then the user has to enter a new password. But in exchange for these false positives we have guaranteed query time. So we answer the question of whether it was an acceptable password or not quickly. And in this setting false positives are reasonable. False negatives that would have been a big cost, that would have been unacceptable in this setting. When we have an unacceptable password we definitely want to say it's unacceptable. If we have an acceptable password, okay. If we occasionally say that it's an unacceptable password that's okay. So in this setting it's reasonable to have false positive with some small probability that we'll try to bound. In other settings it may be unacceptable to have false positives. In which case bloom filters might be a bad idea. So this is not a universal scheme. You have to look at your setting and determine whether the price of having a simpler and faster scheme is worth the cost of having false positives. Is it acceptable to have false positives with some small probability?