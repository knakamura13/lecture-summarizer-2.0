Now, let's summarize the recurrence that we have. Now, a recurrence is going to have two scenarios. Either we include object i, or we don't include object i. First off, we have to know whether object i even fits in the backpack or not. If it doesn't fit, then we know we cannot exclude object i. So, we have to condition on whether the weight of the ith object, Wi, is smaller than b or not. If it is smaller than b, then the ith object can fit in the back pack. So, we're gonna take the best of the two scenarios, either including object i or not including object i. If we include object i, we gain value Vi, for object i, plus, we gain the value from the optimal solution to the subproblem which uses a subset of objects 1 through i-1 and has total capacity available b-Wi. The -Wi is because we included, we forced Wi and object i to be included in the backpack. The other scenario is that we don't include object i in the solution and then, the optimal solution to this subset of objects 1 though i is also going to be a subset of objects 1 through i-1, since object i is not being included. And the total capacity available, it stays the same. And we're going to take the best of these two scenarios, which means we're going to take the max of these two entries. In the other case, the weight of object i is strictly larger than b, and therefore it can't get included in the backpack. So then, our entry k(i, b) is just going to be the second scenario. This defines a recurrence, but to be complete, let's define the base cases and then we can go ahead and write the pseudo-code for our dynamic programming algorithm. For the first row of our table, then i=0. That means we're taking a subset of objects which are the empty set. We're taking a subset of the empty set. Therefore, there's no objects that can get included. So, the max value we can obtain is zero. Similarly, for the first column, we have total weight available, zero. Therefore, no objects can be included and therefore the max value we can obtain is, again, 0. Now, we can go ahead and write the pseudo-code for our algorithm, but let's take a look first at how we're going to do it. We have this table. It's a two dimensional table and we're going to fill this table row by row. And the point is, that when we fill the entry k(i, b), notice our recurrence, it always uses an entry from the previous row, either the entry right above is k(i-1, b) or an earlier entry in that previous row. So, if we filled the table row by row and the entries we need for the smaller subproblems for our recurrence will be there, already completed in the table.