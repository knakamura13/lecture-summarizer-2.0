Once again, we take this LP, and we find the optimal point, and we denote the optimal point by this vector Y ^* and Z ^*. Hats correspond to LP's, so they might be fractional values. Without the hats, it corresponds to integer so our goal is to find an integer point, we'll denote it by YI and ZJ. We drop the stars because it might not be optimal any longer, but we want this integer point that we find by rounding this point. We want this integer point that we find to be close to the optimal integer point. How do we prove that this point that we find, this integer point that we find is close to the optimal integer point because we don't know at this point? Well, we show that this rounding procedure doesn't change the objective function too much. So this integer point that we find is close to this optimal fractional point, this optimal LP solution, and this is at least as good as this. Therefore, if this is close to this one, then it's also close to this point. How do we round from this fractional point to this integer point? We'll call our LP and our integer linear program had the constraint that these variables are constrained between 0 and 1. Therefore, this optimal solution also satisfies these constraints so YI*^ is between 0 and 1. Therefore, we can think of it as like a probability so we're going to round this, so we're going to set YI to be 1 or 0 with probability proportional to this. With probability YI^* is between 0 and 1, and it's a real number. With that probability, we set YI to be one. So if this is 3/4, then with probability 3/4, we set YI to be 1. And with probability 1/4, we set it to be zero. This is known as randomized rounding. Now this actually completes our algorithm. We have assignment now. We have a true false assignment for the variables in the original formula. So we've taken this fractional point, and we round it to an integer point. Notice we don't have around these Z's, we just have to round these Y's. Now, if YI = 1, then we that the variable XI to be true. If YI = 0, we set the variable to be false. So we have a true-false assignment for the X's, and it's a randomized algorithm for setting these X's. So, as we did before, we wanted to look at the expected performance of this randomized algorithm.