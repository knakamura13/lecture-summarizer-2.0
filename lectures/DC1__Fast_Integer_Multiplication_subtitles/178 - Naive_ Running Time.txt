Let's go ahead and analyze the running time of this algorithm. How long does it take us to partition x into the two halves and y into the two halves? These steps take us O(n) time, in order to break up x into the first n/2 bits and the last n/2 bits and similarly for y. How long does it take us to recursively compute these four products A, B, C and D? These are each pairs of n/2 bit numbers. So if we use T(n) to denote the running time and the worst case for inputs of size n, then each of these takes T(n/2), and there's four of them. So the total time for these four recursive subproblems is 4 times T(n/2). Finally, given the solutions to these four recursive subproblems, how long does it take us to compute z? Well we have three additions of O(n) bit numbers. How long does that take? That takes O(n) time. We also have to multiply this O(n) bit number times 2 to the n. How do we do that? Well it's much faster than a multiplication which takes O(n) square time. This is just a shift n times. In order to multiply by 2 to the n we just have to shift this number A, n times. Similarly, to multiply this number C + D times 2 to the n/2 we have to shift it and n/2 times. So it just takes O(n) time to do this multiplication by a power of 2. So to compute z, it takes us O(n) time. So the total time is O(n) + 4 times T(n/2). So let's look at T(n) denote the running time of this algorithm EasyMultiply on input of size n and this is for the worst input. So we take the worst input of size n and T(n) is the running time on that worst case input. We just looked at the running time of our pseudocode and we saw the T(n) satisfies the following relation. We have four subproblems of size n/2 each. And we take an additional O(n) time to combine these solutions together to get the product of x times y. So the running time for an input of size n, is at most 4 times T(n/2) + O(n). Now if you remember how to solve recurrences or this is a good time to brush up on it, this recurrence might look familiar. And what you might recall is that this recurrence solves to O(n) square. So, the easy divide and conquer algorithm that we just described takes O(n) square time. So the running time of this divide and conquer algorithm is the same as of running time of the straightforward multiplication approach. Can we improve this? Can we do better? The key thing is, can we improve this four down to three? Can we get away with just doing three subproblems? This is where we're going to utilize the Gauss's idea that we talked about.