Now, let's go ahead and see if we can write a recurrence for this subproblem definition. So let's try to express K(i,b) in terms of smaller subproblems. We're going to try to use the insight that we had from the previous version of knapsack. So we're going to have two scenarios. Either we include object i or we don't include object i and we're going to take the best of those two so we're going to take the max. Now, as in the other version of knapsack, we're going to have two scenarios. In the other version of knapsack, we either included object i or we didn't include object i. In this version of the problem, we're going to have two scenarios. Either we include no more copies of object i or we're going to add in another copy of object i. Now, in the first scenario where we have no more copies of object i then the remainder of the set is going to be a subset or a multiset actually of objects 1 through i minus 1 with the total capacity available staying the same. Therefore the solution is k of i minus 1 B. Now in the other scenario where we're adding in another copy of object. And for that copy of object we get value v i. And in addition we get the optimal solution to this subproblem where the capacity went down by w i. So that capacity went down by w i. So the capacity available is now b minus w i. But notice here the first index is i, whereas in the other version of knapsack it was i minus 1 because in this version, we're allowed to use object i again even another copy, additional copies, whereas in the other version of knapsack once we use the object i which is what's happening in this case then we could no longer use object i. So this went down to i minus 1 to keep track that we didn't allow ourselves to use it multiple times. Now let's take a look. Is this recurrence in fact a valid recurrence? Are we expressing this current subproblem in terms of smaller subproblems? Previously, when we wrote recurrence for the current entry we always expressed it in terms of entries in previous rows. So this would be this one is in row i and the previous ones were in a row i minus 1. But in this case, we're actually using the same row. Let's look at the table. We're going to fill this table row by row and when we get to this entry, k i b, this current entry, okay, we've filled up the previous rows and we filled up this current row up to that entry. Now, what entries do does this recurrence require? Well, it requires the entry which is one row above. And in addition, it requires the entry which is in the same row but it's earlier in that row. So that will already be completed in the table. So these two entries that are acquired by this recurrence are already completed by the time we get to this current entry, k i b. So it's a valid recurrence that expresses k i b the current subproblem in terms of smaller subproblems. So we can go ahead and actually use the same pseudocode as before with the slightly different recurrence. Of course, we also have to condition on we have to make sure that the i object fits in the remainder remaining capacity. So we can only do this case when this holds. So if w i is the most b, then we take the best of these two scenarios. If w i is bigger than b then we can only use this case just as before and the other um pseudocode for the other version of knapsack. And what's our running time going to be? Well, we got a table of size n times b. That's the size of our table and to fill each entry it's going to take us order one time. So a running time is going to be order and times capital B just as before. So I won't go I won't detail it because it's almost the same pseudo code is for the other version of knapsack.