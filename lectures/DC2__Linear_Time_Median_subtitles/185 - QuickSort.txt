Now we're going to use divide and conquer to solve this case smallest problem and our algorithm, the basic approach is going to be quite reminiscent of the quicksort algorithm. Let me remind you about the quicksort algorithm and then we'll see the modifications for our approach. So we're looking at quicksort for sorting this unsorted list A. The first step in the quicksort algorithm is to choose a pivot, p. Then we partition the array A into three buckets based on their relation to the pivot p. One bucket is for those elements strictly smaller than p, those equal to p, and those strictly bigger than p. We do one scan through the array A and we put each element into one of these three buckets. Then we recursively run quicksort on the small elements and the big elements. We take that output and our final output is the sorted list of the small elements, followed by the equal elements, followed by the big elements. Now recall the whole challenge in quicksort is how to choose a good pivot. If we chose a terrible pivot, such as the smallest element or the largest element, then one of these two lists is going to be of size n minus1. It's just going to go down by one element and then the running time of our algorithm is going to be order n square. So what's a good pivot for quicksort? It's the median, or something close to the median. For our problem we're going to have the same challenge. How to choose a good pivot? That's going to be the main task. But quicksort ideally runs in order n log n time. We're aiming for an order n time algorithm. The key is that we don't have to recursively consider both a less than p and a bigger than p. We only have to recursively search in one of these two lists. Let's look at a specific example to see exactly what I mean for this third step.