So let's design a dynamic programming algorithm for the single source shortest path problem. We're given as input a graph and it's a directed graph. And the edges of the graph are waited, and they are waited arbitrarily so they can be positive, some can be negative, so we can no longer apply Dijkstra's algorithm. And we have some specified start for text S, and our goal is to find the shortest path from S to every other vertex. Now what about negative weight cycles? Let's assume for now that there are no negative weight cycles in the graph and therefore, the shortest path length from S to every other vertex is well-defined. We're going to visit every vertex at most once. We'll see how to solve this problem and then we'll see a slight tweak of the algorithm will detect whether there exists a negative weight cycle or not. But for now, let's assume there's no negative weight cycles in the graph. Problem is well-define. Since there are no negative weight cycles in the graph, as we just noticed, the shortest path from the start vertex S to any other particular vertex Z visits every vertex at most once. There's no reason to repeat a vertex because the cycles all have positive length. So let cal P denote the path, the particular path which is of shortest length from S to Z. If there's multiple ones let P be any particular one of shortest length. Since we visit every vertex at most once, what do we know about the length of P? P contains at most N minus one edges because we visit every vertex at most once. Now let's try to design a dynamic programming algorithm for this single source shortest path problem. Normally we try to use a prefix of the input in our dynamic programming algorithm. Here it's going to be a little different type of solution. Notice that the path length is at most N minus one edges. Let's try to use a prefix of the path. What do we mean by that? Let's try to condition on the number of edges in the path. What we're going to do is to introduce a variable I which is going to vary from zero to N minus one. And this is going to be the number of edges that we allow on the pass that we consider. When I equals N minus one, then we're going to allow the pass to be of length at most N minus one edges and that's going to solve the shortest path problem. It's going to be the final solution. At the beginning, the base case I equals zero, we don't allow any edges. That's more formally defined the subproblem for a dynamic programming algorithm. We're going to have two parameters, I and Z. I is going to vary between zero and N minus one and Z is a vertex of the graph. And we're going to find the function capital D of I, Z. This is going to denote the length of the shortest path from S to Z, but we only consider pass which use at most I edges. So when I is N minus one then this is the final solution that we're looking for and we're going to build up our solutions starting from I equal zero and building it up to N minus one. So now let's try to write a recurrence for D of I, Z. Our goal is to express D of I, Z in term of D of I minus-