Let's dive into the FFT algorithm. It's a divide and conquer algorithm. So let's start with the base case. The base cases is when N equals one. What are the roots of unity in this case? Well, it's just one. So we can simply return A evaluated at the point one. Now, we have to partition this vector A into A even and AI. These correspond to the polynomials A even and AI. So let A even, the vector A even be even terms in the vector A. So A naught, A2, A4 up to AN minus two, and A odd are the odd terms. So A1, A3 up to AN minus one. The input vector A was a vector of size N. These two vectors A even and AI that we just defined are vectors of size N over two. Now, we have our two recursive steps. We call FFT the same algorithm with the vector A even, and instead of Omega, we use Omega square, and we also call FFT with A odd and also Omega square. What do we get back from this call? What we get back is A even at the square of these endpoints, which are these N over two points. Omega naught, Omega square, up to Omega to the N minus two. So if Omega is the Nth root of unity, then we get A even at the N over second roots of unity. And similarly, we get A odd at the N of a second roots of unity. Notice that if Omega equals Omega sub N, then the Jth of these points square is the Jth point in this sequence or actually the J plus first. This is Omega sub N over two to the Jth power. So this is the Jth or J plus first of the N over second roots. Now using these values for A even and A odd we can get A at the Nth root to unity. Now we use our formula for A of X in terms of A even and AI. So A evaluated at the point Omega to the Jth power equals A even, evaluated at this point square, plus Omega to the J times A odd at this point square. And similarly, if we look at the point Omega to N over two plus J. This is the opposite of Omega J. So using the same formula, this requires A even and A odd at exactly the same points. The only difference is we subtract these two terms instead of adding them together. This takes order one time for each J. So it takes order N total time. Finally, we have A evaluated at these endpoints and that's our output that we returned from the algorithm. Now, notice this algorithm works for any Omega which is an Nth root of unity. We only require that Omega to the Jth power is opposite Omega to the N over two plus J. That's true for any root of unity except when Omega is one, because then this would be one and this would also be one. So they're not opposites of each other, but for any other root of unity, the Jth power is opposite the N over second plus to the Jth power.