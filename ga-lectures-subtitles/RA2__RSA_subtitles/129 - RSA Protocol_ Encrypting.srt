1
00:00:00,000 --> 00:00:03,270
 Now, let's look at things from Alice's perspective.

2
00:00:03,270 --> 00:00:06,830
 Alice has a message M that she wants to send to Bob.

3
00:00:06,830 --> 00:00:09,035
 What's the first step that Alice does?

4
00:00:09,035 --> 00:00:13,560
 She looks up Bob's public key which is this pair N, E. Now,

5
00:00:13,560 --> 00:00:18,735
 she needs to encrypt her message using Bob's public key. What does she do?

6
00:00:18,735 --> 00:00:20,910
 She encrypts using their public key.

7
00:00:20,910 --> 00:00:22,800
 She takes the message M raises

8
00:00:22,800 --> 00:00:27,900
 its power E and takes that mod N. And that's her encrypted message,

9
00:00:27,900 --> 00:00:30,415
 Y that she sends to the world.

10
00:00:30,415 --> 00:00:33,120
 Now, one key thing is, E might be a little bit large.

11
00:00:33,120 --> 00:00:37,260
 So, how does she raise M to the power E Mod N?

12
00:00:37,260 --> 00:00:40,470
 She uses our fast modular exponentiation algorithm

13
00:00:40,470 --> 00:00:43,230
 that we just saw earlier in this lecture.

14
00:00:43,230 --> 00:00:45,384
 Finally, Alice can send the message Y.

15
00:00:45,384 --> 00:00:48,600
 Now, let's look at the final step of the procedure.

16
00:00:48,600 --> 00:00:49,885
 What happens for Bob?

17
00:00:49,885 --> 00:00:53,650
 Bob receives this encrypted message Y that Alice sent.

18
00:00:53,650 --> 00:00:55,200
 Now, Bob decrypts this message.

19
00:00:55,200 --> 00:00:58,011
 How does he decrypt it? He computes Y,

20
00:00:58,011 --> 00:01:00,360
 this encrypted message, raises it to

21
00:01:00,360 --> 00:01:03,715
 the power D which is his private key and he takes that mod.

22
00:01:03,715 --> 00:01:05,029
 N. What is that going to equal?

23
00:01:05,029 --> 00:01:07,380
 That's going to give him back M. So,

24
00:01:07,380 --> 00:01:12,010
 he's going to end up with the original message M. Let me recall why that's the case.

25
00:01:12,010 --> 00:01:14,215
 Remember, how did we choose D?

26
00:01:14,215 --> 00:01:17,215
 D is the inverse of e mod P minus one Q minus one.

27
00:01:17,215 --> 00:01:22,175
 That means D times E is congruent to one mod P minus 1 Q minus one.

28
00:01:22,175 --> 00:01:25,875
 That means D times Z is one plus

29
00:01:25,875 --> 00:01:29,757
 some multiple of P minus one times Q minus one. Now, what are we doing?

30
00:01:29,757 --> 00:01:33,300
 We're starting with the message M. Alice is encrypting it by

31
00:01:33,300 --> 00:01:36,870
 taking that message M raising it to the power E

32
00:01:36,870 --> 00:01:44,315
 then taking it mod N. Call N is P times Q where P and Q are prime numbers.

33
00:01:44,315 --> 00:01:46,133
 This M to the E is Y.

34
00:01:46,133 --> 00:01:48,090
 Now, what does Bob do?

35
00:01:48,090 --> 00:01:51,390
 Bob takes this as message Y and he

36
00:01:51,390 --> 00:01:54,975
 decrypts it by raising it to the power D. What do we get then?

37
00:01:54,975 --> 00:01:59,910
 We get M to the power E times D. What do we know about E times D?

38
00:01:59,910 --> 00:02:03,990
 That's equal to one plus some multiple of P minus one Q minus one.

39
00:02:03,990 --> 00:02:09,620
 We get M for this one and then we get this multiple of P minus one Q minus one.

40
00:02:09,620 --> 00:02:13,530
 What is M raised to the power P minus one Q minus one?

41
00:02:13,530 --> 00:02:16,600
 Well, when M is relatively prime to N,

42
00:02:16,600 --> 00:02:20,675
 then Euler's theorem tells us that this is one.

43
00:02:20,675 --> 00:02:23,135
 So, this whole term drops out and what are we left with?

44
00:02:23,135 --> 00:02:25,760
 We're left with M, the original message.

45
00:02:25,760 --> 00:02:29,775
 So, we take this message M raise it to power E and then raise it to the power D,

46
00:02:29,775 --> 00:02:31,050
 what do we end up with?

47
00:02:31,050 --> 00:02:32,650
 M the original message.

48
00:02:32,650 --> 00:02:37,580
 This is the case when M is relatively prime to N. And also it

49
00:02:37,580 --> 00:02:43,020
 holds when M and N have a common factor namely, P or Q.

50
00:02:43,020 --> 00:02:46,175
 In which case you can prove this statement still holds.

51
00:02:46,175 --> 00:02:47,480
 But it takes a little bit more work.

52
00:02:47,480 --> 00:02:49,270
 You got to use Chinese Remainder Theorem.

53
00:02:49,270 --> 00:02:50,885
 But that's the basic idea.

54
00:02:50,885 --> 00:02:52,430
 We use Euler's theorem.

55
00:02:52,430 --> 00:02:55,960
 So, that gives us this P minus one Q minus one term.

56
00:02:55,960 --> 00:02:58,940
 That's the whole RSA algorithm. It's fairly simple.

57
00:02:58,940 --> 00:03:01,145
 The only thing that's missing now for us,

58
00:03:01,145 --> 00:03:04,130
 is how do we generate a random prime number?

59
00:03:04,130 --> 00:03:06,185
 How do we get this P and this Q?

60
00:03:06,185 --> 00:03:10,100
 We said, generate a random number and then check whether it's prime.

61
00:03:10,100 --> 00:03:11,610
 So, we've got to look at how to check whether

62
00:03:11,610 --> 00:03:15,415
 a number P is prime or not. We'll do that next.

63
00:03:15,415 --> 00:03:17,870
 But let's first look at some simple issues that might

64
00:03:17,870 --> 00:03:21,080
 arise in the RSA algorithm that you have to be careful about.

65
00:03:21,080 --> 00:03:22,970
 One important note before we move on.

66
00:03:22,970 --> 00:03:26,250
 How do we compute this Y to the D mod N?

67
00:03:26,250 --> 00:03:29,455
 Notice we, typically tried to make E small.

68
00:03:29,455 --> 00:03:30,770
 Why did we make E small?

69
00:03:30,770 --> 00:03:32,060
 So, that it's easy,

70
00:03:32,060 --> 00:03:37,525
 it's fast to compute the message raised to the power E mod N. So,

71
00:03:37,525 --> 00:03:40,085
 it's easy and it is fast to encrypt the message.

72
00:03:40,085 --> 00:03:43,395
 So, we want to make it easy for somebody to send us an encrypted message.

73
00:03:43,395 --> 00:03:46,700
 But then we're going to put in extra work in order to decrypt it.

74
00:03:46,700 --> 00:03:51,360
 Why? Because this D, if E is smaller then D is probably going to be a huge number.

75
00:03:51,360 --> 00:03:56,580
 So, how do we take this mass encrypted message Y and raise it to the power D?

76
00:03:56,580 --> 00:04:00,795
 Here is where we really need to use our fast modular exponentiation algorithm.

77
00:04:00,795 --> 00:04:03,665
 This was the algorithm based on repeated squaring.

78
00:04:03,665 --> 00:04:07,600
 And then using this, we can compute Y to the D efficiently,

79
00:04:07,600 --> 00:04:11,225
 mod N. But if we don't use this fast algorithm,

80
00:04:11,225 --> 00:04:12,640
 we use a naive approach.

81
00:04:12,640 --> 00:04:14,815
 Then this is going to be exponential time

82
00:04:14,815 --> 00:04:14,815
 and there's no way we're going to be able compute it efficiently.

