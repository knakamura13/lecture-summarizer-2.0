1
00:00:00,000 --> 00:00:02,300
 Let's detail the RSA protocol.

2
00:00:02,300 --> 00:00:04,480
 Let's start with the receiver,

3
00:00:04,480 --> 00:00:06,270
 Bob. So what is Bob going to do?

4
00:00:06,270 --> 00:00:09,420
 Bob has to compute his public key and his private key and

5
00:00:09,420 --> 00:00:12,890
 he has to announce to the world his public key. How does he do it?

6
00:00:12,890 --> 00:00:15,135
 The first step that Bob is going to do,

7
00:00:15,135 --> 00:00:21,360
 is he's going to choose two N-bit numbers P and Q which are primes.

8
00:00:21,360 --> 00:00:23,190
 And he's going to do that at random.

9
00:00:23,190 --> 00:00:26,145
 So he's going to choose two random prime numbers P and Q.

10
00:00:26,145 --> 00:00:28,960
 How does he do that? We haven't discussed that at all.

11
00:00:28,960 --> 00:00:32,545
 And we're going to skip it until after we see the whole protocol.

12
00:00:32,545 --> 00:00:36,495
 The idea is that, first he's going to generate two random N-bit numbers P and Q.

13
00:00:36,495 --> 00:00:40,680
 And then he's going to check whether those random N-bit numbers are prime or not.

14
00:00:40,680 --> 00:00:43,035
 So we're gonna have a primarily testing algorithm,

15
00:00:43,035 --> 00:00:46,560
 so we can efficiently test whether a number is prime or not.

16
00:00:46,560 --> 00:00:48,330
 So he's going to generate random numbers,

17
00:00:48,330 --> 00:00:49,350
 test whether they are prime,

18
00:00:49,350 --> 00:00:52,560
 if the are prime, then they are random prime, if they're not prime,

19
00:00:52,560 --> 00:00:55,680
 he's going to repeat and generate a new random number and

20
00:00:55,680 --> 00:00:59,640
 check whether its prime again and keep going until he gets a prime number.

21
00:00:59,640 --> 00:01:01,265
 How do you generate a random number?

22
00:01:01,265 --> 00:01:04,500
 You just try and generate a random string of zeros and

23
00:01:04,500 --> 00:01:08,660
 ones of length and that gives you an N-bit random number.

24
00:01:08,660 --> 00:01:09,990
 How do you check whether it's prime or not?

25
00:01:09,990 --> 00:01:11,980
 Well, that's a little bit more complicated.

26
00:01:11,980 --> 00:01:16,485
 And it turns out that a random number has a reasonable chance of being prime.

27
00:01:16,485 --> 00:01:18,670
 Primes or dense in some sense.

28
00:01:18,670 --> 00:01:20,490
 We'll see details of all that next,

29
00:01:20,490 --> 00:01:23,205
 after we go through the whole RSA protocol in detail.

30
00:01:23,205 --> 00:01:29,250
 The second step, Bob chooses an E which is relatively prime to P minus 1 times Q minus 1.

31
00:01:29,250 --> 00:01:30,615
 How does he do that?

32
00:01:30,615 --> 00:01:32,550
 He's going to try E equals 3 and he's going to

33
00:01:32,550 --> 00:01:36,090
 check whether the GCD of three and P minus 1,

34
00:01:36,090 --> 00:01:37,665
 Q minus 1 is 1.

35
00:01:37,665 --> 00:01:39,990
 If it is, then they are relatively prime to each other.

36
00:01:39,990 --> 00:01:41,280
 How does he check it?

37
00:01:41,280 --> 00:01:43,485
 He runs Euclid's GCD algorithm.

38
00:01:43,485 --> 00:01:46,730
 And if three is not relatively prime, then what does he do?

39
00:01:46,730 --> 00:01:52,035
 He tries five and then seven and then 11 and so on.

40
00:01:52,035 --> 00:01:54,555
 You know, if you get up to 13 or 17 or

41
00:01:54,555 --> 00:01:57,990
 19 and none of those are relatively prime to P minus 1,

42
00:01:57,990 --> 00:01:59,760
 Q minus 1, what do you do?

43
00:01:59,760 --> 00:02:01,528
 Usually, you go back to the first step,

44
00:02:01,528 --> 00:02:04,555
 choose two new primes P and Q and try again.

45
00:02:04,555 --> 00:02:07,110
 It's nice to keep this encryption key small.

46
00:02:07,110 --> 00:02:11,400
 It makes it easy for somebody to encrypt their message, to send to you.

47
00:02:11,400 --> 00:02:15,470
 Now what do you do? Let's let N equal P times Q.

48
00:02:15,470 --> 00:02:17,835
 Now Bob can publish his public key,

49
00:02:17,835 --> 00:02:21,645
 N and E. N is the product of P times Q.

50
00:02:21,645 --> 00:02:23,535
 So he's publishing that product.

51
00:02:23,535 --> 00:02:25,050
 He's not publishing P or Q,

52
00:02:25,050 --> 00:02:29,500
 he's just telling what the product is and he's telling them what E is,

53
00:02:29,500 --> 00:02:32,390
 where E is relatively prime to P minus 1, Q minus 1.

54
00:02:32,390 --> 00:02:36,435
 So the whole world can know N and E. Meanwhile,

55
00:02:36,435 --> 00:02:38,260
 Bob computes his private key.

56
00:02:38,260 --> 00:02:39,660
 What's his private key?

57
00:02:39,660 --> 00:02:44,325
 It's the inverse of E relative to P minus 1, Q minus 1.

58
00:02:44,325 --> 00:02:47,220
 So D is the inverse of E mod P minus 1, Q minus 1.

59
00:02:47,220 --> 00:02:50,235
 How do we know that D exists?

60
00:02:50,235 --> 00:02:53,650
 Because E is relatively prime to P minus 1, Q minus 1.

61
00:02:53,650 --> 00:02:56,490
 We chose it so that it was relatively prime therefore it

62
00:02:56,490 --> 00:02:59,645
 has an inverse mod P minus 1, Q minus 1.

63
00:02:59,645 --> 00:03:01,755
 And we can find that inverse, how?

64
00:03:01,755 --> 00:03:03,990
 By using the extended Euclid algorithm,

65
00:03:03,990 --> 00:03:05,815
 we can find the inverse.

66
00:03:05,815 --> 00:03:08,190
 This is going to be Bob's decryption key.

67
00:03:08,190 --> 00:03:10,025
 He keeps it private, he doesn't tell anybody.

68
00:03:10,025 --> 00:03:11,920
 He tells the whole world N and E,

69
00:03:11,920 --> 00:03:11,920
 but he keeps private his decryption key, D.

