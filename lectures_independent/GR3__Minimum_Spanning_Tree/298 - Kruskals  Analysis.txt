Now let's take a look at the running time of Kruskal's algorithm and then we'll look at the proof correctness of Kruskal's algorithm. How long does it take to sort the edges by increasing weight? This takes o(m log n) time. M is the number of edges and N is number of vertices. Note of course (m log n) is the same as (m log m). Now how long does it take to do this step? How long does it take to check whether adding edge E into X creates a cycle or not? What exactly do we want to check to see whether it creates a cycle or not? Look at the sub graph on this set of edges X. Now in this sub graph, let C of V be the component containing V, and C of W is a component containing W. Now to see whether the edge E creates a cycle when we add it into this subgraph, we want to check whether there's already a path between V and W. If there already is a path between V and W, then the components containing V and W are the same, V and W are in the same component. So what this step does is, it checks whether the component containing V and the component containing W are different. So if V and W are in different components, then we add the edge E into X. Now how do we check the component containing V and the component containing W? Well, we use this data structure, the simple data structure known as union-find data structure, using this data structure it takes O(log N) time per operation. So it takes O(log N) time to check the component containing V and the component containing W and then we can see whether they're the same or different components. And then, once we add this edge E into X then we can update the component containing V and the component containing W. We can merge those two components in O(log N) time. So the union-find data structure takes O(log N) time for each check operation, in order to check whether the component containing V and the components C and W are the same or not. And it takes the O(log N) time to do a merge operation, where we merged the component contained V and the component containing W because we added edge E into X. Now I'm going to skip the details of the union-find data structure, since many of you may have seen in the data structures class before and if you want, if you haven't seen it before then you can review it in the textbook. But it's a very simple data structure using this notion of rooted directed trees, and once we have this data structure which has O(log N) per operation, then the key fact is that we're doing at most M operations and then since there are order M operations each one taking O(log N) time, then the total run time for the step three is o(m log n) again. So step 1 and step 3 both take o(m log n) time, so the total run time is o(m log n) for the whole algorithm. Now what I want to focus on in this lecture is not the data structure but the proof of correctness of this algorithm. Why does the greedy approach work for this problem?