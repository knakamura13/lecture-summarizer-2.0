Let's look at the following example with an array of n numbers and let's choose a specific pivot. Let's say the pivot is number 11. So we make these three buckets. Those less than p, those equal to p and those bigger than p. And we're going to take a scan through the array and we're going to put each of these elements in one of these three buckets. Five is smaller than the pivot, two is smaller than the pivot and so on. Eleven happens to appear twice, so it appears twice in this equal list. And these are the final buckets. Now, what is the K we're searching for? Depending on the K we're searching for, the Kth smallest will be in one of these three lists. And we can figure out where it resides based on how large these lists are in comparison to K. The smallest list is those of size four. So if K is, at most, four then we know the Kth smallest is in this list. So in this case, what we can do is we can recursively search for the Kth smallest in this list and we can discard these two other lists. Now if K is five or six, then what do we know? Then we know the Kth smallest is in this list and then, therefore, it's equal to 11. So we don't need to recurse at all, we can just output 11. Finally, if K is bigger than six, then what do we know? We know that the Kth smallest is in this list, so we don't search for the Kth smallest in this list because we discarded six elements from these lists. So we're going to search for the K minus six smallest in this list, A greater than p. Now the key is that we're always recursing on at most one list, either the small list or the big list. Or, in the middle case, we don't even have to recurse at all. Whereas QuickSort has to recursively sort these two lists, less than p and bigger than p. In this case, we only have to recursively search in one of the two lists. Now let's go ahead and detail this for the general case and let's write the pseudo code to make sure it's all clear.