1
00:00:00,000 --> 00:00:03,120
 So in the repeated squaring algorithm, we start off the same.

2
00:00:03,120 --> 00:00:07,650
 We compute X_mod_N and let's store the answer as a_one.

3
00:00:07,650 --> 00:00:09,210
 Then we compute X_squared_mod_N.

4
00:00:09,210 --> 00:00:11,755
 How do we get X_squared?

5
00:00:11,755 --> 00:00:13,670
 Well, a_one is X_mod_N,

6
00:00:13,670 --> 00:00:15,855
 so we take a_one_squared_mod_N.

7
00:00:15,855 --> 00:00:19,190
 So far it's the same as the other algorithm.

8
00:00:19,190 --> 00:00:22,740
 Now we're going to skip X_cubed and we're going to go to X_to_the_fourth.

9
00:00:22,740 --> 00:00:25,983
 How do we get X_to_the_fourth? We take the previous solution,

10
00:00:25,983 --> 00:00:28,320
 let's call it a_two and we square that.

11
00:00:28,320 --> 00:00:31,500
 A_two is congruent to X_squared_mod_N,

12
00:00:31,500 --> 00:00:35,970
 so if we take X_squared and we square that,

13
00:00:35,970 --> 00:00:37,715
 then we get X_to_the_fourth.

14
00:00:37,715 --> 00:00:40,830
 Then we take that solution and let's call it a_four.

15
00:00:40,830 --> 00:00:44,128
 Now to compute X_to_eighth_mod_N,

16
00:00:44,128 --> 00:00:46,680
 you take the previous solution and we square that.

17
00:00:46,680 --> 00:00:50,540
 That gives us X_to_the_fourth_squared which is X_to_the_eighth_mod_N.

18
00:00:50,540 --> 00:00:53,250
 And we repeat. What do we end up with?

19
00:00:53,250 --> 00:00:56,870
 We end up with X raised to the powers of two.

20
00:00:56,870 --> 00:01:01,320
 Then what do we do? We look at the binary representation of Y and

21
00:01:01,320 --> 00:01:06,075
 then we can use the appropriate powers of two and we can get X_to_the_Y_mod_N.

22
00:01:06,075 --> 00:01:06,075
 Let's look at a specific example so you illustrate the idea better.

