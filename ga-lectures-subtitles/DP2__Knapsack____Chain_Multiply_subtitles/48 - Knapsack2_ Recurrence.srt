1
00:00:00,000 --> 00:00:04,800
 Now, let's go ahead and see if we can write a recurrence for this subproblem definition.

2
00:00:04,800 --> 00:00:08,355
 So let's try to express K(i,b) in terms of smaller subproblems.

3
00:00:08,355 --> 00:00:12,280
 We're going to try to use the insight that we had from the previous version of knapsack.

4
00:00:12,280 --> 00:00:13,705
 So we're going to have two scenarios.

5
00:00:13,705 --> 00:00:16,670
 Either we include object i or we don't include object

6
00:00:16,670 --> 00:00:20,225
 i and we're going to take the best of those two so we're going to take the max.

7
00:00:20,225 --> 00:00:22,590
 Now, as in the other version of knapsack,

8
00:00:22,590 --> 00:00:24,865
 we're going to have two scenarios.

9
00:00:24,865 --> 00:00:26,040
 In the other version of knapsack,

10
00:00:26,040 --> 00:00:29,040
 we either included object i or we didn't include object i.

11
00:00:29,040 --> 00:00:30,970
 In this version of the problem,

12
00:00:30,970 --> 00:00:32,825
 we're going to have two scenarios.

13
00:00:32,825 --> 00:00:35,580
 Either we include no more copies of object

14
00:00:35,580 --> 00:00:39,670
 i or we're going to add in another copy of object i.

15
00:00:39,670 --> 00:00:42,270
 Now, in the first scenario where we have no more copies of object

16
00:00:42,270 --> 00:00:46,110
 i then the remainder of the set is going to be

17
00:00:46,110 --> 00:00:49,795
 a subset or a multiset actually of objects 1

18
00:00:49,795 --> 00:00:54,330
 through i minus 1 with the total capacity available staying the same.

19
00:00:54,330 --> 00:00:59,555
 Therefore the solution is k of i minus 1 B.

20
00:00:59,555 --> 00:01:03,650
 Now in the other scenario where we're adding in another copy of object.

21
00:01:03,650 --> 00:01:10,155
 And for that copy of object we get value v i.

22
00:01:10,155 --> 00:01:12,870
 And in addition we get the optimal solution to

23
00:01:12,870 --> 00:01:18,305
 this subproblem where the capacity went down by w i.

24
00:01:18,305 --> 00:01:20,620
 So that capacity went down by w i.

25
00:01:20,620 --> 00:01:23,140
 So the capacity available is now b minus w i.

26
00:01:23,140 --> 00:01:25,583
 But notice here the first index is i,

27
00:01:25,583 --> 00:01:30,900
 whereas in the other version of knapsack it was i minus 1 because in this version,

28
00:01:30,900 --> 00:01:36,465
 we're allowed to use object i again even another copy, additional copies,

29
00:01:36,465 --> 00:01:40,325
 whereas in the other version of knapsack once we use the object

30
00:01:40,325 --> 00:01:44,820
 i which is what's happening in this case then we could no longer use object i.

31
00:01:44,820 --> 00:01:48,300
 So this went down to i minus 1 to keep track that we didn't

32
00:01:48,300 --> 00:01:52,400
 allow ourselves to use it multiple times. Now let's take a look.

33
00:01:52,400 --> 00:01:55,620
 Is this recurrence in fact a valid recurrence?

34
00:01:55,620 --> 00:02:00,605
 Are we expressing this current subproblem in terms of smaller subproblems?

35
00:02:00,605 --> 00:02:04,740
 Previously, when we wrote recurrence for the current entry we always expressed it

36
00:02:04,740 --> 00:02:09,335
 in terms of entries in previous rows.

37
00:02:09,335 --> 00:02:15,755
 So this would be this one is in row i and the previous ones were in a row i minus 1.

38
00:02:15,755 --> 00:02:18,705
 But in this case, we're actually using the same row.

39
00:02:18,705 --> 00:02:20,280
 Let's look at the table.

40
00:02:20,280 --> 00:02:25,501
 We're going to fill this table row by row and when we get to this entry, k i b,

41
00:02:25,501 --> 00:02:27,658
 this current entry, okay,

42
00:02:27,658 --> 00:02:33,760
 we've filled up the previous rows and we filled up this current row up to that entry.

43
00:02:33,760 --> 00:02:38,285
 Now, what entries do does this recurrence require?

44
00:02:38,285 --> 00:02:42,665
 Well, it requires the entry which is one row above.

45
00:02:42,665 --> 00:02:45,080
 And in addition, it requires the entry

46
00:02:45,080 --> 00:02:48,545
 which is in the same row but it's earlier in that row.

47
00:02:48,545 --> 00:02:51,350
 So that will already be completed in the table.

48
00:02:51,350 --> 00:02:54,590
 So these two entries that are acquired by this recurrence are

49
00:02:54,590 --> 00:02:58,540
 already completed by the time we get to this current entry, k i b.

50
00:02:58,540 --> 00:03:01,610
 So it's a valid recurrence that expresses k i b

51
00:03:01,610 --> 00:03:05,090
 the current subproblem in terms of smaller subproblems.

52
00:03:05,090 --> 00:03:08,355
 So we can go ahead and actually use the same pseudocode

53
00:03:08,355 --> 00:03:11,765
 as before with the slightly different recurrence.

54
00:03:11,765 --> 00:03:15,865
 Of course, we also have to condition on we have to make sure that the i

55
00:03:15,865 --> 00:03:20,415
 object fits in the remainder remaining capacity.

56
00:03:20,415 --> 00:03:23,995
 So we can only do this case when this holds.

57
00:03:23,995 --> 00:03:25,605
 So if w i is the most b,

58
00:03:25,605 --> 00:03:27,885
 then we take the best of these two scenarios.

59
00:03:27,885 --> 00:03:31,970
 If w i is bigger than b then we can only use this case

60
00:03:31,970 --> 00:03:37,365
 just as before and the other um pseudocode for the other version of knapsack.

61
00:03:37,365 --> 00:03:39,395
 And what's our running time going to be?

62
00:03:39,395 --> 00:03:43,085
 Well, we got a table of size n times b.

63
00:03:43,085 --> 00:03:48,145
 That's the size of our table and to fill each entry it's going to take us order one time.

64
00:03:48,145 --> 00:03:52,055
 So a running time is going to be order and times capital B just as before.

65
00:03:52,055 --> 00:03:54,050
 So I won't go I won't detail it because it's

66
00:03:54,050 --> 00:03:54,050
 almost the same pseudo code is for the other version of knapsack.

