1
00:00:00,000 --> 00:00:03,750
 Let's go back and specify the remainder of the reduction in general.

2
00:00:03,750 --> 00:00:06,390
 For each clause, we encoded the literals which appear

3
00:00:06,390 --> 00:00:09,285
 in that clause using V_i and V_i prime.

4
00:00:09,285 --> 00:00:12,195
 To ensure that at least one of these literals is satisfied,

5
00:00:12,195 --> 00:00:15,750
 we put a three in digit n plus j of t. Then,

6
00:00:15,750 --> 00:00:18,315
 if all of the literals in this clause are satisfied,

7
00:00:18,315 --> 00:00:20,735
 we get the desired sum in this digit.

8
00:00:20,735 --> 00:00:23,958
 What if only one or two of the literals in this clause are satisfied,

9
00:00:23,958 --> 00:00:26,040
 how do we get the desired sum?

10
00:00:26,040 --> 00:00:29,965
 Well, that's where we use S_j and S_j prime to act as buffers.

11
00:00:29,965 --> 00:00:33,450
 We put a one in digit n plus j of both of these numbers,

12
00:00:33,450 --> 00:00:36,000
 and finally put a zero in digit n plus j

13
00:00:36,000 --> 00:00:38,935
 of all the other numbers which we haven't specified so far.

14
00:00:38,935 --> 00:00:39,990
 The main point is that,

15
00:00:39,990 --> 00:00:43,035
 if all three of the literals in this clause are satisfied,

16
00:00:43,035 --> 00:00:46,365
 then we get the desired sum of three in this digit.

17
00:00:46,365 --> 00:00:50,025
 If exactly one or two of these literals are satisfied,

18
00:00:50,025 --> 00:00:52,095
 then using these buffer numbers,

19
00:00:52,095 --> 00:00:54,795
 we get the desired sum of three in this digit.

20
00:00:54,795 --> 00:00:57,655
 But if none of the literals in this clause are satisfied,

21
00:00:57,655 --> 00:01:00,420
 then there's no way to achieve a sum of three in

22
00:01:00,420 --> 00:01:00,420
 this digit because the sum of these buffer numbers only adds up

