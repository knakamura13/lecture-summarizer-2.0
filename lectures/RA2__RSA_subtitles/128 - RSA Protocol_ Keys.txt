Let's detail the RSA protocol. Let's start with the receiver, Bob. So what is Bob going to do? Bob has to compute his public key and his private key and he has to announce to the world his public key. How does he do it? The first step that Bob is going to do, is he's going to choose two N-bit numbers P and Q which are primes. And he's going to do that at random. So he's going to choose two random prime numbers P and Q. How does he do that? We haven't discussed that at all. And we're going to skip it until after we see the whole protocol. The idea is that, first he's going to generate two random N-bit numbers P and Q. And then he's going to check whether those random N-bit numbers are prime or not. So we're gonna have a primarily testing algorithm, so we can efficiently test whether a number is prime or not. So he's going to generate random numbers, test whether they are prime, if the are prime, then they are random prime, if they're not prime, he's going to repeat and generate a new random number and check whether its prime again and keep going until he gets a prime number. How do you generate a random number? You just try and generate a random string of zeros and ones of length and that gives you an N-bit random number. How do you check whether it's prime or not? Well, that's a little bit more complicated. And it turns out that a random number has a reasonable chance of being prime. Primes or dense in some sense. We'll see details of all that next, after we go through the whole RSA protocol in detail. The second step, Bob chooses an E which is relatively prime to P minus 1 times Q minus 1. How does he do that? He's going to try E equals 3 and he's going to check whether the GCD of three and P minus 1, Q minus 1 is 1. If it is, then they are relatively prime to each other. How does he check it? He runs Euclid's GCD algorithm. And if three is not relatively prime, then what does he do? He tries five and then seven and then 11 and so on. You know, if you get up to 13 or 17 or 19 and none of those are relatively prime to P minus 1, Q minus 1, what do you do? Usually, you go back to the first step, choose two new primes P and Q and try again. It's nice to keep this encryption key small. It makes it easy for somebody to encrypt their message, to send to you. Now what do you do? Let's let N equal P times Q. Now Bob can publish his public key, N and E. N is the product of P times Q. So he's publishing that product. He's not publishing P or Q, he's just telling what the product is and he's telling them what E is, where E is relatively prime to P minus 1, Q minus 1. So the whole world can know N and E. Meanwhile, Bob computes his private key. What's his private key? It's the inverse of E relative to P minus 1, Q minus 1. So D is the inverse of E mod P minus 1, Q minus 1. How do we know that D exists? Because E is relatively prime to P minus 1, Q minus 1. We chose it so that it was relatively prime therefore it has an inverse mod P minus 1, Q minus 1. And we can find that inverse, how? By using the extended Euclid algorithm, we can find the inverse. This is going to be Bob's decryption key. He keeps it private, he doesn't tell anybody. He tells the whole world N and E, but he keeps private his decryption key, D.