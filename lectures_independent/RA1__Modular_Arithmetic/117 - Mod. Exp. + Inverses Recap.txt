Let's recap what we've seen so far. We've seen the Modular Arithmetic definition, X mod Y. The first non-trivial algorithm that we saw was computing modular exponentiation using the repeated squaring idea. This gave us an algorithm which was polynomial in the number of bits, little n. This modular exponentiation algorithm is gonna be a key component in the RSA algorithm. We're gonna have numbers X, Y and capital N and we're gonna have to compute X raised to the Y mod N. And these numbers X, Y and capital N are all gonna be huge number of bits. So we're gonna have to compute this modular exponentiation, in time polynomial, in the number of bits, not in the size of the numbers. So it will be key that we use this Fast algorithm that we devised. The other key concept that we looked at were multiplicative inverses. For example, X inverse mod N. What we saw is that this inverse exists, if and only if, these two numbers are relatively prime. In other words, that their GCD is one. How do we check that they're relatively prime? How do we check their GCD? Well, we can compute their GCD using Euclid's algorithm. Now if they are relatively prime, how do we compute their inverse? Well we saw how to compute their inverse using the extended Euclid algorithm. So those are the key algorithms that we're gonna use in our RSA cryptosystem. Euclid's algorithm, extended Euclid algorithm and this Fast modular exponentiation. Now, we can dive into their RSA cryptosystem.