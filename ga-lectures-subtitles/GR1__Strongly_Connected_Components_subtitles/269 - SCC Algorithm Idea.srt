1
00:00:00,000 --> 00:00:04,440
 Now, let's look at the main idea for our strongly connected component algorithm.

2
00:00:04,440 --> 00:00:07,955
 Now, we're going to find these strongly connected components in topological ordering.

3
00:00:07,955 --> 00:00:11,970
 So let's go back and look at our topological ordering algorithm for DAGs.

4
00:00:11,970 --> 00:00:14,700
 Now, let's look at the topological ordering of a DAG where

5
00:00:14,700 --> 00:00:18,600
 vertex V happens to be first and vertex W happens to be at the end.

6
00:00:18,600 --> 00:00:20,415
 Now, what do we know about vertex W?

7
00:00:20,415 --> 00:00:22,480
 We know it has to be a sink vertex.

8
00:00:22,480 --> 00:00:24,510
 It might have some edges in but it can't have

9
00:00:24,510 --> 00:00:27,750
 any edges out because those edges would go backwards in the ordering.

10
00:00:27,750 --> 00:00:30,620
 Similarly, vertex V must be a source vertex.

11
00:00:30,620 --> 00:00:33,353
 It can have edges out but it can't have any edges in.

12
00:00:33,353 --> 00:00:36,510
 We have this alternative approach for topologically sorting a DAG.

13
00:00:36,510 --> 00:00:38,210
 We could find a sink vertex,

14
00:00:38,210 --> 00:00:40,650
 output it, rip it out, and repeat.

15
00:00:40,650 --> 00:00:43,915
 Find a new sink in the resulting graph and repeat.

16
00:00:43,915 --> 00:00:45,640
 Or, we could find a source vertex,

17
00:00:45,640 --> 00:00:48,600
 put it at the beginning, rip it out of the graph, and repeat.

18
00:00:48,600 --> 00:00:51,980
 Find a new source vertex in the resulting graph and so on.

19
00:00:51,980 --> 00:00:54,505
 We can either work left to right, or right to left.

20
00:00:54,505 --> 00:00:56,940
 Finding sink vertices and moving on,

21
00:00:56,940 --> 00:00:59,040
 or finding source vertices and moving on.

22
00:00:59,040 --> 00:01:02,700
 We're going to do a similar idea here but instead of finding a single vertex,

23
00:01:02,700 --> 00:01:05,310
 we're going to find a sink strongly connected component.

24
00:01:05,310 --> 00:01:07,050
 This is a component which is

25
00:01:07,050 --> 00:01:10,945
 a sink vertex in a meta graph on strongly connected components.

26
00:01:10,945 --> 00:01:14,253
 We're going to find a sink strongly connected component then we're going to output it.

27
00:01:14,253 --> 00:01:16,235
 That's going to be at the end of our ordering.

28
00:01:16,235 --> 00:01:17,705
 We're going to remove it from the graph,

29
00:01:17,705 --> 00:01:19,830
 so we're going to remove all vertices from

30
00:01:19,830 --> 00:01:23,130
 this strongly connected component from the graph and then we're going to repeat.

31
00:01:23,130 --> 00:01:26,650
 We're going to find a sink component in this resulting graph,

32
00:01:26,650 --> 00:01:27,930
 output it, remove it,

33
00:01:27,930 --> 00:01:30,090
 and repeat until the graph is empty.

34
00:01:30,090 --> 00:01:32,425
 Now, why do we do sink strongly connected components?

35
00:01:32,425 --> 00:01:34,650
 Why not do source strongly connected components?

36
00:01:34,650 --> 00:01:36,975
 For the topological ordering of the DAG,

37
00:01:36,975 --> 00:01:40,655
 it didn't matter whether we started with sinks and worked that way backwards,

38
00:01:40,655 --> 00:01:43,295
 or if we started with source and work forward.

39
00:01:43,295 --> 00:01:45,510
 But for SCC it matters.

40
00:01:45,510 --> 00:01:47,845
 Sinks are easier to work with.

41
00:01:47,845 --> 00:01:49,895
 Why are sinks easier to deal with?

42
00:01:49,895 --> 00:01:54,150
 Well, take any vertex which lies in a sink SCC.

43
00:01:54,150 --> 00:01:57,075
 So S is a sink and strongly connected component,

44
00:01:57,075 --> 00:01:59,280
 V is the vertex lying in that component.

45
00:01:59,280 --> 00:02:03,960
 Now run Explorer from V. This is the basic procedure in the DFS algorithm.

46
00:02:03,960 --> 00:02:06,570
 Suppose this is the first vertex that you explore from,

47
00:02:06,570 --> 00:02:09,430
 which vertices do you visit when you explore from V?

48
00:02:09,430 --> 00:02:13,110
 Well, take our earlier example where we had this sink strongly connected component

49
00:02:13,110 --> 00:02:17,090
 which was H through L. Say we run explore from any of these vertices,

50
00:02:17,090 --> 00:02:19,165
 what's going to happen when we run Explorer?

51
00:02:19,165 --> 00:02:23,340
 We're going to visit all the vertices in this sink component but we're not going to visit

52
00:02:23,340 --> 00:02:26,100
 any other components because we can't reach any other components from

53
00:02:26,100 --> 00:02:28,960
 this component because it's a sink strongly connected component.

54
00:02:28,960 --> 00:02:32,220
 So we visit all of this component and we visit nothing else.

55
00:02:32,220 --> 00:02:33,660
 We don't see any other vertices,

56
00:02:33,660 --> 00:02:36,050
 we just see this component itself.

57
00:02:36,050 --> 00:02:37,950
 So if we can find a vertex which is

58
00:02:37,950 --> 00:02:40,810
 guaranteed to be in a sink strongly connected component,

59
00:02:40,810 --> 00:02:43,290
 then we can run Explorer from that vertex,

60
00:02:43,290 --> 00:02:47,250
 and we're going to visit and we're going to find exactly that sink component.

61
00:02:47,250 --> 00:02:49,620
 That's the key property about sink components.

62
00:02:49,620 --> 00:02:53,160
 We just need to find a vertex which lies in that component,

63
00:02:53,160 --> 00:02:54,810
 then when we explore from it,

64
00:02:54,810 --> 00:02:58,805
 we're going to find the component itself and we're going to see nothing else.

65
00:02:58,805 --> 00:03:01,530
 Therefore, we can mark all the vertices that we visited from

66
00:03:01,530 --> 00:03:04,330
 this Explorer as lying in this sink component,

67
00:03:04,330 --> 00:03:08,535
 then we can rip out those visited vertices and we can repeat the algorithm.

68
00:03:08,535 --> 00:03:11,665
 Find a vertex in a sink of the resulting graph,

69
00:03:11,665 --> 00:03:13,115
 run Explorer from it,

70
00:03:13,115 --> 00:03:16,950
 mark those vertices as being in that component, and repeat.

71
00:03:16,950 --> 00:03:20,580
 Now, what if we could find a vertex lying in the source component?

72
00:03:20,580 --> 00:03:23,120
 For example, what if we can find vertex A?

73
00:03:23,120 --> 00:03:25,899
 And we know that A is guaranteed to be in a source component,

74
00:03:25,899 --> 00:03:27,600
 while in our earlier example,

75
00:03:27,600 --> 00:03:30,840
 A happened to be a source component by itself.

76
00:03:30,840 --> 00:03:33,240
 But suppose there are other vertices in this component and we

77
00:03:33,240 --> 00:03:35,895
 want to figure out who are the other vertices in this component?

78
00:03:35,895 --> 00:03:39,401
 When we run Explorer from vertex A, what happens?

79
00:03:39,401 --> 00:03:43,485
 All we know is that from A we can reach many vertices. It's a source.

80
00:03:43,485 --> 00:03:46,690
 So in fact, we can reach the whole graph from A.

81
00:03:46,690 --> 00:03:48,515
 The whole graph is going to be visited.

82
00:03:48,515 --> 00:03:51,720
 So we have no way of marking which vertices happen to be in

83
00:03:51,720 --> 00:03:56,165
 this SCC and which vertices lie in other SCCs.

84
00:03:56,165 --> 00:04:00,350
 But if we run Explorer from a vertex which lies in a sink SCC,

85
00:04:00,350 --> 00:04:03,180
 we only visit that component and nothing else.

86
00:04:03,180 --> 00:04:06,320
 That's the key property about sink components.

87
00:04:06,320 --> 00:04:09,390
 Now, how can we find a vertex V which is guaranteed to

88
00:04:09,390 --> 00:04:12,765
 lie in a sink component? That's our key task.

89
00:04:12,765 --> 00:04:16,672
 Once we can find a vertex which is guaranteed to lie in a sink component,

90
00:04:16,672 --> 00:04:18,940
 then we can run Explorer from that vertex,

91
00:04:18,940 --> 00:04:20,590
 we'll find that sink component,

92
00:04:20,590 --> 00:04:22,785
 rip it out, and repeat the algorithm.

93
00:04:22,785 --> 00:04:25,680
 We'll find a sink component in the resulting graph,

94
00:04:25,680 --> 00:04:25,680
 rip it out, repeat and so on.

