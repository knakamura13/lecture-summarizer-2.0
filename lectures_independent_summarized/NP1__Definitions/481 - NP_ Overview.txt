To establish computational difficulty, we define a problem as NP-complete, indicating it lacks an efficient algorithm for all inputs. This involves demonstrating that a given problem is as hard as the hardest problems in NP, through reductions, a process we've encountered with the two-set and strongly connected components problems. We'll further clarify what reductions are and how they're used to prove NP-completeness. This discussion includes examples like 3SAT, graph problems such as independent sets, clique, and vertex cover, as well as the Knapsack problem. We'll also address Alan Turing's demonstration that the halting problem isn't just difficult, but undecidableâ€”it cannot be solved in general.