1
00:00:00,000 --> 00:00:01,740
 Now, let's date the pseudocode for

2
00:00:01,740 --> 00:00:05,130
 the dynamic programming algorithm for the longest increasing subsequence problem.

3
00:00:05,130 --> 00:00:08,580
 And I kept the recurrence from the previous slide about the L of i

4
00:00:08,580 --> 00:00:13,640
 in terms of smaller subproblems as a sort of crib notes for ourselves.

5
00:00:13,640 --> 00:00:19,030
 Here's a pseudocode for our dynamic programming algorithm for the LIS problem.

6
00:00:19,030 --> 00:00:21,165
 The input is a1 through an.

7
00:00:21,165 --> 00:00:23,923
 Our solutions are in one dimensional array L

8
00:00:23,923 --> 00:00:27,900
 and we're going to fill the table L from bottom up.

9
00:00:27,900 --> 00:00:31,030
 So we're going to start at index i equals 1 and go up to i equals n.

10
00:00:31,030 --> 00:00:34,950
 So we're going to have a single for loop for i going

11
00:00:34,950 --> 00:00:38,800
 from 1 to n. Now our subproblem formulation requires that ai

12
00:00:38,800 --> 00:00:43,795
 is included in the solution for L of i plus one term.

13
00:00:43,795 --> 00:00:47,070
 Therefore, we start by setting L of i equal to 1.

14
00:00:47,070 --> 00:00:49,230
 And then we're going to do the max over j.

15
00:00:49,230 --> 00:00:55,410
 So we're going to have another for loop which varies j from 1 to i minus 1.

16
00:00:55,410 --> 00:00:59,575
 Now we need to check that aj is strictly smaller than ai.

17
00:00:59,575 --> 00:01:02,160
 If aj is strictly smaller than ai,

18
00:01:02,160 --> 00:01:07,375
 then we need to check if the solution we can obtain by appending ai onto

19
00:01:07,375 --> 00:01:13,625
 the end of the solution ending at aj is longer than our current best solution.

20
00:01:13,625 --> 00:01:15,560
 So if aj is strictly smaller than ai,

21
00:01:15,560 --> 00:01:22,050
 and our current best solution L of i is strictly smaller than the new solution,

22
00:01:22,050 --> 00:01:26,910
 we can obtain by appending ai onto the end of L of j.

23
00:01:26,910 --> 00:01:30,255
 In this case we want to update our current best solution,

24
00:01:30,255 --> 00:01:33,905
 which is now the solution that we obtained by appending

25
00:01:33,905 --> 00:01:38,185
 ai onto the end of the solution that ends at aj.

26
00:01:38,185 --> 00:01:41,460
 Now we've given an algorithm which defines our table

27
00:01:41,460 --> 00:01:45,940
 L. But what is the solution that we're trying to output from this algorithm?

28
00:01:45,940 --> 00:01:47,670
 For the case of Fibonacci numbers,

29
00:01:47,670 --> 00:01:50,535
 it was the last entry in the table.

30
00:01:50,535 --> 00:01:53,450
 In this case, the last entry of the table is

31
00:01:53,450 --> 00:01:58,025
 the longest increasing subsequence ending at an.

32
00:01:58,025 --> 00:02:00,415
 That's not necessarily the solution that we're trying to obtain.

33
00:02:00,415 --> 00:02:05,170
 We're trying to find the longest increasing subsequence regardless of where it ends at.

34
00:02:05,170 --> 00:02:08,810
 So what we need to do is try to look through L and find

35
00:02:08,810 --> 00:02:13,020
 out maximum entry in the entire one dimensional array.

36
00:02:13,020 --> 00:02:14,635
 So let's go ahead and do that.

37
00:02:14,635 --> 00:02:16,020
 We'll make a variable max,

38
00:02:16,020 --> 00:02:19,350
 which will maintain the index with the largest entry of the table.

39
00:02:19,350 --> 00:02:22,650
 We'll start max at 1 and then we'll go through the entries at

40
00:02:22,650 --> 00:02:26,735
 the table to see if we find a larger entry than the current max.

41
00:02:26,735 --> 00:02:30,390
 This for loop simply finds the largest entry of the table and stores

42
00:02:30,390 --> 00:02:35,250
 the index for that entry in the variable max.

43
00:02:35,250 --> 00:02:36,960
 Finally, what do we return?

44
00:02:36,960 --> 00:02:41,170
 We return the entry at index max.

45
00:02:41,170 --> 00:02:44,790
 This completes the formulation of our dynamic programming algorithm.

46
00:02:44,790 --> 00:02:44,790
 Now let's take a look at the running time of our algorithm.

