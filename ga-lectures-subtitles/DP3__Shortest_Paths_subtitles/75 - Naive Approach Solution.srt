1
00:00:00,000 --> 00:00:01,830
 For Bellman-Ford, first off,

2
00:00:01,830 --> 00:00:06,210
 takes O(nm) time for each run.

3
00:00:06,210 --> 00:00:07,890
 Now, I'm terrible at memorizing these things,

4
00:00:07,890 --> 00:00:10,380
 so actually, the name itself,

5
00:00:10,380 --> 00:00:12,225
 Bellman-Ford, is not important.

6
00:00:12,225 --> 00:00:14,010
 What's important is we had the single source

7
00:00:14,010 --> 00:00:17,255
 shortest path algorithm using dynamic programming.

8
00:00:17,255 --> 00:00:19,740
 And if you want to reconstruct the running time in your head,

9
00:00:19,740 --> 00:00:24,335
 then what you can do is you can try to remember how it worked, the basic idea.

10
00:00:24,335 --> 00:00:28,620
 So the basic idea was we conditioned on the number of edges in the path.

11
00:00:28,620 --> 00:00:32,775
 So we went and we had this variable I which went from zero to n minus one.

12
00:00:32,775 --> 00:00:34,410
 So we had a for loop over I,

13
00:00:34,410 --> 00:00:36,143
 which had n choices.

14
00:00:36,143 --> 00:00:37,740
 Okay, that's the order_n.

15
00:00:37,740 --> 00:00:39,000
 And then in each step,

16
00:00:39,000 --> 00:00:42,780
 we conditioned on the last edge in the path.

17
00:00:42,780 --> 00:00:46,095
 So we had a for loop over the edges of the graph,

18
00:00:46,095 --> 00:00:49,340
 and that gave us the m factor.

19
00:00:49,340 --> 00:00:51,370
 So the total run time was O(nm).

20
00:00:51,370 --> 00:00:55,050
 And now, we're running this algorithm n times,

21
00:00:55,050 --> 00:00:58,580
 so the total run time is going to be order_n_squared_m.

22
00:00:58,580 --> 00:01:02,281
 What we're going to do now is that direct algorithm for this problem,

23
00:01:02,281 --> 00:01:05,520
 and this algorithm is called Floyd-Warshall algorithm,

24
00:01:05,520 --> 00:01:07,720
 and the running time is going to be order_n_cubed.

25
00:01:07,720 --> 00:01:10,110
 So it's better than this because in this case,

26
00:01:10,110 --> 00:01:13,920
 m the number of edges of the graph can be up to n_squared.

27
00:01:13,920 --> 00:01:15,150
 And if the graph is connected,

28
00:01:15,150 --> 00:01:17,765
 it's going to be at least n minus one.

29
00:01:17,765 --> 00:01:20,800
 So, this is possibly n to the fourth,

30
00:01:20,800 --> 00:01:22,870
 whereas this is n_cubed.

31
00:01:22,870 --> 00:01:28,080
 Now, just to clarify, I'm not expecting you to memorize the names of these algorithms.

32
00:01:28,080 --> 00:01:31,080
 What I want you to do is to understand the basic approach in

33
00:01:31,080 --> 00:01:36,420
 the two algorithms and then using that basic high level intuition,

34
00:01:36,420 --> 00:01:39,765
 you can reconstruct the running time for these algorithms,

35
00:01:39,765 --> 00:01:41,070
 and if you need be with

36
00:01:41,070 --> 00:01:45,155
 enough sufficient time you can reconstruct the actual algorithms, okay?

37
00:01:45,155 --> 00:01:47,460
 But I myself get confused all the time,

38
00:01:47,460 --> 00:01:49,690
 which one is Bellman-Ford, which one is Floyd-Warshall,

39
00:01:49,690 --> 00:01:51,845
 that's not the important aspect for here.

40
00:01:51,845 --> 00:01:54,008
 I want you to understand the high level idea,

41
00:01:54,008 --> 00:01:57,180
 and I'm illustrating these algorithms because they both have

42
00:01:57,180 --> 00:02:00,030
 some nice dynamic programming approaches which are

43
00:02:00,030 --> 00:02:03,635
 slightly different than the approaches that we've seen in the past.

44
00:02:03,635 --> 00:02:03,635
 So now let's dive into this Floyd-Warshall algorithm and see how we get this n_cubed.

