We've looked so far at the satisfiability problem, SAT, the colorings problem, and MST; minimum spanning tree problem. And we've seen why each of these are in the class NP. Now let's take a look at the knapsack problem which we studied in the dynamic programming section. Let me remind you the formulation of the knapsack problem. Now the input to the knapsack problem are n objects. For each object, were given an integer weigh, and we are given an integer value. The weights are denoted as W to the first and W to the nth, and the values are denoted by V to the first through V to the nth. And in addition, we're given a total capacity for the backpack or knapsack. Now the output for the knapsack problem is a subset of objects which fit in the backpack, so their total weight is at most capital B. And we want to subset which maximizes the total value. Let's make this a little bit more mathematically precise. By total weight and most capital B, we mean that if you sum over the objects in the subset S, their weights sum up at most capital B. Our objective is to maximize the total value. The total value for a subset S is the sum over the objects in the subset of their values. And we're trying to find the subset S which maximizes this sum of the total value, subject to the constraint that the sum of their weights is at most capital B. Now if you recall there were two variants of the knapsack problem that we studied in dynamic programming section. There was the version with repetition. So there was unlimited supply of each object or there was a version without repetition, so we had at most one copy of each object. Now which of these two variants that you consider, it doesn't matter. For the following discussion, it holds for both of these version.