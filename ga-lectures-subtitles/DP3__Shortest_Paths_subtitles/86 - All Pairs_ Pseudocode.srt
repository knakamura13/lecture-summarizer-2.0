1
00:00:00,000 --> 00:00:04,010
 So now we can write our pseudo code for the all pairs shortest path problem.

2
00:00:04,010 --> 00:00:06,900
 This algorithm is called the Floyd-Warshall algorithm.

3
00:00:06,900 --> 00:00:12,210
 The input to the problem is a directed graph G and a set of weights on the edges.

4
00:00:12,210 --> 00:00:15,180
 And these edge weights are allowed to be positive or negative.

5
00:00:15,180 --> 00:00:16,585
 Now we'll start with the base case.

6
00:00:16,585 --> 00:00:20,335
 What is the base case? The base case was the case D of zero S,

7
00:00:20,335 --> 00:00:25,970
 T. So we want to iterate through all S and all T and fill in the entries D of 0, S,

8
00:00:25,970 --> 00:00:29,385
 T. Recall our vertices are numbered one through N,

9
00:00:29,385 --> 00:00:32,690
 so to iterate through all possible choices of S,

10
00:00:32,690 --> 00:00:36,615
 we just have a for loop where S goes from one to N. Similarly,

11
00:00:36,615 --> 00:00:38,370
 to go through all possible choices for T,

12
00:00:38,370 --> 00:00:41,190
 we're going to have a for loop that varies T from one

13
00:00:41,190 --> 00:00:44,060
 to N. Now to fill in the entry D of zero S,

14
00:00:44,060 --> 00:00:48,345
 T, we got to check whether there is an edge from S to T. So if S,

15
00:00:48,345 --> 00:00:52,375
 T is an edge, then this entry D of zero S,

16
00:00:52,375 --> 00:00:54,890
 T is exactly the weight of this edge from S to

17
00:00:54,890 --> 00:00:58,819
 T. In the other case where S to T is not an edge,

18
00:00:58,819 --> 00:01:00,465
 then we're going to set D of zero S,

19
00:01:00,465 --> 00:01:02,550
 T to be infinite.

20
00:01:02,550 --> 00:01:04,710
 Now we go ahead and do the general case,

21
00:01:04,710 --> 00:01:07,035
 where I is at least one.

22
00:01:07,035 --> 00:01:12,285
 So we're going to vary from one to N. We're going to try to fill the entry D of I,

23
00:01:12,285 --> 00:01:14,175
 S, T. So once again,

24
00:01:14,175 --> 00:01:15,260
 we're going to go very overall,

25
00:01:15,260 --> 00:01:19,890
 choices for S and all choices for T. So we're going have for loop going over the choices

26
00:01:19,890 --> 00:01:22,070
 for S and a for loop going over the choices for

27
00:01:22,070 --> 00:01:24,840
 T. Finally we can fill in the entry D of I,

28
00:01:24,840 --> 00:01:28,414
 S, T. Now let's go ahead and write the recurrence for D of I, S,

29
00:01:28,414 --> 00:01:32,620
 T. This is the recurrence that we just defined on the previous line.

30
00:01:32,620 --> 00:01:36,975
 There are two cases and we're going to take the min or the best of the two cases.

31
00:01:36,975 --> 00:01:41,490
 The two cases depend on whether vertex I is on the path or is not on the path.

32
00:01:41,490 --> 00:01:43,987
 If it's not on the path then D of I, S,

33
00:01:43,987 --> 00:01:46,602
 T is exactly D of I minus one,

34
00:01:46,602 --> 00:01:47,725
 S, T. In the other case,

35
00:01:47,725 --> 00:01:49,435
 when vertex I is on the path,

36
00:01:49,435 --> 00:01:51,705
 we can break up that path into two parts.

37
00:01:51,705 --> 00:01:54,720
 The first part goes from S to I and the second part

38
00:01:54,720 --> 00:01:58,200
 goes from I to T and we take the sum of those two parts.

39
00:01:58,200 --> 00:01:59,730
 Finally, what do we return?

40
00:01:59,730 --> 00:02:05,172
 We return the case where I equals N. So we turn this matrix D of N,

41
00:02:05,172 --> 00:02:09,270
 for all possible choices S and all possible choices T. I put

42
00:02:09,270 --> 00:02:13,980
 these dots that signifies we're varying over all possible choices for that index.

43
00:02:13,980 --> 00:02:16,780
 So we want all possible choices for S and all possible choices for

44
00:02:16,780 --> 00:02:19,965
 T. If you think of this as a three dimensional array,

45
00:02:19,965 --> 00:02:23,400
 then we're returning the slice corresponding

46
00:02:23,400 --> 00:02:27,405
 to I equals N which isn't two dimensional array.

47
00:02:27,405 --> 00:02:29,125
 It has N squared entries.

48
00:02:29,125 --> 00:02:31,710
 This details the Floyd-Warshall algorithm.

49
00:02:31,710 --> 00:02:31,710
 Now let's go ahead and analyze the writing time of the algorithm.

