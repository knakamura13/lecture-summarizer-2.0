1
00:00:00,000 --> 00:00:02,850
 We've seen how to use the DFS algorithm to solve

2
00:00:02,850 --> 00:00:06,405
 connectivity problems in undirected and directed graphs.

3
00:00:06,405 --> 00:00:10,770
 Let's quickly remind you of some other common algorithms for exploring graphs.

4
00:00:10,770 --> 00:00:12,285
 As opposed to DFS,

5
00:00:12,285 --> 00:00:14,080
 which is depth first search,

6
00:00:14,080 --> 00:00:16,140
 BFS is breadth first search.

7
00:00:16,140 --> 00:00:19,435
 BFS explores the graph in layers.

8
00:00:19,435 --> 00:00:23,200
 The input to the BFS algorithm is similar to the DFS algorithm.

9
00:00:23,200 --> 00:00:28,210
 It's an undirected or directed graph G in adjacency list representation.

10
00:00:28,210 --> 00:00:31,020
 But BFS has an additional input parameter.

11
00:00:31,020 --> 00:00:36,045
 We specify a start vertex which we denote as little s. BFS returns

12
00:00:36,045 --> 00:00:42,078
 the distance for every vertex from the start vertex little s. The graph G is unweighted,

13
00:00:42,078 --> 00:00:45,690
 so the distance is defined as the minimum number edges to get from

14
00:00:45,690 --> 00:00:51,060
 vertex s to vertex v. Now if there is no path from s to v,

15
00:00:51,060 --> 00:00:54,120
 then this distance is defined as infinite.

16
00:00:54,120 --> 00:00:56,640
 Now how do we get such a path of minimum length?

17
00:00:56,640 --> 00:00:59,418
 Well, BFS also returns this previous array,

18
00:00:59,418 --> 00:01:03,085
 which one can use to construct a path of minimum length from

19
00:01:03,085 --> 00:01:07,465
 s to v. Now what's the running time of the BFS algorithm?

20
00:01:07,465 --> 00:01:10,510
 BFS, like DFS, is linear time,

21
00:01:10,510 --> 00:01:12,890
 so the running time is order n plus m,

22
00:01:12,890 --> 00:01:15,225
 where n is the number of vertices in the graph G,

23
00:01:15,225 --> 00:01:18,245
 and m is the number of edges in the graph G.

24
00:01:18,245 --> 00:01:22,575
 Dijkstra's algorithm is a sort of more sophisticated version of BFS.

25
00:01:22,575 --> 00:01:25,390
 It solves a similar problem as BFS, but instead,

26
00:01:25,390 --> 00:01:29,565
 it considers a weighted version of the graph G. As in the BFS algorithm,

27
00:01:29,565 --> 00:01:34,795
 the input to Dijkstra's algorithm is a graph G. It could be directed or undirected,

28
00:01:34,795 --> 00:01:37,171
 and we have a specified start vertex,

29
00:01:37,171 --> 00:01:41,680
 little s. But Dijkstra's algorithm has an additional input parameter.

30
00:01:41,680 --> 00:01:44,785
 We were given a weight, a length for every edge,

31
00:01:44,785 --> 00:01:47,880
 and this length has to be positive.

32
00:01:47,880 --> 00:01:50,495
 What is the output of Dijkstra's algorithm?

33
00:01:50,495 --> 00:01:53,230
 Well, it is the weighted analog of the BFS output,

34
00:01:53,230 --> 00:01:59,164
 so it outputs this array dist and dist(v) is the length of the shortest path from s

35
00:01:59,164 --> 00:02:01,660
 to v. Now one of the key requirements of

36
00:02:01,660 --> 00:02:05,335
 Dijkstra's algorithm is that these edge lengths are positive.

37
00:02:05,335 --> 00:02:08,410
 If you want to know how to deal with negative edge lengths,

38
00:02:08,410 --> 00:02:13,110
 then you should refer to our dynamic programming lecture, DP3.

39
00:02:13,110 --> 00:02:19,205
 Dijkstra's algorithm uses the BFS framework with the min-heap data structure.

40
00:02:19,205 --> 00:02:22,590
 The min-heap data structure is often called the priority queue.

41
00:02:22,590 --> 00:02:26,725
 Each operation in the min-heap data structure takes order log and time,

42
00:02:26,725 --> 00:02:31,465
 so we get an additional log and factor on the BFS running time,

43
00:02:31,465 --> 00:02:38,400
 and hence, the total runtime of Dijkstra's algorithm is order n plus m times logn.

44
00:02:38,400 --> 00:02:40,440
 Now there are other variants of Dijkstra's algorithm

45
00:02:40,440 --> 00:02:42,835
 with different data structures that they utilize.

46
00:02:42,835 --> 00:02:47,725
 We'll always refer to the following the min-heap data structure in this class.

47
00:02:47,725 --> 00:02:50,840
 And for concreteness, in this class we'll say the running time of

48
00:02:50,840 --> 00:02:55,320
 Dijkstra's algorithm is order n plus m times logn.

49
00:02:55,320 --> 00:02:59,955
 I assume that many of you have seen BFS and Dijkstra's many times in the past.

50
00:02:59,955 --> 00:03:01,330
 If you need a quick review,

51
00:03:01,330 --> 00:03:01,330
 I suggest you look at chapter four of the textbook.

