Let's take a look at the recursive nature of our algorithm. At the top level of the recursion, we're computing the nth Fibonacci number. Then we have recursive subclause computing the n minus first and n minus second. And we recursively compute the n minus first Fibonacci number, in which our algorithm is going to recursively compute the n minus second and n minus third Fibonacci number. And for the n minus second, it recursively computes the n minus third and n minus fourth Fibonacci numbers and so on. Notice that the n minus fourth Fibonacci numbers can be compute in many times. Similarly, when we get down to small Fibonacci numbers, we're gonna be recomputed them many times exponential number of times. That causes the inefficiency of our algorithm because we're recomputing the solution to the small sub-problems many times. To get around that, we're gonna flip the algorithm on its head. We're gonna compute the small sub-problems first, and then work our way to the larger sub-problems. In particular, we're gonna make an array F, we're gonna call it, to denote the Fibonacci numbers, and F of I is gonna be the I Fibonacci number. We're gonna start at index zero, and we're gonna record the first Fibonacci number, and the second Fibonacci number, and then we're gonna use a recursive formula to compute the third Fibonacci number and so on. We're gonna increase our index using the recursive formula. Finally, we'll get the n Fibonacci number. This is the idea of our algorithm. We start with the small indices, compute the small Fibonacci numbers, and then, we'll work our way up to compute the larger Fibonacci numbers using our recursive formula. This is our dynamic programming algorithm. So let's define it more precisely, so we are all clear.