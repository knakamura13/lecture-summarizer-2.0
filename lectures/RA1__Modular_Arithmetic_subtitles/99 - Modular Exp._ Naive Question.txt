We've seen the definition of the modulo operation, the basic modular arithmetic operation that we're going to do repeatedly is modular exponentiation. So, the setting is that we have n-bit numbers X, Y, and capital N, and our goal is to compute X raised to the power Y modular N. Now recall, little n, the number of bits, is going to be huge. For example, we might have little n, the number of bits, be about a thousand or 2000 in which case these numbers, X, Y, and capital N, are on the order of about two to the thousand or two to the 2000. S, o we want an efficient algorithm to compute X raised to the power Y mod N. By efficient we want polynomial in little n, because little n is the size of the input, to represent these numbers it takes little n bits. So, we want polynomial in the input size, which is polynomial in little n. We don't want polynomial in the numbers themselves because the magnitude of these numbers is exponential in little n. These are huge, if we had running time which was polynomial in two to the thousand that would be enormous. There was no way we could run such an algorithm. So, let's look at the time it takes to compute X raised of the power Y mod N. So, let's start off with a simple algorithm for computing X to the Y mod N. We start off by computing X mod N, let's call that a1. Then what do we do? We compute X squared mod N. Now x squared, that's going to be a1, which is x mod N, and then multiply that by x. So, we take the previous solution, a1, multiply it by x and then take that mod N. Then for x cubed mod N, we take the previous solution, let's call that a2, and we take the a2 and we multiply by x and we take it mod N. And we keep repeating finally for X to the Y in the last round we take the previous solution, which is aY minus 1, and we multiply by x and we take in mod N. Now, how long does this algorithm, this simple algorithm take? Let's look at one round. What are we doing? Let's look at x cubed here. So, we're taking this number a2, which is an n bit number because it's at most capital N minus one. Okay? So, this is n bit number, x is an n bit number. How long does it take to multiply two n bit numbers? That's just normal real arithmetic. That has nothing to do with modular arithmetic, okay? So, we're multiplying two n-bit numbers that takes order n squared time, and then we're taking it mod capital N. How do we do that? We take this order n-bit number and we divide it by this order n-bit number and we take the remainder. How long does it take to divide two n-bit numbers? That's order n squared time. So, this takes order n squared time for this one operation. How many rounds, how many operations do we have? How many ai's do we have? We got y ai's. How large is y? y is n-bits, little n-bits. So, y is at most two to the n. So then, the total runtime of our algorithm is order n squared time per round, and then the number of rounds is on the order of y, which is at most two to the n. So, that means the total runtime of our algorithm that we just described is n squared times 2 to the n. It's an exponential time algorithm, exponential in the input size, little n. So, this is a terrible algorithm. If we have little n even, let's say, about 30 there's no way we could run such an algorithm. And we're going to be looking at a little n which is on the order of about 1000 or 2000. So, this is enormous. So, what do we do better? We used the basic idea of repeated squaring, which you've probably seen many times. So, instead of taking the previous answer and then multiplying by X, we're going to take the previous answer squared and that's going to give us the powers of two. Let's go ahead and in detail