Now, let's look at things from Alice's perspective. Alice has a message M that she wants to send to Bob. What's the first step that Alice does? She looks up Bob's public key which is this pair N, E. Now, she needs to encrypt her message using Bob's public key. What does she do? She encrypts using their public key. She takes the message M raises its power E and takes that mod N. And that's her encrypted message, Y that she sends to the world. Now, one key thing is, E might be a little bit large. So, how does she raise M to the power E Mod N? She uses our fast modular exponentiation algorithm that we just saw earlier in this lecture. Finally, Alice can send the message Y. Now, let's look at the final step of the procedure. What happens for Bob? Bob receives this encrypted message Y that Alice sent. Now, Bob decrypts this message. How does he decrypt it? He computes Y, this encrypted message, raises it to the power D which is his private key and he takes that mod. N. What is that going to equal? That's going to give him back M. So, he's going to end up with the original message M. Let me recall why that's the case. Remember, how did we choose D? D is the inverse of e mod P minus one Q minus one. That means D times E is congruent to one mod P minus 1 Q minus one. That means D times Z is one plus some multiple of P minus one times Q minus one. Now, what are we doing? We're starting with the message M. Alice is encrypting it by taking that message M raising it to the power E then taking it mod N. Call N is P times Q where P and Q are prime numbers. This M to the E is Y. Now, what does Bob do? Bob takes this as message Y and he decrypts it by raising it to the power D. What do we get then? We get M to the power E times D. What do we know about E times D? That's equal to one plus some multiple of P minus one Q minus one. We get M for this one and then we get this multiple of P minus one Q minus one. What is M raised to the power P minus one Q minus one? Well, when M is relatively prime to N, then Euler's theorem tells us that this is one. So, this whole term drops out and what are we left with? We're left with M, the original message. So, we take this message M raise it to power E and then raise it to the power D, what do we end up with? M the original message. This is the case when M is relatively prime to N. And also it holds when M and N have a common factor namely, P or Q. In which case you can prove this statement still holds. But it takes a little bit more work. You got to use Chinese Remainder Theorem. But that's the basic idea. We use Euler's theorem. So, that gives us this P minus one Q minus one term. That's the whole RSA algorithm. It's fairly simple. The only thing that's missing now for us, is how do we generate a random prime number? How do we get this P and this Q? We said, generate a random number and then check whether it's prime. So, we've got to look at how to check whether a number P is prime or not. We'll do that next. But let's first look at some simple issues that might arise in the RSA algorithm that you have to be careful about. One important note before we move on. How do we compute this Y to the D mod N? Notice we, typically tried to make E small. Why did we make E small? So, that it's easy, it's fast to compute the message raised to the power E mod N. So, it's easy and it is fast to encrypt the message. So, we want to make it easy for somebody to send us an encrypted message. But then we're going to put in extra work in order to decrypt it. Why? Because this D, if E is smaller then D is probably going to be a huge number. So, how do we take this mass encrypted message Y and raise it to the power D? Here is where we really need to use our fast modular exponentiation algorithm. This was the algorithm based on repeated squaring. And then using this, we can compute Y to the D efficiently, mod N. But if we don't use this fast algorithm, we use a naive approach. Then this is going to be exponential time and there's no way we're going to be able compute it efficiently.