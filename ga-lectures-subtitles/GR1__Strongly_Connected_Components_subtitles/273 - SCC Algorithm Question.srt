1
00:00:00,000 --> 00:00:03,040
 Finally, let's detail our strongly connected component algorithm.

2
00:00:03,040 --> 00:00:08,805
 The input to our algorithm is a directed graph G in adjacency list representation.

3
00:00:08,805 --> 00:00:11,980
 The first step of our algorithm is to construct the reverse of the graph

4
00:00:11,980 --> 00:00:16,160
 G. Then we run DFS on the reverse graph. What do we know?

5
00:00:16,160 --> 00:00:18,760
 We know that the vertex with highest post order number from

6
00:00:18,760 --> 00:00:23,180
 this DFS run is guaranteed to lie in a source SCC of GR,

7
00:00:23,180 --> 00:00:26,350
 and therefore is in a sink SCC of G. So,

8
00:00:26,350 --> 00:00:29,350
 now what we want to do is we want to run explorer from this vertex

9
00:00:29,350 --> 00:00:32,500
 with highest post order number from this DFS run.

10
00:00:32,500 --> 00:00:35,170
 So now, what we're going to do is we're going to order the vertices.

11
00:00:35,170 --> 00:00:36,820
 These are the vertices of the original graph,

12
00:00:36,820 --> 00:00:40,535
 G. We're going to order these vertices by decreasing post order number.

13
00:00:40,535 --> 00:00:43,195
 This is like we're ordering them by topological ordering,

14
00:00:43,195 --> 00:00:44,785
 as for our DAG algorithm,

15
00:00:44,785 --> 00:00:47,900
 and these are the post order numbers from this DFS run.

16
00:00:47,900 --> 00:00:51,790
 So, we run DFS on the reverse graph and then we order the vertices in

17
00:00:51,790 --> 00:00:56,650
 the graph by decreasing post order number from this DFS run.

18
00:00:56,650 --> 00:00:59,695
 Now, finally, we run DFS on the original graph,

19
00:00:59,695 --> 00:01:05,375
 where the vertices are ordered by this decreasing post order number from this DFS run.

20
00:01:05,375 --> 00:01:08,115
 Now, what is the version of DFS we use for this last one?

21
00:01:08,115 --> 00:01:11,235
 We're actually going to use the undirected connected components algorithm.

22
00:01:11,235 --> 00:01:15,820
 If you recall, that runs DFS and it marks the components

23
00:01:15,820 --> 00:01:20,865
 that we see along the way with a connected component number CCnum.

24
00:01:20,865 --> 00:01:23,495
 We're going to run that identical pseudocode.

25
00:01:23,495 --> 00:01:27,245
 Even though this is a directed graph and that was designed for undirected graphs,

26
00:01:27,245 --> 00:01:29,990
 we run the identical pseudocode and the components,

27
00:01:29,990 --> 00:01:31,360
 the strongly connected components,

28
00:01:31,360 --> 00:01:33,450
 in this case, are going to be numbered

29
00:01:33,450 --> 00:01:35,985
 and they're going to be numbered in topological ordering.

30
00:01:35,985 --> 00:01:38,170
 So, the first component is going to be at the end of

31
00:01:38,170 --> 00:01:41,400
 our topological ordering and so on, and we're going to work over.

32
00:01:41,400 --> 00:01:44,020
 Now, just to remind you, this is our pseudocode

33
00:01:44,020 --> 00:01:46,840
 for our undirected connected component algorithm.

34
00:01:46,840 --> 00:01:50,710
 So, this was just DFS where we kept track of the connected component number and

35
00:01:50,710 --> 00:01:54,910
 we marked the vertices with their connected component number as we visited them.

36
00:01:54,910 --> 00:01:58,820
 So, for step four of this directed SCC algorithm,

37
00:01:58,820 --> 00:02:02,585
 we're going to run this identical pseudocode and this CCnum,

38
00:02:02,585 --> 00:02:04,060
 is going to give us the ordering,

39
00:02:04,060 --> 00:02:04,060
 the topological ordering on the strongly connected components.

