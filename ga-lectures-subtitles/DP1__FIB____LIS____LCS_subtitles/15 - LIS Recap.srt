1
00:00:00,000 --> 00:00:03,525
 This completes the formulation of our dynamic programming algorithm,

2
00:00:03,525 --> 00:00:05,505
 and the analysis of its running time.

3
00:00:05,505 --> 00:00:11,550
 But now, let's go back and take a look at some important aspects of our algorithm design.

4
00:00:11,550 --> 00:00:15,635
 What was the first step in our recipe for designing a dynamic programming algorithm?

5
00:00:15,635 --> 00:00:18,175
 It was to define the sub-problem in words.

6
00:00:18,175 --> 00:00:20,440
 In this case, define alibi in words.

7
00:00:20,440 --> 00:00:23,725
 Our initial attempt was to use a prefix of the input,

8
00:00:23,725 --> 00:00:25,170
 to find the length of

9
00:00:25,170 --> 00:00:29,480
 the longest increasing sub-sequence on the first I elements of the array.

10
00:00:29,480 --> 00:00:33,290
 Then, our second step in our recipe is to find

11
00:00:33,290 --> 00:00:37,960
 a recurrence relation that the solutions' sub-problems satisfy.

12
00:00:37,960 --> 00:00:39,960
 In that case, for that definition,

13
00:00:39,960 --> 00:00:42,250
 we were unable to do so. So what did we do?

14
00:00:42,250 --> 00:00:46,695
 We went back and we reformulated our sub-problem definition.

15
00:00:46,695 --> 00:00:48,540
 We added an extra condition into it,

16
00:00:48,540 --> 00:00:53,515
 and then we were able to write a recurrence for the sub-problems.

17
00:00:53,515 --> 00:00:58,920
 Now, the intuition for why we wanted to strengthen the sub-problem definition.

18
00:00:58,920 --> 00:01:04,200
 It goes back to, if you recall perhaps from a discrete math class way long ago,

19
00:01:04,200 --> 00:01:07,505
 when you were trying to prove some statement by induction,

20
00:01:07,505 --> 00:01:09,130
 how did you go about it?

21
00:01:09,130 --> 00:01:11,925
 Well, you would first state an inductive hypothesis.

22
00:01:11,925 --> 00:01:14,220
 Usually, the inductive hypothesis is of

23
00:01:14,220 --> 00:01:17,120
 the same form as the statement that you're trying to prove.

24
00:01:17,120 --> 00:01:20,835
 Then you try to prove that hypothesis using induction,

25
00:01:20,835 --> 00:01:22,860
 but sometimes you run into difficulties.

26
00:01:22,860 --> 00:01:27,480
 And what do you do? You go back and you alter your inductive hypothesis.

27
00:01:27,480 --> 00:01:30,090
 Typically, what you do is you try to strengthen

28
00:01:30,090 --> 00:01:33,090
 your inductive hypothesis by adding extra conditions in.

29
00:01:33,090 --> 00:01:34,645
 That's exactly what we did here,

30
00:01:34,645 --> 00:01:36,285
 we added the extra condition,

31
00:01:36,285 --> 00:01:40,435
 that the sub-problem has to include a i itself.

32
00:01:40,435 --> 00:01:42,600
 Okay? And then, you strengthen

33
00:01:42,600 --> 00:01:45,960
 the inductive hypothesis and you prove that stronger statement.

34
00:01:45,960 --> 00:01:47,100
 And that's what we're doing here.

35
00:01:47,100 --> 00:01:51,540
 We're giving you an algorithm for this stronger problem.

36
00:01:51,540 --> 00:01:54,120
 We're finding, in length, the longest increasing sub-sequence

37
00:01:54,120 --> 00:01:56,950
 with the specific character at the end.

38
00:01:56,950 --> 00:02:00,195
 Using that solution to that stronger problem,

39
00:02:00,195 --> 00:02:02,440
 we can then solve the weaker problem,

40
00:02:02,440 --> 00:02:05,370
 where we don't care, what is the ending character.

41
00:02:05,370 --> 00:02:08,190
 So, a lot of the intuition for what we're doing in dynamic programming,

42
00:02:08,190 --> 00:02:08,190
 comes from some ideas from induction proofs.

