Now, what happens in our algorithm if we have negative weight cycles in the graph? Well, the algorithm as written assumes there's no negative weight cycles. If there's no negative weight cycles in the graph, then this is correct. If there are negative weight cycles, then this is not necessarily correct, and we want to detect these negative weight cycles. If there is a negative weight cycle, how can we detect a negative weight cycle? How can we find out if the graph has a negative weight cycle and output, yes, there is a negative weight cycle? And if there is no negative weight cycles then we can run the algorithm as is. To get an idea for how to detect negative weight cycles, let's look at a simple example. So this is a cycle of length -1, 5 + -7 + 1, so it's -1 total length. And let's add in two more vertices to make it a non-trivial example. Let's add some connections from d to this cycle and from this cycle back to d. And also, from this cycle to e and from e to this cycle. And let's add in some weights to these edges. So, how can we find this negative weight cycle which goes from a b c a? Cycle of length three. What's going to happen in our algorithm? There's a more open-ended question. Once you think about how can we modify the algorithm in some simple way to detect a negative weight cycle? How can we find this cycle of length three in this graph? What is the final output of our algorithm? It's D of n, s, t for all pairs s, t. So let's look at this output on this example. Take somebody on this negative weight cycle, let's say vertex a. What is D of n, a, a for this example? What is the length of the shortest path from a to itself? It's allowed to use anybody as intermediate vertices. When this example is going to be of length -1. And notice also D of n, b, b is also going to be -1 and D of n, c, c is going to be -1. That is going to signify that there's a negative weight cycle. If we have any diagonal entries, so these are passed from vertex to itself. So any diagonal entries in the matrix which are negative then that means there's a path from a vertex to itself, which is shorter, which is negative. That means there's a negative weight cycle which includes that vertex. So to check for negative weight cycle we check if any diagonal entry, any entry D of n, y, y, for any y is less than zero. And that signifies that there is a negative weight cycle which includes this vertex y. So if we think of this three-dimensional table, and we look at this slice for i=n, then we have a two-dimensional table. We look at the diagonal entries and we check if there's any negative entries on that diagonal entry. Now notice we have two algorithms now for detecting negative weight cycles. We have the Floyd-Warshall algorithm which is all pair shortest path, and that's going to find any negative weight cycle in the graph by checking the diagonal entries. We also have the Bellman-Ford algorithm, which is the single source shortest path algorithm, and that also detects negative weight cycle. So there's some difference though, an important difference, that I want to distinguish between the two algorithms.