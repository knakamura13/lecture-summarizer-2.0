MF1 Ford Fulkerson Algorithm - 336 - Max-Flow
In this section, we'll look at the graph problem, known as the Max-flow problem. It's a quite useful problem. We'll first look at basic algorithm for the problem, known as a Ford Fulkerson Algorithm, and then we'll prove correctness of the Ford Fulkerson Algorithm. And along the way, we'll get the classic result known as the Max-flow- min-cut theorem. Next, we'll look at the nice application of the Max-flow problem to computer vision known as the Image Segmentation problem. We'll also look at a more general version of the problem, Max-flow with additional demand constraints, and we'll see how to reduce this more general problem to the original Max-flow problem. Finally, we'll see a faster Algorithm for the Max-flow problem, known as the Edmonds-Karp Algorithm.

MF1 Ford Fulkerson Algorithm - 337 - Lecture Outline
This lesson is about the max flow problem. First, we'll focus on algorithms for solving the max flow problem. We'll start with the Ford-Fulkerson algorithm and then we'll look at the Edmonds-Karp algorithm. Both of these algorithms are very simple, but the analysis of the running time of Edmonds-Karp algorithm is a bit more involved. After that, we're going to look at the very beautiful and very important theorem known as the max flow equals min-cut theorem. Now, this theorem will imply correctness of the Ford-Fulkerson and Edmonds-Karp algorithms. It will also be key for several of our applications. In particular, we'll look at solving the image segmentation problem using the max flow problem. Now, in the image segmentation problem, we're given an image and we want to separate it into the foreground and background components. We'll solve this using the max flow problem and utilizing the max flow equals min- cut theorem.

MF1 Ford Fulkerson Algorithm - 338 - Problem Setup
The general setting is that we're sending supply from vertex s to vertex t. Now, what does this supply? The supply might be things like Internet traffic, or it might be a product. Now, the network is specified by a directed graph, and we have a designated start vertex s, and we have a designated end vertex t. And our goal is to maximize the amount of supply sent from s to t along the edges of this network, but we don't want to exceed the capacities of the edges. So, for each edge we have a capacity of that edge. If you think of supply as an example such as Internet traffic then the capacity corresponds to the bandwidth of the link. If you think of a more physical example such as supply being oil, then we're maximizing the amount of oil sent from point s to point t in this network. And then the edges correspond to actual pipes, and then these numbers correspond to the capacity of these pipes.

MF1 Ford Fulkerson Algorithm - 339 - Problem Formulation
Now let's formally state the max flow problem. The input to the max flow problem is what is called a flow network. A flow network consists of a directed graph G. Here's an example of a directed graph again. Now in this directed graph we have two vertices labeled s and t, corresponding to the source and the sync for the flow in our problem. Finally for each edge, we're given a capacity which is a positive number. Here are the example capacities from before for this network. And our goal is to maximize the flow which is sent from s to t. So the flow originates at s and it ends at t. Now we use the variable f_sub_e to denote the flow along edge e. Now these are the variables which we're trying to determine. So our goal is to specify the flow along every edge so that we maximize the flow from s to t.

MF1 Ford Fulkerson Algorithm - 340 - Max-Flow Problem
Here's the general formulation of the max-flow problem. So the input is a flow network. Flow network, once again, consists of a directed graph with a specified start vertex and end vertex, and for each edge, we're given a capacity which is a positive number specified by c_sub_e. Our goal is to find the maximum amount of flow that can be sent from s to t. This flow is specified by these variables f_ sub_e for each edge in the directed graph. Now what are the constraints on these flows? The first constraint is the capacity constraint. For every edge, the flow along that edge cannot exceed the capacity of that edge, and the flow must be non-negative. The second constraint is conservation of flow. The flow originates at the source vertex s and ends at the sync vertex t. But for all other vertices, so for all v in the vertex set minus s and t, for all such vertices v, the flow must be conserved. So the flow into v must equal the flow out of v. Nothing can be lost or gained at vertex v. Formerly, the flow into v is the following. It's a sum over edges w to v of the flow along this edge which is specified by f_sub_wv, and the flow out of v is a sum over edges v to z of the flow along that edge, which is specified by f_sub_vz. A valid flow is one which satisfies the capacity constraints and conserves the flow at every vertex except for the source and the sync.

MF1 Ford Fulkerson Algorithm - 341 - Max-Flow Goal
Now our goal in the max flow problem is to find a valid flow. So one satisfying the capacity constraints and the conservation of flow constrains, and we want to find a valid flow of maximum size. What exactly do we mean by maximum size? What is the size of a flow? Well, the size of the flow is the total flow sent. This can be measured by the total flow out of s or the flow into t.

MF1 Ford Fulkerson Algorithm - 342 - Quiz Max-Flow Example Question
To make sure you understand the formulation of the max-flow problem, let's take a look back at our earlier example. So here's a flow network with a specified start and end vertex, and we specified the capacity for every edge. Now specify a flow. So for specify the flow along every edge where this flow is of maximum size and the flow needs to be valid, so it needs to satisfy the two constraints, which are the capacity constraints along every edge and the conservation of flow along every vertex except for S and T.

MF1 Ford Fulkerson Algorithm - 343 - Quiz Max-Flow Example Solution
Now, here's a flow of maximum size. The flow is specified by the green numbers along every edge and their capacities, once again, are specified by the red numbers along every edge. Now, notice for every vertex, the flow in equals the flow out. For instance, for vertex c, the flow in is seven and the flow out is seven. For vertex e, the flow in is one plus one which is two and the flow out is two. For vertex d, the flow in is seven and the flow out is seven. And all of the flows along the edges are upper bounded by the capacities along those edges. And finally, the total flow size is of size 12. This is 12 units of flow coming out of s and there's 12 units of flow coming into t. Now for this example, why do we know that this is the maximum flow? What the total capacity of edge is coming into t is 12, so the maximum amount of flow that can come into t is at most,12 and we've achieved that therefore, we've achieved the maximum flow.

MF1 Ford Fulkerson Algorithm - 344 - Cycles are OK
Now, one interesting feature of this example, is that there is a cycle in this graph. There's a cycle that goes from C to F, to E, to D and back to C. Now, this is a cycle in the original input graph in the flow network. Now, we've seen for some other examples such a shortest path problem that cycles in the input graph can cause some issues. In that formulation, it's negative weight cycles which cause problems. So a natural question is whether cycles are okay in a flow network for the max flow problem. Notice that a flow network has a cycle but our flow, our maximum flow is not utilizing this cycle. And why is it not utilizing this cycle? Well, suppose that I had one unit of flow coming into D and then I send one unit flow along this entire cycle back to T and then send that one unit out of D. Well, I could just send it right from this edge into D and then out of D directly without going around the cycle so I could have bypassed the cycle. So there's no reason to utilize a cycle in a flow network. Now I may want to utilize part of this cycle and I don't know a priority which part of the cycle I might want to utilize. So the main conclusion is that cycles are okay in a flow network. In fact they simplify the problem in some sense but the problem is well-defined regardless of whether there are cycles in the flow network or not.

MF1 Ford Fulkerson Algorithm - 345 - Anti-parallel Edges
Before we dive into algorithms for the max-flow problem, let's look at one slight simplification of the input. Here's an example flow network. Notice that there are edges from A to B, and also an edge from B to A. These are anti-parallel edges, we'll call them. Now, I'd like to remove these anti-parallel edges. Why we want to remove these anti-parallel edges will become clear later when we come up with our algorithms for the max-flow problem. But for now, let's just say, we want to simplify the input a little bit. So I wanted to find an equivalent flow network, and work with that equivalent flow network, and in that equivalent flow network, I don't have any anti-parallel edges. So let's put some capacities on these edges. So here are the edge capacities for this flow network. Now we wanted to find an equivalent flow network, and I wanted this flow network to not have any anti-parallel edges. I want to remove this anti-parallel edges here, and I want the max-flow, and that equivalent network to be the same as the max-flow here. This is the new network I want to consider. So I just split this edge from B to A, into a path of length two, and I added one auxiliary vertex, and the edge capacity stay the same. This single edge had a capacity of three. Now it gives both of these edges capacity three, and notice that these two flow networks are equivalent to each other? I can easily convert a solution to the max-flow problem on one network to the other network and vice versa.

MF1 Ford Fulkerson Algorithm - 346 - Toy Example
Now it'll be useful to have a small toy example to work with when we devise our algorithms. So let's look at this following example. It only has four vertices. It's quite easy to find a max flow in this network. Here's a max flow in this network. Notice this flow is of size 17. Therefore it's clearly maximum because it achieves the capacity into t and also the capacity out of s. Now we're going to use this toy example as a running example to try out our right.

MF1 Ford Fulkerson Algorithm - 347 - Simple Algorithm
Let's take a look at a simple algorithm approach, and let's use the toy example from before as our running example. Let's start off by initializing the flow to zero everywhere. So, we'll illustrate the current flow in this example. Then let's take a look at the available capacities along every edge. Since the flow is zero everywhere, the available capacities will be the same as the capacities in the input flow network. So we'll use this middle copy of the graph to illustrate the available capacities along the edges. Now in order to augment the flow in a valid manner, what we're going to do is we're going to try to find a path from s to t in this available capacity graph. So in this graph, we're going to find an s-t path. A path from s to t. Let's denote this path by P, cal P. How do we find such a path? Well, we can run BFS or DFS in this graph, it doesn't matter which one. We're not saying anything about which particular path we're looking for. We're just trying to finding find any path from s to t, where every edge has some available capacity. Let's consider this path from s to t in this graph. Now this path happens to be optimal in some sense. It has the one with the maximum available capacity, but that's not important for this example. We're going to look at all edges in this path and we're going to look at the available capacity of that edge. So we're going to look at the capacity along this edge, minus the current flow along this edge, it's the available capacity along this edge. We're going to minimize this. So this is going to be the maximum amount that we can send along this path. So finally we're going to augment this flow, the current flow, by sending c(P) units of flow along this path P. Hence, this flow changes so that and then we now have 10 units of flow along this path, s to a, a to b and b to t. So this is the new flow we're currently at and now we simply repeat. We redefine this graph of available capacities, we look for a path, s to t, we augment along that path, we update the flow, we re-update this graph, and repeat. And we keep going until there's no s-t path in this graph. So, let's update this graph for this current flow. Notice, that the available capacity for these three edges is now zero. So, in this graph there is no path from s to t anymore. So our algorithm is going to stop. There's no way to augment. So we're going to end with this flow, which is clearly sub-optimal. This is a flow of size 10, and we saw before there's a flow of size 17 in this graph.

MF1 Ford Fulkerson Algorithm - 348 - Backward Edges
Now what are we missing in this graph of available capacities? Well, if we reverse engineer a little bit and we look at the optimal solution, we see that we want to augment along this path. So we'd like to augment the current flow along this path from s to b, b to a and a to t. In this way, we want to increase the flow along this edge, s to b, in this edge, a to t, to seven. But what does it mean to augment along this edge from b to a? There's no such edge in this flow network. We'll think about this as a pipe. So when we send flow along this edge, a to b, we're opening up faucet. So we're sending more flow along this pipe. If we send flow from b to a, it's like we're closing the faucet, so we're sending less flow from a to b. The point is that this graph of available capacities is not properly representing everything that's possible to do from this current flow. In particular, we want to send an edge from b to a, and this edge should have available capacity 10. Why 10? Because the current flow from a to b is 10 units. So, if we send at most 10 units of flow from b to a, that corresponds to decreasing the flow from a to b. Now if we look at this graph, this is no longer the graph of available capacities. This graph is called the residual network. And in this graph, we can find a path from s to t. Namely, we can find this path that we're looking for, you go s to b, b to a and a to t. The capacity of this path is seven units. So we can augment the flow by seven units along this path. So the flow from s to b will change to seven units, we'll send seven units from b to a by decreasing the flow from a to b by seven units, so it will go down from 10 to three. And from a to t, the flow will increase by seven units. And then, we'll be at a Max-flow for this example. So the key idea is to look at the residual network instead of the network of available capacities.

MF1 Ford Fulkerson Algorithm - 349 - Residual Network
Let's formally define a residual network. First off, we have our input to the max-flow problem which is the flow network, the directed graph with capacities for each edge, and our residual network will be a function of the current flow. So fe is the current flow. So we'll denote the residual network as this graph G superscript f because it is a function of the current flow f. This will be a directed graph. The vertices will be the same as the flow network, but the edges will differ. So the edges will be a function of the current flow. And then these edges will also have weights. But even the actual edges that exist will be dependent on the current flow. And these might differ from the flow network or edges. For example, in the previous toy example, we saw that the flow network had an edge from a to b, but the residual network will have an edge from b to a. So how specifically do we define the edges of this residual network? Well, if there's an edge from v to w in the original flow network, and this edge has some available capacity. So, the flow along this edge is strictly smaller than its available capacity, then we add the same edge to the residual network where the capacity in this residual network is the available capacity. So it's the total capacity minus the current flow. These are, in some sense, the forward edges. These are the original type of edges we considered when we talked about available capacity network. Now, for this edge in the original flow network, if the flow is positive so there is some flow going along this edge, then we add the reverse of the edge to the residual network. Notice that this was the edge v to w and now we added the edge from w to v. This is the backward edge that we talked about earlier in the toy example. And the capacity of this backward edge is the current flow along the edge v to w so we can send most f or vw units of flow along this edge from w to v, and we send this flow from w to v by decreasing the flow along v to w. Now, since we sometimes have the forward edge and the backward edge, this is why, in our original flow network, we removed antiparallel edges. This way we're allowed to add the forward edge and the backward edge and we don't have to worry about any inequalities.

MF1 Ford Fulkerson Algorithm - 350 - Ford-Fulkerson Algorithm
Now we can state the Ford-Fulkerson algorithm. This is going to follow the same basic approach we did before, but instead of considering the graph of available capacities, we're instead going to consider the residual network. We're going to start by initializing the flow to zero everywhere, then we build the residual network for the current flow. Initially, the residual network will be the same as the input flow network. Now we look for a path from s to t in this residual network. How do we look for the path? Once again we use DFS or BFS. If there is no such path the, n we stop the algorithm and we output the current flow as our output as the max flow for this graph. If instead we found such a path, let's first denote this path by cal P, now given this path cal P, let's define the capacity of this path. This is the minimum capacity along this path in the residual network. So look at the edges in this path, look at the capacities of these edges in the residual network. Finally, we augment the current flow by c(P) units along this path. What exactly does it mean to augment the flow? Well, for every forward edge we increase the flow along that edge by this amount. For every backward edge, we decrease the flow in the other direction, in the reverse direction by this amount. Finally, we'll repeat from step 2, build the residual network and check for an st-path and we continue repeating until there is no such st-path. And then we output the current flow as our solution to the max flow problem.

MF1 Ford Fulkerson Algorithm - 351 - Running Time
Now the proof of correctness of this algorithm, the fact that it does output flow, which is equal to the Max-flow, this will follow from the Max-flow=min-cut theorem which we'll see later. So we're going to skip the proof of correctness for now. Let's instead focus on the running time with this algorithm. In order to analyze the running time, we need to make a huge assumption. We need to assume that all the capacities are integers. Only under this assumption can we make a claim about the running time with a Ford-Fulkerson algorithm. Later, we'll see more sophisticated algorithms namely, Edmonds-Karp algorithm, which eliminates this assumption. The main point of this assumption is that when we augment the flow, we're going to augment it by an integer amount. So therefore, the capacities in the residual network will maintain as integers, and then every round will continue to augment by an integer amount. Now, if all the capacities in the residual network are integers, therefore they are all at least one, since they're all positive. Then, the flow is going to augment by at least one unit, because the capacity of this path will be at least one unit. So the flow is going to increase by at least one unit for every round of the Ford-Fulkerson algorithm. Now how many rounds do we have? Let's let capital C denote the size of the Max-flow. This is what we're trying to find. Well then, we have at most capital C rounds of the algorithm, because in every round, the flow increases by at least one unit. The maximum flow that we're trying to find is of size capital C, so we're going to get at most capital C rounds.

MF1 Ford Fulkerson Algorithm - 352 - Time per Round
Now, here again is Ford-Fulkerson algorithm, and now the question is, what is the time needed for one round of the algorithm? Now, one round of the algorithm are steps two through five. In particular, we first build the residual network, then we check for a path, and then we augment along that path. Now, originally, the residual network is just the input network. Now, given the residual network from the previous round how long does it take us to update the residual network? Given this augmentation along this path P while the residual network is simply going to change along this one path P, it might change along the forward edges or the backward edges, or both. Now, this path is of length at most N and minus one edges, so it's going to take us order N time to update the residual network. How do we check for st-path in this residual network? Well, we run either DFS or BFS. The running time is linear, order N plus M. N is the number of vertices, M is the number of edges. Lets assume the number of edges is at least N minus one, then this is bounded by order M and also augmenting the flow along this path also takes order N time. So, one round of the algorithm is dominated by this checking for an st-path which takes order N time. Now, going back to our running time analysis what we concluded was that it takes order N time per round of the algorithm. As discussed before is most capital C rounds of the algorithm. Since in every round the flow increases by at least one unit, therefore, we can conclude that Ford Focus in algorithm requires time order N times capital C.

MF1 Ford Fulkerson Algorithm - 353 - Discussion
What we just saw is a Ford-Fulkerson algorithm, takes running time, order M times capital C, where capital C is a size of the max-flow. But this assume that the capacities were integer values. Now there are two problems or unpleasant aspects of this. The first is that, we're assuming that the capacities are integer values. The other is that, the running time depends on the output. It depends on the size of the max-flow, which depends on the size of the capacities in the input. Since the running time of this algorithm depends on the numbers, the capacities in the input, we say that this running time is pseudo-polynomial. This is much like the situation for Knapsack. And there we discussed that the running time should depend on the log of these numbers, and ideally, the running time should be independent of these numbers. What we're going to see next is the Edmonds-Karp algorithm. This is very similar to the Ford-Fulkerson algorithm. It's got the same paradigm, but in the Ford-Fulkerson algorithm, we just find any path from s to t in the residual network, and we can run DFS or BFS to find such a path. In the Edmonds-Karp algorithm, we take the shortest path from s to t. Shortest means minimum number of edges. We don't care about the weights on the edges. To find such a path, we just run BFS, and then, what can prove is that the number of rounds is going to be at most M times N, since each round, again, takes order M time, the total running time will be order M squared N. So the running time will be independent of the size of the max-flow, and we no longer need this assumption that the capacities are integer values. Finally, we'll point out that Orlin has a current past algorithm from 2013, in contrast, the Edmonds-Karp algorithm is from 1972. So roughly 40 years later. And he achieves a running time of order M times N. This is currently the best for general graphs for the exact solution of the max-flow problem.

MF2 Max Flow Min Cut - 354 - Lecture Outline
In this lecture, we're going to have two main tasks. The first task, is to prove the max-flow min-cut theorem. Later, we're going to use this theorem to solve the image segmentation problem. Our second main task, is to prove correctness of the Ford Fulkerson algorithm. And in fact we will prove correctness of the Edmonds-Karp algorithm at the same time. Now this is going to follow as a byproduct of the max-flow min-cut theorem. Let's start with a quick overview of what we've seen so far for the Ford Fulkerson algorithm.

MF2 Max Flow Min Cut - 355 - Recap Ford-Fulkerson
The input to the Ford–Fulkerson algorithm, or to the Max flow problem in general, is a flow network. This is a directed graph G with a specified star and N vertex S and T. And for each edge of the graph, where specified a positive capacity C_sub_e. Now, if you recall for the Ford–Fulkerson algorithm, to analyze the running time, we required that the capacities were integer value. Let's ignore that assumption for now and let's look at the more general Max flow problem. The output for the algorithm or for the Max flow problem is a flow of maximum size. And recall that the size of the flow is the flow out of the source vertex or the flow into the sync vertex T. Now recall, we analyzed the running time of the Ford–Fulkerson algorithm but we didn't prove that the flow that's outputted by the Ford–Fulkerson algorithm is of maximum size. So let's look at that now. What do we know about this flow that's outputted by the Ford–Fulkerson algorithm? In particular, when did the Ford–Fulkerson stop? What is the stopping condition for the algorithm? The algorithm stops when we look at the residual graph for the current flow. So this is G superscript f-star. Now in this residual graph, we look for a path from s to t. Such a path is called an augmenting path. If there's no augmenting path, there's no path from s to t in this residual graph, then the algorithm stops. We have no way to augment the flow to get a bigger flow. We're going to prove the following general lemma: for a flow f-star, If there's no augmenting path in the residual graph G superscript f-star, then its flow is a Max flow. So if in the residual graph there's no path from s to t, then this flow is a Max flow.

MF2 Max Flow Min Cut - 356 - Quiz Verifying Max-Flow Question
Let's look at an important consequence of dilemma we just stated on the previous slide. Given a flow network, so an input to the Max-flow problem, and given a particular flow F, what is the time required to check whether this particular flow F is a Max-flow or not? Specify your answer in big O notation, in terms of N, the number of vertices in the flow network, and M, the number of edges in the flow network.

MF2 Max Flow Min Cut - 357 - Quiz Verifying Max-Flow Solution
The solution is linear time. It takes O(n+m) time to check whether a particular flow f is maximum or not. This follows as a consequence of the lemma we stated on the previous slide. For a flow f*, if there's no augmenting path, no path from s to t in the residual graph for this particular flow, then this flow f* is a max-flow. So to check whether f is a max-flow, we build its residual graph which takes linear time, O(n+m) time, and then we check for a path from s to t in this residual graph. To do that, we simply run DFS from s to check whether t is reachable from s. What this lemma says is if there is no path from s to t in this residual graph, then this particular flow f is a max-flow. So we output yes. Now what if there is a path from s to t? Well, then we can augment a flow along this path. And then we get a flow of larger value. And therefore, this particular flow f is not a max-flow because we can build a flow of larger size. Now we'll get back to the proof of this lemma shortly. But let's go back first to the max-flow min-cut theorem, and let's see what min-cut actually means.

MF2 Max Flow Min Cut - 358 - Min-Cut Problem
Now a cut of the graph is a partition of the vertices and two sets. We will think of these two sets as the left side and the right side. So we denote it as L and R. Then we are going to be looking at st-cuts. These are a particular type of cuts. This is the cut which separates S from T. So S is on one side, let's say the left side, and T is in the right side. Now here's our example of a flow network that we looked at earlier. Let's mark an example of an st-cut in this graph. Here's an example of an st-cut. We put these four vertices S, A, B and F in the set L. Notice this set doesn't have to be a connected set. F is not connected to A and B in this subset. And the set R are the remaining four vertices, C, D, E and T. Now we're going to be interested in the capacity of this st-cut. What exactly is the capacity? Recall is a directed graph. We're going to look at these directed edges VW where V is in the left side and W was in the right side. So these are all edges which go from the set L to the set R and we're going to look at the capacity of these edges. So we're looking at the total capacity of edges from the set L to R. But we're not looking at edges from R to L. So we're looking at sum of the capacities of these six edges which exit L. Notice that these edges such as C to F which go into L do not count in this count.

MF2 Max Flow Min Cut - 359 - Problem Formulation
Let's formally state the min st-cut problem. The input is a flow network. So we have a directed graph with a specified start and end vertex. And for every edge, we have a positive capacity. Now the output for the min st-cut problem, it's an st-cut (L, R), so s has to be an L and t has to be an R. And we want to find that st-cut with minimum capacity. Recall the capacity of this cut is the sum of the capacities of the edges that go from L to R, and we ignore the edges that go from R to L. Now let's take a look at this cut that we looked at earlier. So the set L contains s, a, b and f. Now, the capacity of this cut is A plus two, plus two, plus five, plus seven, plus three. So the capacity is 27. We want to find the cut of minimum capacity. Here is an st-cut of minimum capacity. R simply contains T and L contains everybody else. The capacity of this cut is 12. We just have these two edges exiting L to R. How do we know this is min st-cut? Well, we're going to prove the Max-flow-min-cut theorem which says that the size of the Max flow equals the size of the min st-cut. We know there's a flow in this graph of size 12 and since there is an st-cut of capacity 12, therefore we know that this flow and this st-cut are both optimal.

MF2 Max Flow Min Cut - 360 - Max-Flow = Min st-Cut
The Max-flow-min-cut theorem states that for any flow network, the size of the max-flow equals the minimum capacity of an st-cut. Just a quick note about notation here. We keep calling this an st-cut to distinguish that s is on one side of the cut and t is on the other side of the cut. Notice s and t are also implicit in this max-flow formulation. We could have called it a max st flow because we're sending the flow from s to t. Now in the max-flow problem, it's clear there must be a start vertex s and an end vertex t. In a min-cut problem, there doesn't necessarily have to be an s and t that you're separating. We could instead look at the min-cut overall without looking at whether we separate s and t. So that's why we include the s and t in this formulation. So we called it the min st-cut problem to differentiate it from the min-cut problem. Now, let's dive into the proof of this min-cut max-flow theorem. First, we're going to prove that the size of the max-flow is the most the minimum capacity of an st-cut. And then, we'll prove the reverse inequality. So we'll prove that the max-flow is at least the minimum capacity of an st-cut. Once we prove both inequalities, then we've proved equality, and then we're done. To prove this inequality, what we'll show is that for any flow and any st-cut (L, R), the size of this flow is at most the capacity of this cut. Notice that this simpler result will imply this inequality. Why is that the case? Well, this is true for any flow f, so we might as well take a max-flow and it's still true. So if we maximize over f, the size of f is still at most the capacity of this cut. And since the right hand side holds for any st-cut, we might as well take the cut of smallest size. So for the right hand side we can choose any cut we want. So we'll choose the cut of minimum capacity, and then we have that the max-flow size is the most the min st-cut capacity. So that shows the max-flow is the most of min st-cut. So we proved this inequality. So we have a much simpler task now. We can forget about the max-flow and the min cut. We simply have to take any flow f, and any st-cut and show that the size of this flow is at most the capacity of this cut. And we don't have to worry anything about showing that this flow is optimal or this cut is optimal.

MF2 Max Flow Min Cut - 361 - Max-Flow Min st-Cut
Recall, we want to show that the size of the max-flow is the most to the capacity of the min st-cut. And to do that, we need to show that for any particular flow f and any particular st-cut L,R, the size of this flow is at most the capacity of this cut. Let's take a look again at our earlier example of a flow network. And here is our example of an st-cut. These four vertices are set L and the other four vertices are the set R. Now the capacity of this cut is 27. That's the total capacity of the edges going from L to R. Now the intuition for this claim is that this flow is going from s to t. At some point, it has to exit from L to R. These six edges which go from L to R are the only edges that the flow can escape L from. Now the total capacity of these edges is 27. So the total amount of flow that can go along these edges is at most 27. So the size of this flow has to be at most 27. That's the intuition. Let's formalize it. To formalize the intuition we just stated, we're going to prove the following claim. We're going to prove that the size of this flow equals the total flow out of the set L, minus the total flow into the set L. Now it will just be a few lines to prove this claim. It's quite easy. And then once we have this claim, the main statement that the size of f is at most of capacity of this cut will follow immediately. And this claim is going to be useful later. We're going to use it when we prove the reverse inequality, that the max flow is at least the min st- cut capacity.

MF2 Max Flow Min Cut - 362 - Proof of Claim
Let's prove this claim that for any flow f, and for any s-t cut L, R, the size of this flow equals the total flow out of the set L minus the total flow into the set L. Let's look at the right hand side, so we have the flow out of the set L, minus the flow into the set L. Now, the first term, the flow out of the set L, that's the sum of edges of the graph, where the head of the edge is in the set L, and the tail of the edge is outside of the set L. And we look at the flow along that edge, that's the flow out of the set L. Now for the flow into the set L, we're going to sum over edges W to V, where W is outside the set L, and V is inside the set L, and we look at the flow along that edge W, V. Now I've labeled these edges VW, and this one WV, so that V is always the vertex in the set L. Now, this captures the flow out of L, and the flow into L. Now, want to add an additional term, so we're going to add it and subtract it that at the same time, and therefore we still have equality. I'm going to look those edges VW, where V is in L, and W is in L and I'm going to add in the flow along those edges, and I'm going to subtract off the same term but I'm going to label the edge by WV instead of VW. But I'm going to be summing up over the same set of edges. Just labeled differently. Now,take the first and the third term, these are the positive terms. This considers the edges from V that go to R, and this considers the edges from V that go to L. So if I combine them together, I have all edges out of V. This first term, and this third term combined give us the sum of all vertices in the set L of the total flow out of this vertex L. Similarly, this term and this term give the flow into the vertex V because this term gives the flow of the edges from R to V, and this gives from L to V. So, combined they give the total flow into V. Now let's distinguish one particular vertex. The set L contains the source vertex, s. What do we know about the source vertex? Well, the flow in is zero. So we only have the flow out of it. So, let's take out s from this set L. So now we have a sum of vertices V in the set L minus s, and we have the flow out of this vertex V minus the flow into this vertex V. We dropped the term for s, so we have the flow out of s. We also dropped the term for the flow into s but we said that's zero, so we can drop it. Now what do you notice for all these vertices which are not s? The flow out has to equal the flow in. That's the definition of a valid flow, conservation of flow. So these two terms are equal, so this whole sum is zero, and all we're left with is the total flow out of s which is the size of f. The total size of this flow is equal to the flow out of s. Therefore, we've shown that the size of f equals the flow out of L minus a flow into L which is the claim that we wanted to prove.

MF2 Max Flow Min Cut - 363 - Finishing Off
So now we've proven this claim, the size of F equals the flow out of L minus the flow in it to L, and this is true for any flow F, and for any ST cut L, R. Now, recall we want to show, that the size of this flow F is at most the capacity of this ST cut L, R. And we saw before that this inequality implies that the max flow is at most the min ST cut capacity. So, let's see how this claim implies this desired result. Well, the size of F equals the flow out of L minus the flow into L, that's just the claim again. Where we can drop this second term, and it only gets bigger. So, this is at most the flow out of L. Now, along every edge that leaves the set L, the flow along that edge has to be at most the capacity of that edge. Therefore, the total flow out of this set L, has to be at most the capacity. Because the capacity is defined as the total capacity from the set L to R. We didn't count the edges from R to L. Looking back at our earlier example, for this ST cut L, R, the capacity of this cut is 27, and the total flow along these six edges, which leave this set L, clearly, must be at most the total capacity along these edges, which is 27. So, the flow out of this set L has to be at most the capacity of this cut. So, this proves that desired result. And therefore, we have that the max flow size is at most the min ST cut capacity. Now, to complete the proof of the theorem. We have to prove the reverse inequality. That the max flow size is at least the min ST cut capacity. Let's dive into that now.

MF2 Max Flow Min Cut - 364 - Reverse Inequality
Now, we'll show the following inequality. We'll show that max over the flows, F, the size of F. So the max flow size is at least, the capacity of the min ST-cut. We just proved that the max-flow size is at most, the min ST-cut capacity. Now if we prove this inequality, then we shown that it's the quality, that the left hand side equals the right hand side. To prove this inequality, what we're going to do, is we're going to take the flow F*, produced by the Ford-Fulkerson algorithm. What do we know about this flow? The Ford-Fulkerson algorithm stops, when there's no augmenting path in the residual network. So we know that this flow, F*, has no path from S to T in this residual network for this flow. What we're going to prove, is that for any flow, F*, which has no augmenting path in the residual network, we're going to construct an ST-cut, L, R which has the following property. The size of this flow, F*, equals the capacity of this cut that we construct. Now once we prove this, we claim that it's done. Why does this statement imply this inequality? Well this is one particular flow, F*. How does this compare to the max-flow size? Certainly, if we maximize over the flows F, the size of this flow, is at least the size F*. It maybe quality if F* is a max-flow, but certainly, the max flow is at least the size of F*. And how does the capacity of this particular cut L, R, compare to the capacity of the min ST-cut? Well certainly, the capacity of this particular cut, is at least the minimum capacity of any kind. So if we prove this middle equality, that the size of F* equals the capacity of this cut L, R that we construct, then that implies that the max flow size is at least, the min ST-cut capacity, which is what we want to prove. So it just remains to prove this equality

MF2 Max Flow Min Cut - 365 - Proof of Claim
So let's go ahead and prove the claim. So let's take a flow f* that has no augmenting path in this residual network and we wanted to find an s-t cut now. We want to use this property about this f*. We know there's no st-path in this residual network. So we know that t is not reachable from this vertex s in this graph. So that's a way to separate s from t. Therefore, we're going to let L be those vertices which are reachable from the vertex s in this residual network. Now we know this vertex t is not in this set L, why? Because we know there's no path from s to t in this residual network, that's our assumption about this flow f*. Therefore, we let R be the remaining vertices and we know that the vertex t is in this set R. So s is clearly reachable from itself. So s is in L and t is in R. So this set (L, R) is an s-t cut. So we've constructed our s-t cut, now we have to prove that this s-t cut has capacity which is equal to the size of this flow.

MF2 Max Flow Min Cut - 366 - Properties of Cut
Let's take a look now at the properties of this cut we just constructed and let's use as an illustration our earlier example of a flow network. Here's our example of a flow network G with the capacities marked in red. We're looking at a flow f star which has no ST path in the residual network G superscript f star. Here's an example of such a flow f star with the green numbers indicating the flow. Now let's look at this residual network for this flow f star. Recall some properties of this residual network. For example, this edge from E to D has positive flow so the reverse edge from D to E appears in this graph. Also the edge from E to D has some spare capacity available so the edge from E to D itself appears there. Similarly, this edge from D to C has some flow along it so the reverse edge from C to D appears. But the edge from D to C has no leftover capacity available so the forward edge does not appear in this residual network. Now the capacities on these edges in the residual network are not important. What's important are simply which edges are present or not. We define this set L, to be the set of vertices reachable from the source vertex in this residual network. Let's look at the set L in this example. So certainly s itself is reachable from S, also B is reachable and then we reach E and D and A. So these five vertices are the set L and the remaining three vertices are the set R and that defines our ST cut LR. By assumption, T is not reachable from S in this residual network therefore T is an R, so it's a valid ST cut. Let's look at some properties of this ST cut LR. For convenience let me draw this L on the original graph as well. Let's look at edges in the original graph which go from the set L outside to R, D to T is one such example, D to C is another example and S to C is another example. Now notice that none of these edges appear in the residual network. Why? Because L is the set of vertices reachable from S so this edge from D to T appeared in this residual network, then T would be added into the set L. It would be reachable from S and then we'd have a contradiction with the definition of L. So for any edge in the original graph, say from V to W, if this edge leaves the set L, so V is in L and W is in R, well we know that this edge does not appear in the residual network so what does that say about the flow along this edge? This edge must be fully capacitated and therefore the forward edge does not appear in the residual network so the flow along this edge equals its capacity. Now since every edge from L to R is fully capacitated, what does this say about the total flow out of L? Well it's equal to the capacity from L to R. The total flow out is equal to the total capacity from L to R. Recall that this capacity was defined as edges going from L to R. It doesn't count edges going from R to L. Well that's good we're close to what we want to prove. Now let's take a look at the edges that are going from R into L in the original graph. There is only one such edge in this example, the edge going from F into E. So consider an edge Z to Y in the original graph whereas Z is in R and Y is in this set L. What do we know about the flow along this edge from Z to Y, say from F to E? What's flow zero, why? Because this edge from E to F, the reverse edge does not appear in this residual network. If it did appear then F would be included in the set L which it's not so since the back edge does not appear in the residual network, then this forward edge has to have flow zero. Since this is true for all edges into the set L, we conclude that the total flow into L is zero in this flow f star. Now we proved earlier for any flow f star and any ST cut, LR, that the size of this flow f star equals the flow out of L minus the flow into L. What we've seen so far for this ST cut LR, the flow out of this set L is equal to the capacity and the flow in equal zero. So that means the size of this flow equals the capacity of this cut LR. This statement is exactly what we need to prove in order to finish the proof of the max flow main cut theorem. So that completes the proof of the theorem.

MF2 Max Flow Min Cut - 367 - Completing the Proof
Now let's go back to our earlier slide. We're trying to prove this inequality. We're trying to prove that the size of the max flow is at least the minimum capacity of an s-t cut. To do that, we took any flow which has no augmenting path in the residual network, and we constructed a s-t cut. How do we construct the s-t cut? We set L to be the set of vertices reachable from s, in this residual network. Since, there is no augmenting path, there is no s-t path in this residual network. So, t is not reachable from s. So, t is in the set R and s is in the set L. So, this is a valid s-t cut. And then, what we just proved is that the size of this flow, f*, is equal to the capacity of this cut. Therefore, the max flow is at least this size, and the min s-t cut capacity is at most this. So the max flow is at least the min s-t cut capacity. So we proved this inequality, and earlier we proved the other inequality, and therefore, that completes the proof of the max flow min cut theorem. We've proved that the max flow size equals the capacity of the min s-t cut. Notice, we've also proven the earlier, lemma that we claimed. We've shown, that for any flow that has no augmenting path in the residual network, we can construct an s-t cut, where the size of this flow equals the capacity of the s-t cut. Now the only way we can have equality here is if both of these are optimal. So this must be a max flow and this must be a min s-t cut. So, first off, this proves that Ford-Fulkerson algorithm, or any algorithm, which stops when there is no augmenting path in the residual network is correct. It outputs a max flow, but secondly, it shows us a way of constructing a min s-t cut. If we take a max flow f*, and we set L to be those vertices reachable from s in the residual network, then that s-t cut, that we just defined, has capacity equal to the size of this flow. So the capacity here must be optimal, this must be a min s-t cut. So we have a way of verifying that we have a max flow, and we have a way, given a max flow of constructing an s-t cut of minimum capacity, and were going to use that in our image segmentation application, and were going to use this lemma about a flow being optimal if there is no augmenting path in the residual network, for proof of correctness not only a Ford-Fulkerson algorithm, but also of Edmonds-Karp algorithm.

MF3 Image Segmentation - 368 - Image Segmentation
In this lecture, we'll look at an application of max flow to a problem from computer vision, known as Image Segmentation. We're given an image, such as this one, and our goal is to separate the image into objects. The easier tests that we're going to look at is to simply separate the image into foreground and background. For example, in this image we want to discern the triangle from the rest of the image.

MF3 Image Segmentation - 369 - Formulation
We are going to view the images lying on a graph with the vertices of a graph correspond to the pixels of the image. So let us look at an example of a pixelated image. Here is an example of a small pixelated image magnified. The input is going to be specified by an undirected graph G. The vertices of the graph once again correspond to the pixels of the image. So there are nine vertices in this example and the edges will go between neighboring pixels.

MF3 Image Segmentation - 370 - Parameters
The input once again is specified by an undirected graph G where the vertices correspond to the pixels. And in addition, we have the following parameters; for each pixel, we have two parameters, fi and bi. Fi is the likelihood or weight that vertex i, pixel i is in the foreground. And bi is the weight or likelihood that pixel i is in the background. Now, we'll assume that both of these parameters are non-negative. In addition, we're given a parameter for each pair of neighboring pixels. Pij is a separation penalty for this edge. It's the cost of separating i and j into different objects. And once again, we'll assume that pij is not negative.

MF3 Image Segmentation - 371 - Example
This is our example of an image from before. Let's look at an example setting of the parameters in this case. Here are example settings for the foreground and background likelihood for this image. So we're saying that the white pixels are more likely to be in the foreground and the black pixels are more likely to be in the background. For this image, we could have just as well reversed what we called foreground and background since we've defined the matrix to be symmetric. And here are sample separation penalties. And when the pixels are different, we don't pay any penalty for separating the pixels into different objects. Now keep in mind, this is very much a toy example. All the pixels are monochromatic. So we've chosen very simple weights in this example.

MF3 Image Segmentation - 372 - Partition
Our goal is to partition the vertices of pixels into two sets F and B. F will correspond to the foreground pixels and capital B will be the pixels that we assign to the background. Now, for a particular partition B, we need some score or weight to measure the likelihood of this partition. Thus, we defined the weight of this partition as the following for each pixel assigned to the foreground we get FB for each pixel assigned to the background we get BJ have used different indices for these two sets to avoid some confusion. Finally, we pay a separation penalty for separated edges. This is a penalty so we're going to subtract it. And, we're going to look at all edges where the first endpoint is an F and the other end point is in B or vice versa. And, the penalty is of course CIJ. This defines the weight for a particular partition FB. So, for a particular assignment of the pixels to foreground and background we have a weight associated with it. Our goal is to find the partition or assignment of pixels to foreground and background with maximum weight.

MF3 Image Segmentation - 373 - Min-Cut
Now our goal is to reduce this problem, this maximisation problem, to the min st-cut problem. So we have to somehow change this maximisation problem into a minimization problem. So we are going to have to modify these weights. And the other issue is that we are summing some terms and we are subtracting other terms. Now all of these parameters are non-negative. In our min st-cut problem, all the capacities in the input flow network are all positive. So we somehow need to change this minus of the separation penalty into an addition, so that all the terms are positive or non-negative.

MF3 Image Segmentation - 374 - Reformulation
Look at the sum of all the foreground and background likelihoods. So, let capital L denote the sum over all pixels of their foreground likelihood plus their background likelihood. We color our weight for a particular partition FB at weight fi for each pixel assigned to the foreground, and bj for each pixel assigned to the background. Notice, that this quantity is equal to capital L minus the sum of the pixels assigned to the foreground of their background, minus the sum of all the pixels assigned to the background of their foreground. Because, if we take the sum over the pixels assigned to the foreground of their foreground likelihood, plus sum of the pixels assigned to the background of their foreground likelihood, we get the total likelihood of all pixels for the foreground. This is the first term in this sum. Simply by summing this term with this term, we get this total likelihood of all pixels for the background. Now, if we subtract a separation penalty for separated edges, now think of this ij as an un-ordered pair. So, I don't have to write both cases, i and F, or j and B, this un-ordered pair that covers the other case, where i is in B, and j is an F. Now, to maintain equality, I want to subtract this term also from the other side. Now, what do you notice about this left hand side? Well, this is exactly our definition of the weight, W of FB. Now, we're going to define a new weight W-prime of FB, which is the sum of these three terms, and then the right hand side will be equal to L, capital L minus W-prime of FB.

MF3 Image Segmentation - 375 - New Weights
Now just to summarize we let capital L be the sum of the foreground and background likelihoods for all pixels. Now for a partition F, B we define its weight to be the following quantity: it's a sum over the vertices assigned to the foreground of their foreground likelihood plus the pixels assigned to the background of their background likelihood minus the separation penalty for separated edges. Now let's define a new weight W prime. This is the sum over vertices assigned to the foreground of their background likelihood plus the sum over vertices assigned to the background of their foreground likelihood. And now we'll add instead of subtract the separation penalty and the key point is that these two quantities are related in the following manner, W_F,B equals L minus W'_F, B. The separation penalty's cancel from both sides and then when you add up these remaining terms you get L. Now the point is if we find the partition F, B which maximizes the weight W of F, B this is equivalent to finding the partition F, B which minimizes W'. Since we're subtracting off W' minimizing this term is the same as maximizing the whole quantity. So we've changed our maximization problem into a minimization problem and all the terms and W prime are positive. So now this is in potential form that we can convert it to a mean SD cut problem. And how do we solve the mean SD card problem? We solve it by doing the max flow problem. So we're going to find a flow networks, solve the max flow on that flow network and then that will give us the mean SD cut solution.

MF3 Image Segmentation - 376 - New Problem
Here is our new problem formulation. The input is an undirected graph corresponding to the image, once again, and we're given the following weights. For each pixel, for each vertex I, we're given fi and bi and these are non-negative weights. And, for each edge, we are given the weight Pij, which is also non-negative. And, our goal is to find the partition of the vertices or pixels into two sets, F and B, and we want the partition which minimizes the weight, w prime of FB. Recall the partition, FB, which minimizes w prime of FB, is the same partition which maximizes w of FB and therefore it solves the original image segmentation problem. Now, let's see how to reduce this to the max flow problem.

MF3 Image Segmentation - 377 - Flow Network
To convert this new image segmentation problem into a max-flow problem, we define the flow network which is the input to our max-flow problem. Now, the input to the image segmentation problem is undirected graph. Now flow network is a directed graph. So we have to take this undirected graph and define a directed graph G-prime. Now, here's our example input to the image segmentation problem. This corresponds to a natural undirected graph which is the corresponding directed graph. Well, here are the vertices of this graph. And instead of putting undirected edges between neighboring pixels, we'll put bi-directional edges. So these bi-directional arrows denote edges going from this pixel to this pixel and vice versa. This pixel back to this pixel. So this is the directed graph corresponding to our undirected image. So for each edge in our undirected graph, we add an edge from i to j and j to i. Now, what are the capacities on these edges? Well, we want to keep track of the separation penalties, so it's natural to put capacities which are the separation penalties. So both of these edges will get capacity Pij. Now, that encodes the separation penalties. What do we do with the foreground and background likelihoods? Well, we're going to add additional vertex corresponding to the foreground and an additional vertex corresponding to the background.

MF3 Image Segmentation - 378 - Foreground
So, we're going to add a vertex S, a source vertex, corresponding to the foreground pixels. Now, here's the same directed graph, once again, with the vertices shrunk a little bit, just for illustrative purposes. Now, we're going to add two additional vertices, S and t. S will correspond to the foreground, t will correspond to the background, and this will be our source and our sync for our max-flow problem. We're going to add an edge from S to every pixel, every vertex. So, for every pixel in the original undirected graph, we add an edge from S to i. Now, S is supposed to correspond to the foreground. So, the capacity of this edge will be fi. So, we encode the foreground likelihoods.

MF3 Image Segmentation - 379 - Background
Now for the background, we do similar, using this vertex t. So, we have an edge from every vertex of the original undirected graph to t. So these edges are going to T, whereas edges came out of S. So S was a source and T is a sync, and the capacity of these edges two t will be the background likelihood. So now we've got the foreground likelihood and the background likelihood encoded, and we have the separation penalties encoded. So here's our final graph, and we've specified the capacities along every edge. Therefore, we've defined a flow network, and we can use this as our input to the max-flow problem.

MF3 Image Segmentation - 380 - Cuts
Now we're going to take this flow network, and we're going to run the max-flow on it. We're going to get a flow of maximum size, and we know that the size of the maximum flow equals the capacity the minimum S, T cut. Now let's try to understand S, T cuts. For a particular partition F, B, what is the capacity of that cut? Recall the capacity of this cut, and the capacity of the edges that go from F to B. So which S go from F to B? Recall we only get these edges that go from F to B. We don't get the edges that go from B to F. So let's define a partition or cut in this graph. Let's suppose that these four pixels get assigned to the foreground. So this is our set F, and the remaining five, six vertices are in the background B. Now which edge is cross from F to B? Now consider one of these four pixels in the foreground. Notice its edge to T, crosses this cut. So we get this edge from I to T, and what's the capacity of this edge? It's B, I. That was our definition of this flow network. Similarly, look at these pixels assigned to the background. For each of these five pixels, we get the edge from S to that pixel, and that edge from S originates in F, and ends in B. So it crosses this cut from F to B. And what's the capacity of this edge from S to this pixel? And that was defined to be F, J. Finally, for each of these separated edges, we get the edge in one direction, but not the other direction. We get this edge, this edge, this edge, and this edge. But notice we don't get the other direction edge. So for each edge in the original undirected graph, if I is assigned to the foreground, and J is assigned to the background, then we get the edge from I to J, and the capacity is P, I, J. Now if you sum up these terms, what do you get? That's the capacity of this cut, F, B. And that's exactly equal to W prime of F, B. That was our definition of W prime. We summed over pixels in the foreground of B, I. Pixels in the background of F, J, and the separation penalty. That's great. Our capacity is exactly equal to the quantity W prime, and our goal was to minimize W prime. If we run max-flow, we find a mins S, T cut. That's a cut with minimum capacity. So, we found the cut, the partition which minimizes W prime.

MF3 Image Segmentation - 381 - Solution
So, we can summarize our solution to the image segmentation problem. Given our original input to the image segmentation problem, this consists of an undirected graph corresponding to the image, the foreground likelihoods, background likelihoods, and the separation penalties. Then we define a flow network. This consists of a directed graph. We take this undirected graph, make each edge bi-directional, and then we add s, which directs to every vertex in the original undirected graph. And, we add vertex t, which has an edge from every pixel in the original undirected graph, to t that defines the directed graph, and then we define our capacities. Then we run max flow on this flow network, and we get a flow, f* of maximum size. Now, the size of this max flow, equals the capacity of the min st-cut, this is the max flow min-cut theorem. And in fact, we can take this max flow and construct a cut of minimum capacity. And, we just saw that the capacity of a particular st-cut equals the weight, w prime of FB. Therefore, by finding the cut of minimum capacity, it's equivalent to finding the partition of minimum weight w prime. Now, our original problem was to find the partition of maximum weight, w. Well, this is the same as capital L, this normalizing factor, minus the min over partitions of w prime. So, if we find the partition which minimizes w prime, that's the same partition which maximizes w. And therefore, we've shown how to solve the original image segmentation problem using the max flow problem.

MF4 Edmonds Karp Algorithm - 382 - Max-Flow Min-Cut Algorithms
Now we've seen the Ford-Fulkerson algorithm for solving the max-flow problem. And in this lecture, we'll look at the Edmonds-Karp algorithm for solving the max-flow problem. Before we dive into the Edmonds-Karp algorithm, let's do a quick contrast of the two algorithms. Now in the Ford-Fulkerson algorithm, the main step is to find augmenting paths which are paths from S to T in the residual graph and to do that, we either use DFS or BFS. Now the running time of Ford-Fulkerson algorithm is order M*C, and recall capital C, is the size of the max-flow. And recall that this running time analysis assume that the capacities are integer value. Now in contrast, Edmonds-Karp finds augmenting paths using BFS. So Edmonds-Karp algorithm is an example of a Ford-Fulkerson algorithm. Does the running time analysis for Ford-Fulkerson algorithms still applies to Edmonds-Karp algorithm when we assume integer capacities? But in fact, we can often make a stronger guarantee on the running time. We'll prove that the running time is order m-squared n, and this doesn't require that the capacities are integer values. We have no assumptions on the capacities other than, of course, that they're positive valued. Now the algorithms are quite similar, so we'll give a quick recap with a Ford-Fulkerson algorithm and then we'll point out the differences in the Edmonds-Karp algorithm. And then afterwards, we'll dive into the running time analysis for the Edmonds-Karp algorithm.

MF4 Edmonds Karp Algorithm - 383 - Ford Fulkerson Algorithm
Let's start with the Ford-Fulkerson algorithm. Recall the input to the Ford-Fulkerson algorithm is a flow network which is a directed graph with capacities along the edges specified by C_sub_e. And for the Ford-Fulkerson algorithm, we assume that these capacities are integer values. Now we start off by setting the flow to zero along every edge of the graph. Next, we build the residual network for the current flow f. We denote this residual network by G_superscript_f. Now we look for an augmenting path in the residual network. More precisely, we check for a path from s to t in the residual network. And we do this using either BFS or DFS. If such a path exists, that's denoted by cal P. Now if no such path from s to t in the residual network exists, then we return the current flow. We'll prove later that if there is no augmenting path, no path from s to t in the residual network, then the current flow is guaranteed to be a maximum size flow. Now if there is such a path, then we want to augment along this path as much as possible. Therefore, we let c(P) be the capacity of this path. More specifically, it's the minimum over the edges of this path, of the capacity of these edges in the residual network. This is the maximum amount that we can augment this path. Finally, we augment the current flow by c(P) units along this path, and then we repeat the algorithm. We use the current flow and we build a new residual network, and we check for a path and continue. And we stop when there's no st-path in the residual network. This completes the description of the Ford-Fulkerson algorithm. Let's look now at the Edmonds-Karp algorithm.

MF4 Edmonds Karp Algorithm - 384 - Edmonds-Karp Algorithm
In the Edmonds-Karp algorithm there's only one distinction. When we check for an st-path in the residual network, we have to use BFS. We cannot use DFS. The running time analysis assumes that we're using BFS to find this path. That's the only difference between Edmonds-Karp and Ford-Fulkerson algorithm. Now, a running time analysis will not assume that the capacities are integer values, so we can remove this assumption. All that's required is that the capacities are positive. Before we dive into the running time analysis, let's look at one basic property of the Edmonds-Karp algorithm and also the Ford-Fulkerson algorithm. Notice that the residual network has to change by at least one edge in every round. In particular, at least one edge reaches full capacity. We augment along P until we reach the full capacity of at least one edge on that path. Now, that edge, which reaches its full capacity in the residual graph, will be removed from the residual graph in the next stage. Now, that edge might be a forward edge or a backward edge, but regardless it will be removed from the residual graph in the next stage. Now, there may be additional edges which are removed and there might be other edges which are added back into the residual network, and we're going to need some understanding of which edges are added in or removed from the residual network. But one key property is that at least one edge is removed in every stage.

MF4 Edmonds Karp Algorithm - 385 - Proof Outline
Now we're going to prove that the running time of Edmonds-Karp algorithm is order m squared n. Now to prove that, we're going to prove that the number of rounds of the algorithm, the number of times we augment the path, is at most m times n. Now in each round, we run BFS. BFS takes linear time. So assuming the number of edges is at least the number of vertices, that's order m time, therefore, it's order m time per round and order mn rounds. So the total run time will be order m squared n. So our main task is to prove that the number of rounds is at most mn. As we just discussed, in every round, the residual graph changes from the previous round. In particular, at least one edge is deleted from the residual graph in every round. This edge corresponds to the one with minimum capacity along the augmenting path. Now, edges make it add it back in in the residual graph. And in particular, this edge might be deleted in this round and in later rounds might be added back in. Now what we're going to prove is that for every edge of the graph, we can bound the number of times that the edge is deleted in the residual graph and then reinsert it back later. In particular, we're going to show that the number of times this edge e is deleted from the residual graph, and then later reinserted into the residual graph, is at most n over two times. Now since there are m edges in the graph, and this holds for every edge of the graph, so we know that every edge is deleted at most n over two times, at least one edge is deleted in every round. Therefore, there is at most n over two times m total rounds. This gives our desired bound on the number of rounds of the algorithm which proves the desired running time. So let's dive into the proof of this key lemma.

MF4 Edmonds Karp Algorithm - 386 - BFS Properties
Now we want to prove the key lemma from the previous slide which states that for every edge of the graph in the residual graph, this edge is deleted and then reinserted later at most n_over_two times. So this deletion, insertion process can occur at most n ove_ two_times. Now of course to prove this lemma, we're going to have to use properties of the BFS. Let's recall the setting for BFS, breadth-first search. The input is a directed or undirected graph G. We're going to be working with directed graphs. Our directed graph, the residual network, we'll have edge weights. But in fact, BFS doesn't pay attention to edge weights. Now BFS also specifies as a start vertex s. Now what is the output of the breadth-first search algorithm? Well, for every vertex of the graph, so it outputs an array of size n, and dist(v) is defined as the minimum number of edges to go from s to v. Notice, this just counts the number of edges, it pays no attention to the edge weights. If we want to pay attention to the edge weights then we have to use an algorithm such as Dijkstra's algorithm. Now in addition to computing this distance for every vertex, it also finds such a path from s to v which uses the minimum number of edges.

MF4 Edmonds Karp Algorithm - 387 - BFS Example
Let's take a look at BFS on one of our earlier examples. Here's one of our examples of a flow network. Let's assume that we're at the initial flow. So the flow is zero along every edge of the graph. Therefore, the capacities along these edges don't really matter. Now, since the flow is zero along every edge, there's no back edges, and the residual network at this stage will be exactly the same flow network. Now, let's run BFS on this residual network. Now, we start off from vertex s, and we explore the edges out of s, and we see a, b and c. Next, we explore the edges out of a, b and c. From vertex a, we see d and e. From vertex b, we see e, which is already explored. So this is an unexplored edge. Then from vertex c, we see vertex f. So the solid red edges are the tree edges, the BFS tree edges, and the dash gray edges are the non-explored edges. Now we explore the edges out of d, e and f. From vertex d we see vertex t, our end vertex, and then we have a bunch of unexplored edges. Now at this stage, BFS is done. Now, let's look at some properties of BFS. Notice this is exploring the graph in layers. Now, in the first layer or level is only vertex s itself. So this is at level 0. Now then, the neighbors of s are at level 1. So a, b and c are level 1. Then we have that d, e, f are at level 2. And finally, vertex t is at level 3. Now the level of vertex is the same as the minimum number of edges to go from s to that vertex. So formerly, the level of vertex is the same as the distance. Now, what is the path cal-P that BFS finds from s to t? Well, it's this path, s to a to d to t. Notice on this path from s to t, look at the levels. S is at level zero, a is at level 1, d is at level 2, and t is at level 3. So the level goes up by plus 1 at every edge. Now, notice that the level cannot go up by more than one in one edge, because of the definition of the level. It's the minimum number of edges from s to that vertex. Similarly, the level cannot stay the same or go down along an edge. Otherwise, there's a shorter path to the vertex. So the path that BFS finds from s to t, is going to be a path where the level goes up by plus one at every edge. That's the key property that we need from BFS, that the path obtained from s to t, the levels of the vertices go up by plus 1 along every edge of their path.

MF4 Edmonds Karp Algorithm - 388 - BFS Properties - Part 2
Now, to approve our main demo about the number of rounds of the Edmonds-Karp algorithm, we're going to analyze the level of a vertex during the course of the Edmonds-Karp algorithm. Now, in particular we want to look at the vertex Z, and we want to look at how it's level changes as the residual network changes. Now, what can happen in the residual network? Well, edges can get deleted. For instance, suppose we delete this edge from A to D, then what happens to the level of D? Well, now the minimum number of edges to get from S to D is one, two, three. So, D will be at level three. So, the level of D will increase when we delete this edge from A to D. Now, we're also going to add edges into the residual network. For instance, what if we add an edge from B to D? Or maybe we'll even add this edge back from A to D, then will the level of D decrease back to level two. Well, we're going to prove that that does not occur. Even though we're adding edges into the residual network sometimes, the level of vertex is never going to decrease. We're going to prove, that for every vertex Z, it's level over the course of the algorithm does not decrease. It can stay the same or can increase in some levels. But if for instance, this vertex D, it's level increases to three, then it can never go back down to two. It can only stay the same or increase further. Now, to prove this claim, we have to understand which edges are added into the residual network, and which edges are removed from the residual network. So, let's look at that in more detail.

MF4 Edmonds Karp Algorithm - 389 - AddDelete Edges
Let's take a look in detail how the residual graph changes potentially in a round. Now, consider an edge of the original flow network. Now, this edge itself might be in the residual network or its back edge from w to v might be in the residual network. Let's look at when the forward or backward edge might be added or removed from the residual network. When do we add this forward edge to the residual network? Well, in order to not be there before, the flow had to be full. So if the flow was full, so it means the flow equaled the capacity along that edge, and then the flow was reduced, then this edge would have leftover capacity. So it would be added into the residual network. Now, how can the flow be reduced along this edge? That means we send flow along the back edge. To send flow along the back edge, that means the back edge was in the augmenting path cal-p. So if this forward edge was added into the residual network, then the back edge must have been on the augmenting path. Now, let's look at the other case where we remove this forward edge from the residual network. Now, we will remove it if there was some leftover capacity, but now there's no leftover capacity. So the flow equals the capacity along this edge. That means we augmented the flow, increased the flow along this edge. So this forward edge itself is on the augmenting path. In order to remove this forward edge from v to w from the residual graph, then this forward edge from v to w must be on the augmenting path because we increased the flow along this edge. Now, the other type of edge that we can add into the residual network is the back edge from w to v. To add the back edge in, the flow must have been empty and then we increase the flow along the edge from v to w. To increase the flow from v to w, that means this edge from v to w must be on the augmenting path. The final case is when we will remove the back edge from the residual network. Now, in order to remove this back edge from the residual network, there must have been some flow along the forward edge, and then the flow is now empty. So we must have decreased the flow along this forward edge. To decrease the flow along the forward edge, that means we send flow along the back edge. So the back edge from w to v must be on the augmenting path cal-P.

MF4 Edmonds Karp Algorithm - 390 - Conclusion
Here are the key conclusions that we need from this analysis. If we add an edge from vertex y to vertex z to the residual network, then what can we conclude? Well that's this case, and this case. Notice that in both of these cases, the opposite direction edge is always on the augmenting path. So if we add this edge from y to z to the residual network, then we know that the edge from z to y is on the augmenting path. Similarly, if we remove the edge from y to z from the residual graph, then what can we conclude in this case? Well, when we remove, then we notice that the edge itself is on the augmenting path. So in this case, we know that the edge from y to z is on the augmenting path. So if we add an edge y to z to the residual graph, then the opposite direction edge is on the augmenting path. If we remove an edge, then the edge itself is on the augmenting path. This should make intuitive sense, because to remove an edge from the residual graph, that means we remove the leftover capacity. In order to remove the leftover capacity, that means we have to increase the flow along this edge. To increase the flow along the edge, the edge has to be on the augmenting path in order to augment along it. To add an edge to the residual network, we have to increase the spare capacity. That means we have to decrease the flow along this edge. To decrease the flow along an edge, then the reverse direction edge must be augmented. So it must be on the augmenting path.

MF4 Edmonds Karp Algorithm - 391 - Proof of Claim
Now, let's prove the main claim that we made earlier. For every vertex Z, the level of that vertex does not decrease during the course of the Edmonds-Karp algorithm. Now, the residual graph may change. We may add edges or delete edges from the residual graph, but the level of the vertex never decreases. How potentially can the level of a vertex decrease? While the level of a vertex might decrease if we add an edge from Y to Z and Y gives a shorter path to Z. Now, suddenly removing edges can decrease the level of a vertex so we can ignore removing edges. We simply have to look at adding edges and their potential effect. So suppose the level of Vertex Z is currently I and then suppose that we add this edge from Y to Z into the residual network. Now, if we add this edge from Y to Z to the residual network, what do we know? Well, as we just saw, then the reverse direction edge must be on the augmenting path. Now, we have to utilize the properties of the Edmonds-Karp algorithm. Edmonds-Karp algorithm says this path, this augmenting path is a BFS path. So we obtained this path by running BFS. Now what do we know about pass from BFS? We know that on this path, the level of the vertices increases by Plus 1 along every edge. Therefore, the level of Y must be the level of Z plus 1. We said the level of Z is i so therefore the level of Y is I plus 1. So we added this edge from Y to Z but this edge goes from a higher level to a lower level. So it certainly does not decrease the level of vertex Z. It does not give a shorter path to Z. So the level of the vertex Z does not decrease when we add this edge in. Now, this completes the proof of this claim. So we prove that the level of a vertex never decreases during the course of the Edmonds-Karp algorithm. This completes the proof of the claim but in order to bound the number of rounds of the algorithm, we're going to have to prove something stronger. We're going to have to prove that occasionally, the level of a vertex strictly increases and then this will give us a bound on the number of rounds of the algorithm.

MF4 Edmonds Karp Algorithm - 392 - DeleteAdd Effect
Now our main lemma bounds the number of times that we can delete an edge and then add it back in. Let's look at the effect of deleting an edge and adding it back in on the level of the vertices. Let's take a particular vertex v and let's say the current level of this vertex v is i. Now suppose at some later round we delete this edge from v to this vertex w from the residual network. What can we conclude about the level vertex w when we delete this edge from v to w? Now if we were deleting this edge from v to w from the residual network, what do we know about the augmenting path? We know this edge itself from v to w is on the augmenting path. That means the level(w) is the level(v)+1. Now at the time that we deleted this edge, the level(v) might have changed from the earlier time, so might not be level i anymore. But what do we know about the level vertex v? We just prove that the level(v) never decreases. So this level(v) at this current time must be at least i. So this is at least i+1. So the level(w) at this time is at least i+1. Now suppose later we add this edge from v to w back into the residual network. Now if we're adding this edge from v to w into the residual network, then we know that the reverse direction edge, the edge from w to v must be on the augmenting path. Therefore, at this current time, the level(v) must be equal to the level(w)+1. By our claim, we know that the level(w) did not decrease from earlier times and we earlier showed that the level(w) was at level at least i+1. So this is that level at least i+2. Notice what we just proved. Suppose the level(v) is i, now we take an edge going out from vertex v, and we delete that edge and later we added it back in. After we added this edge back in, we know that the level of the vertex is at least two greater than what it previously was. So the level of this vertex increased by at least two.

MF4 Edmonds Karp Algorithm - 393 - Finishing Off
We just showed that if we delete an edge v to w from the residual network and later we add this edge back into the residual network, then the level of this vertex v increase by at least two. If we look at the level of vertex v before this deletion compared to after the insertion, the level of the vertex increase by at least two. Now, what do we know about the level of vertices? The minimum level is zero, that's for vertex S itself. The maximum level is n. Therefore, what's the maximum number of times that we can delete and then add this edge back into the residual network? We can delete it and then reinsert it back in at most n over two times. Since there m edges in the graph, this proves our main result that there is at most nm rounds in the Edmonds-Karp algorithm. And that completes the analysis of the Edmonds-Karp algorithm.

MF5 Max Flow Generalization - 394 - Max-Flow with Demands
Let's look now at a generalization of max-flow problem. We're going to add in demand constraints along every edge. We're going to see how to reduce this generalization of the max-flow problem to the standard max-flow problem. Let's formalize this generalization of the max-flow problem. The input starts off the same as before for the max-flow problem. So we have a flow network, which consists of a director graph, G, with a specified start and end vertex, s and t, along with the capacities for every edge. Now the new aspect is that we're also given the demands for every edge. So for edge e, were giving the non-negative number, d of e, which specifies the demand for this edge. Now our goal is to find a feasible flow. What exactly do we mean by feasible flow? A feasible flow is a valid flow as before. So along every edge, the flow is in most capacity, but then we have the additional constraint, that the flow must be at least the demand along that edge. And of course, the other constraint still hold as before. So for every internal vertex, so for every vertex except for s and t, we want to flow in to equal the flow out. So we're looking for a valid flow as before with the additional constraint that the flow along every edge is at least the demand along that edge. Now if we can find a feasible flow, of course we want a feasible flow of maximum size. But the first problem is whether we can even find a feasible flow. Is there a way to satisfy all of the demands? That's the first question we're going to address. Can we figure out whether there is a feasible flow for this input? Once we find a feasible flow, then will be straightforward to augment it into a maximum size feasible flow.

MF5 Max Flow Generalization - 395 - Feasible Flow Example Question
Let us take a look at one of our flow network examples from earlier. And let us look at the feasible flow problem in this example. So here is a directed graph with the specified start and end vertex. Let's mark the demand and the capacities along every edge. The green numbers specify the demand along the edge and the red numbers specify the capacity along the edge. So along this edge we want the flow to be at least two units and at most eight units. Along this edge, there is no demand constraint. It has got to be at least zero and at most three. Here it has got to be at least three and at most six. Is there a feasible flow for this example?

MF5 Max Flow Generalization - 397 - Reduction Overview
Now, we're going to show a reduction from the feasible flow problem, to the max-flow problem. Recalling the feasible flow problem we're trying to find a feasible flow, not necessarily of maximum size. In the max-flow problem we're trying to find a valid flow of maximum size. Formally, what do we mean that we're reducing this problem to this problem? What it means is that we're going to use our algorithms, our polynomial time algorithms for the max-flow problem as a black box. So, it's as if we have this subroutine that we downloaded from the library and we don't want to touch the insides of this subroutine. We can simply give it an input flow network and we'll get out a solution. A flow, F prime of maximum size for this input flow network. Now, we want to use this black box algorithm for max-flow, to build an algorithm for the feasible flow problem. What we're going to do is, we're going to take an input to the feasible flow problem. What exactly is input to a feasible flow problem? Well, there's a directed graph G. There are capacities along every edge, specified by C of E, and there's also demands along every edge specified by D of E. Now, we're going to define a function G, which transforms this input to the feasible flow problem, into a valid input to the max-flow problem. Once again what does the input to the max-flow problem look like? Well, it consists of a directed graph. Not necessarily the same directed graph that we have for the feasible flow problem, we're going to make a new graph. So, we're going to define a new directed graph G prime, based on the directed graph G. And, we also need to specify the capacities along every edge. So, we'll define C prime of E to be the capacity along edges in this graph G prime. But, there are no demands in this graph. The input to the standard max-flow problem does not have any demand constraints. So, we have to somehow encode these demands in these capacities and in this graph G prime. Then, we're going to run our black box algorithm for the max-flow problem on this input. We're going to get some output F prime, and then we have to transform this output into a solution to the original feasible flow problem. So, we have to define a function, which would then notice H, which transforms this output, this solution to the max-flow problem on this input graph, G prime with capacity C prime. And H has to transform F prime into a flow F, where F is a feasible flow for this input, G, capacity C and domains D. So, to reduce feasible flow to max-flow, what we need to do is, we need to define this transformation function g. Which transforms an input from feasible flow into an input for max-flow. And we need to define this function h, which transforms the solution f prime for the max-flow problem on this input, G prime. And produces a solution f, which is a feasible flow for this input network, g with capacity C and demands d. So, in order to reduce feasible flow to max-flow, we need to specify this function transformation function g and this transformation function h. G transforms the input and h transforms the solutions.

MF5 Max Flow Generalization - 398 - Reduction Vertices
So let's dive into the reduction. So let's take a particular input for the feasible flow problem. This is specified by a directed graph G, capacities along the edges and demands along the edges. Now we need this to construct an input for the max flow problem. This is specified by a directed graph which we'll call G prime and capacities along the edges which was specified by C prime. Now these capacities don't have to be the same as the original capacities. In fact, we need these capacities to encode not just the capacities in the original graph, but also the demands in the original graph. Let's take a look at a particular example, very simple example, here's a small example of four vertices, this is our directed graph G, which is our input to the feasible flow problem. That specified some example capacities and demands. We've written a pair of numbers for each edge. The first number, for example three, specifies the demand, and the second number specifies the capacity. Now let's try to create a graph G prime. Well we want to keep all this information, so we're going to keep the same graph G and we're going to add additional vertices to it. So this is going to be our directed graph G prime which is going to be the input to the max flow problem. So we're going to start with the same graph G that was the input to the feasible flow problem and we're going to add a new start vertex which will denote is as prime and a new n vertex which will denote as t prime. So the original s and t will now serve as internal vertices. Now these are the vertices of this new graph G prime. Let's now look at the edges that are in this graph and also the capacities and along the edges in this new graph.

MF5 Max Flow Generalization - 399 - Original Edges
Now the edges in the original flow network G, remain in this new flow network G prime. What will change is the capacities along these edges. Now we want the capacities along these edges to capture the capacities along the original network, and the demands in the original network. What we want to capture is that there is non-negative flow along an edge, if and only if we can construct a flow in the original network, where the flow is at least the demand. And we also want that the flow in this new graph G prime, satisfies this new capacity constraint, if and only if this flow f, that we're going to construct, satisfies the capacity constraint in the original network. Now, the idea is that we want to flow zero in this new network to correspond to flow d in this original network. So this flow is going to be a shift of this flow by d units. So, were going to shift the capacity as well by d units. So the capacities along these edges, which were edges in the original network, will be the original capacities minus the demand. So, whereas this edge from s to a originally had capacity 10, now it'll have capacity seven. This edge will have a capacity of one, four, four, and also four.

MF5 Max Flow Generalization - 400 - New Edges
So what we've done so far in our reduction is for each edge in the original network G. We've added that edge to this new network G-prime, and the capacity of that edge in the new network is the original capacity shifted by the demand. Now we're going to have to add additional edges to this graph. Let's get some intuition for what these additional edges have to accomplish. Now we want a valid flow here in this graph G-prime to correspond to a feasible flow here. So suppose we have a zero flow here. So we have flow zero from s to a, zero from a to b, and zero from a to t. Now what is that going to correspond to over here? Well, zero flow along this edge is going to correspond to flow three along this edge. Zero here is going to correspond to flow one here, and zero here is going to correspond to flow seven here, because the minimum flow here is going to correspond to the minimum flow here. Now certainly zero flow here is valid. The flow into a is zero and the flow out of a is zero. But over here, we have flow in of three units and we have flow out of eight units. So it's not a valid flow over here. The flow into a does not equal the flow out of a. So we need to offset that somehow in this graph so that a valid flow here will correspond to at least a valid flow here. We're going to accomplish that by adding an edge from s-prime to each of these vertices of the original network, and from each of these vertices of the original network to t-prime will have an edge. Let's look first at the edges from s-prime to each of the vertices of the original network. So for each vertex in the original network, we add this edge from s-prime to v. Now, what is the capacity of this edge from s-prime to v in this new network G-prime? Well, we shifted the capacity along this edge into a by three units corresponding to the demand into a. We want to offset that by this edge from s-prime to a. So we're going to define the capacity of this edge to be the demand into the vertex v. So the total demand into the vertex a in the original network is three units. So the capacity of this edge from s-prime to a will be three units. Now t has total demand in of seven plus two, so nine units. So this edge will have capacity nine, b has demand in five units, so this edge has capacity five, and s, of course, has zero demand in. So this edge has zero capacity. Similarly, we are going to add edges from each of these vertices of the original network to t-prime. Now we'll put these in a different color just to differentiate them from the edges from s-prime. So we have s to t-prime, a to t-prime, t to t-prime and b to t-prime. What is the capacity of these edges to the vertex t-prime? Well, from s-prime, that captured the demand into the vertex v and these edges to t-prime are going to capture the demand out of the vertex v. So vertex s has demand out of seven, so this edge has capacity seven. Vertex a has total demand out of eight, so this edge has capacity eight. T, of course, has zero demand out, and b, in this example, has demand out of two. So, that fully specifies our graph G-prime which is our input to the max-flow problem. Now we have to discuss how a solution to this max-flow instance corresponds to a solution to the feasible flow problem.

MF5 Max Flow Generalization - 401 - One More Edge
Now, there's one additional edge that I almost forgot to mention in this graph G prime that we're constructing. Now, notice in the original graph S is the start vertex and T is the end vertex. In this new graph, S and T are internal vertices. So, the flow in has to equal the flow-out for both these vertices. Whereas over here, we don't have that constraint. Notice there's no flow-in. There's no capacity into this vertex, S and T has no capacity. So, in the current set up we don't have any flow into S and any flow out of T. How do we get around that so that we can have the flow-in S equal to the flow-out and similarly for T? Well, we know the flow-out of S equals the flow into T, so we simply have to offset the flow-out of T and the flow-in to S. So, we compare these up with each other. So, we're going to add this edge from T to S. And we don't have any constraints on the flow along this edge, our flow goes into T. We want to send that back to S. So, we give this edge capacity infinity. So, to summarize, we're adding this edge from T to S and the capacity is infinite. Now, we really have completed our construction of this graph G prime.

MF5 Max Flow Generalization - 402 - Saturating Flows
Now, let's take a look at this graph we constructed. What is the maximum flow size that can occur in this graph? Certainly, it's upper bounded by the capacity, the total capacity out of S-prime or the total capacity into T-prime. Let's take a look at those quantities. Let capital D denote the total demand in this original network G. So, we're going to sum over edges in this original network of the demand along that edge. Notice, this is the same as summing over the vertices of the total demand into the vertex because every edge has one tail. And similarly, we can count from the head of the edge. So, we can sum over vertices of the total demand out of each vertex. Now, in this graph, what does the total capacity out of S-prime? Well, the capacity along this edge from S-prime to a is defined as demand into a. So this total capacity out of vertex S-prime is a sum over vertices in the original graph of the demand into that vertex. That's equal to the quantity D. Similarly, if we look at that the total capacity into the vertex T-prime, that's equal to the total demand out of the vertices, which is also equal to capital D. So, if we look at the value of flow F-prime in this new graph G-prime that we constructed, what do we know about the size of this flow F-prime in this graph G-prime? We know it's upper bounded by the total capacity out of S-prime or the total capacity into T-prime. Both of those quantities are capital D. So, the size of this flow F-prime is in most capital D. Therefore, we say this flow F-prime is saturating, if the size of this flow F-prime is capital D. This means that this flow F-prime is of maximum size. So, all of these edges out of S-prime are fully capacitated, they're fully saturated. And all these edges into T-prime are fully saturated. So, in a saturating flow F-prime, we fully capacitated the edges out of S-prime, and fully capacitated the edges into T-prime. What we're going to prove is that G, our original network, has a feasible flow if and only if, this new network G-prime that we constructed has a saturating flow. Once, we prove this lemma, this gives us a way to find a feasible flow. What we do is we take our input to the feasible flow problem, we construct G-prime, we run max-flow on this graph, G-prime, and we check if the size of the max-flow is equal to capital D, and therefore, it is saturating or not. If it is a saturating flow, then, we know that there is a feasible flow and actually our proof of this lemma will give us a construction. So, we can take this saturating flow F-prime and construct a feasible flow F for this original network G. So, what we've done so far is transform the input to the feasible flow problem into an input to the max-flow problem. And now, by proving this lemma, we're going to show how to transform the solution to the saturating flow problem or to the max-flow problem on this graph G-prime, into a solution to the feasible flow problem.

MF5 Max Flow Generalization - 403 - Saturating Feasible
Let's first prove that the existence of a saturating flow G prime implies the existence of a feasible flow in G. So what we're going to do is we're going to take a saturating flow F prime in this graph G prime that we constructed, and we're going to use that to construct the feasible flow F in the original flow network G. Now the construction is quite straightforward. Recall that the capacities in G prime, where the capacities in G, shifted by the demand D. So, we're going to let the flow in G be equal to the flow in G prime, plus the demand. So if we had zero flow in G prime, then we'll have the minimum flow possible in G, which is the demand D of E. And if we send, say two units of flow in G prime along this edge E, then will send two plus the demand along the edge E in the graph G. Now there's two things we need to check. We need to check that F is a valid flow. So for all the internal vertices in this graph G, the flow in has to equal the flow out, and to be valid, we need that to flow along an edge is in most the capacity, and additionally, we need to check that F is a feasible flow. That means it satisfies all the demand constraints. Let's start with the second condition. Let's check that F is a feasible flow. Now F prime is a flow. What does that mean for the flow along a particular edge E? It's got to be non-negative. So what does that imply about this flow F that we just constructed? Well then the flow F along the edge E is at least D of E. Zero flow corresponds to D of E flow, and since the flow is now-negative, that means these flows F satisfy the demand constraints, so F is feasible. While we're at it, let's look at the capacity constraints, the upper bound on these flows. We know this flow is at most C prime E along the edge E. That implies that the flow F along this edge E is at most C prime of E plus demand E. Recall, C prime of E was defined as C of E minus the demand long E. Therefore, this quantity equals the capacity along the edge in the original network G. So this flow F that we constructed, satisfies demand constraints and satisfies the capacity constraints. So all that remains is to check that the flow in to every vertex equals the flow out.

MF5 Max Flow Generalization - 404 - f is Valid
Now in order to show that this flow F is valid, we need to show that for every vertex, the flow in equals the flow out of the vertex. Now this is for every internal vertex. So this is for every vertex in the original graph except for S and T. Now this is for the flow F that we constructed. Now what do we know? We know that this flow F prime was an output from the max flow problem. So F prime is a valid flow for the graph G prime. So we know in this graph G prime, the flow into the vertex V equals the flow out from the vertex V. So we want to use this fact to imply this fact. So let's take a look at this first quantity. The flow into the vertex V in this graph G prime. Now which vertices have edges to the vertex V? This is in the graph G prime that we constructed. While this new vertex S prime has an edge to every vertex. So there's an edge from S prime to V and for every vertex in the original graph, if U was connected to V in the original graph, then it's still connected in this new graph G prime. Now what do we know about this first term? We assume that F prime was a saturating flow. That means that all the edges out of S prime are fully capacitated. So this flow along this edge is up to its full capacity. What's the capacity of this edge? It was defined to be the demand into the vertex V. Now what about this latter quantity? Well let's rewrite this flow F prime along this edge in terms of F. The flow F along this edge from U to V was, by our definition, equal to the flow of F prime along this edge plus the demand. Therefore, F prime equals F along this edge minus the demand along this edge. That we can factor out this sum over U to each of these terms and then this latter quantity is minus the sum over U of the demand into V. So that sum is equal to the demand into V. So this term and this term cancel each other out and what are we left with? We're left with the flow into V in this flow F. So that means the flow into V under this flow F prime is equal to the flow into V in this flow F. Now that's not too surprising because we set up this flow, this capacity along this edge from S prime to offset this difference. So this was by design but we have this nice fact, the flow into V is the same in F prime and in F and similarly you can show that the flow out of V under F prime and F are the same by similar algebra. So therefore, if the flow into V is the same as the flow out of V under F prime and F prime and F have the same flow into V and the same flow out of V, then we also have this statement that we want to prove. So we've shown that F is a valid flow. So we've shown that we can take a saturating flow F prime and we can construct a feasible flow F by simply setting F equal to the flow F prime plus the demand along the edge. Now we have to prove the reverse direction.

MF5 Max Flow Generalization - 405 - Feasible Saturating
To prove the reverse direction, what we want to do now is take a feasible flow f in the graph G, and we want to construct a saturating flow f-prime in this new graph G-prime. Now for each edge of the original network G, we're going to define the new flow along that edge to be the old flow shifted down by the demand along this edge. Now that defines a flow for all the edges in the original network. What about the new edges that we added to this graph G-prime when we did the construction? Well for every vertex in the original network, we have an edge from s-prime and edge to t-prime. So we have this edge from s-prime to v and v to t-prime. Now we're trying to construct a saturating flow. So each of these edges is supposed to be fully capacitated. So we might as well set this flow to be equal to its capacity which is the total demand into v for this edge and the total demand out of v for the edge two t-prime. That defines a flow f-prime for all the edges except for one. We have this edge from t to s which had infinite capacity. We want to set the flow along this edge to be equal to the size of this flow f. That defines the flow f-prime. Now we have to check that f-prime is valid and it's a saturating flow.

MF5 Max Flow Generalization - 406 - f is Valid
Now we know that f is feasible. What does that mean? That means that the flow along this edge E is at least its demand. Now f-prime along this edge E is defined to be f along this edge minus the demand. So since this is true, we have the flow f-prime along this edge is at least zero. So f-prime is non-negative. Similarly, we have that f is at most its capacity. Therefore, f-prime is at most the capacity minus the demand which is the definition of the capacity in this network G-prime. So we know that this new flow f-prime that we constructed is non-negative and satisfies the capacity constraints. Now we simply have to check that f-prime satisfies the flow in equals the flow out constraint.

MF5 Max Flow Generalization - 407 - f Constraints
So we need to check that the flow into every vertex, except for S prime and T prime, under F prime, equals the flow out. Now we started from F, and we know that the flow into the vertex V, under F, equals the flow out from the vertex V. So now we're going to do a little bit of algebra that's similar to before. So we want to go from this fact, to this fact. Now, what is the flow into the vertex V under F prime? Where we have the flow from S prime, we set that equal to the demand into the vertex V. So this is the flow from S prime. Now for every other edge, the flow from that vertex U to V in F prime, is it defined to be the flow in F minus the demand along this edge? As before, this sum over U of this demand into V is the same as this quantity. They're both equal to the total demand into V. So they offset each other, and we're left with the total flow into V under F. So as before, the flow into V under F, is the same as the flow into V under F prime. And similarly, the flow out of V under F prime, equals the flow out of V under F, by similar calculation. Therefore, since the flow into V equals the flow out of V under F, and these are equal to F prime, we also have this factor F prime. And therefore, F prime is a va.

MF5 Max Flow Generalization - 408 - Max Feasible Flow
So we've proved this lemma: G, our original input, has a feasible flow if and only if our new construction G' has a saturating flow. So, to solve the feasible flow problem to find a feasible flow in this input graph, we simply construct this graph G', we run the max-flow problem, we check whether the size of this max-flow equals capital D, and therefore whether or not it's a saturating flow. If it is a saturating flow, then we've shown how to transform that saturating flow f' into a feasible flow f for this graph G. So, we know how to find a feasible flow f for this graph G if one exists. Once we have such a feasible flow f, can we transform it? Can we augment it to find a flow, a feasible flow of maximum size? So, can we find a maximum size feasible flow? Now recall how our max-flow algorithms worked, either Ford-Fulkerson or Edmonds-Karp. Both of them start with a zero flow. So every edge has flow zero initially then we build the residual graph and we find an augmenting path from s to t if one exists. If there exists one, we augment along that path then we build a new residual graph and we repeat. We keep augmenting along a path from s to t in the residual graph until there's no path from s to t in the residual graph, and therefore, the flow that we're at is a max-flow. Now we want to do a similar procedure for the feasible flow. So here, we're going to start at this feasible flow f that we found. Instead of starting at the zero flow as we did for the max-flow algorithms, here we're going to start with a feasible flow, and then we build the residual graph and we try to augment this flow. So we'd look for a path from s to t in this residual graph and augment along it if it exists and if none exists, we'll know that we're at a maximum size feasible flow. Now the only difference from before is that this residual graph is slightly different. Now the capacity of this edge from v to w in the residual graph for this current flow f. For forward edges, it's defined to be the leftover capacity. So it's the capacity minus the current flow. Now for reverse edges, so if there's an edge from w to v in the original graph, then we add the edge from v to w if there is flow from w to v. So normally in the residual graph, the capacity of this edge from v to w, this reverse edge, will be the flow along this edge. But now, we have the constraint that the flow can never go below the demand. So it can't decrease the flow below the demand. So the amount we can decrease the flow along this edge from wv is by how much the flow exceeds the demand. So we set the capacity of this reverse edge to be the flow along this edge minus the demand, and finally its zero otherwise. So, to find a max feasible flow, we run our max-flow algorithm with the following changes. Instead of starting at zero flow, we start at a feasible flow, and when we're building the residual graph, the reverse edges, their capacities is defined as not the flow along the edge but how much the flow exceeds the demand.

