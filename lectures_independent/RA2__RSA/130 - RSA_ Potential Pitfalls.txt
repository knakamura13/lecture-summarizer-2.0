let's look at some of the issues that can arise when we're implementing RSA first off suppose in our message little m is not relatively prime to capital n so the GCD of little m and capital n is greater than 1 now capital n is a product of two primes P and Q so it's only divisors are P and Q so what can be the common divisor of m and capital n it's got to be either P or Q so let's suppose that GCD of little m and capital n is P now what happens in the RSA protocol or we take this message m raise it to the power E and look at that mod capital N and then the receiver takes this encrypted message raises it to the power D and then takes it mod N and what do we get back well this equals the original message M now we didn't prove this case we proved the case when they're relatively prime to each other and then if followed by Euler's theorem and we claim that this case when they're not relatively prime followed by the Chinese remainder theorem this is in fact true but there's a potential problem in this case what's the problem well P divides m and N and if we look at the encrypted message Y which is m to the e mod n or of P divides M and it divides n then it's also going to divide Y so the GCD of Y and capital n is also going to be P what does this mean well anybody that's eavesdropping is gonna see this encrypted message and from this encrypted message and the public key capital n by simply running Euclid's algorithm they can take the GCD of these two numbers and they find that the GCD is little P prime P and once they know prime P then they can factorize n and therefore they can break the RSA cryptosystem they can find the decryption key little T so before using this message m and sending the encrypted version of it we have the first chat that m and n are relatively prime to each other if they share a common factor then anybody will be able to use this encrypted message to break this crypto system what are some other issues that can arise we need that little m is not too large in particular we need that little m is strictly less than capital n now typically our message is text so we first have to convert it into a number how might we do that well we can take the binary version of the text now the binary version of the text is gonna be a huge number so what we do is we break this huge number into n bit segments these are segments of length little N and therefore little m will be at most strictly less than 2 to the little n so if we break the message into little n bit strings then we get this property and if we ensure that P and Q are sufficiently large so we ensure that they're leading bit is 1 then if we look at capital n we know that capital n will be at least 2 to the N and therefore little m will be strictly smaller than capital n so this property that little m is not too large as easy to insure but we also need that m is not too small why is that the case well suppose that little e equals 3 which is a common practice and suppose that M is very small number so m cubed is strictly smaller than n or when we look at M cubed mod n what do we get well the mod n isn't doing anything because M cubed is smaller than n so M cubed or m to the e is the same as m to the e without the mod n so this mod n is not doing anything when this number m is too small and that means that our encrypted message the message we're sending in clear text is simply M cubed the Madonna isn't doing anything now if we see this message m cubed how do we decrypt it we just take the cube root so anybody seeing this encrypted message can simply take to the to brood and we get the original message back so it's easy to decrypt it's easy to break this crypto system in this case cube roots are difficult to do when we're doing it with respect to modular arithmetic but in real arithmetic cube roots are easy to do so how do we avoid this issue when we have a small message well we can choose a random number R and we can look at M plus R or M exclusive or with R and we can send this new message this padded message and we can also send a second message which is just R itself so we send two messages the padded message are itself and as long as our is not too small then this will be okay and if our is too small just choose a new random string until we get an R which is sufficiently large now there's one last issue I want to point out if we use the same message multiple times then we have a potential problem suppose we have the same message that we want to send to three different people each of these three people have a different public key but they're all using a equals two three suppose the first recipient has e equals to 3 and n one second recipient has n 2 and e equals to three third recipient has n 3 and e equal to three and suppose we use the same message m to send to these three people now the encrypted messages are going to be different the first encrypted message is going to be M cubed mod and 1 the second encrypted message is going to be M cubed mod and 2 the third one is going to be M cubed mod and 3 so we got three different encrypted messages y1 y2 and y3 but it turns out that if somebody sees these three encrypted messages which all come from the same message same number M then they can decrypt they can figure out M from y1 y2 and y3 how do they do that they use the Chinese remainder theorem this is a homework problem in the textbook in the desc coupe 2 textbook in Chapter 1 is problem 44 now all that remains for specifying the RSA protocol is to describe how we do primarily testing so let's dive into that