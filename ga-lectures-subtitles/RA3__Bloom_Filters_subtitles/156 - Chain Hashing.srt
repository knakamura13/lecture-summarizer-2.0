1
00:00:00,000 --> 00:00:03,630
 Once again, in the traditional hashing scheme, chain hashing,

2
00:00:03,630 --> 00:00:08,030
 H or hash table is an array of linked lists.

3
00:00:08,030 --> 00:00:10,350
 H is an array of size N, and H of I,

4
00:00:10,350 --> 00:00:12,195
 the Ith element of H,

5
00:00:12,195 --> 00:00:18,960
 is a linked list of elements in our subset S which map to I.

6
00:00:18,960 --> 00:00:22,530
 So, in other words, H of I is a linked list of those elements.

7
00:00:22,530 --> 00:00:27,350
 So, those unacceptable passwords whose hash value is exactly I.

8
00:00:27,350 --> 00:00:28,735
 Let's look at the query time.

9
00:00:28,735 --> 00:00:31,780
 How long does it take us to answer a query of the form?

10
00:00:31,780 --> 00:00:35,550
 Is X in a subset S, that we're maintaining.

11
00:00:35,550 --> 00:00:37,060
 Now, in order to answer this query,

12
00:00:37,060 --> 00:00:40,985
 what we have to do is look at the hash table at the index I,

13
00:00:40,985 --> 00:00:43,800
 which is H of X, and then we have to go through

14
00:00:43,800 --> 00:00:48,215
 that entire linked list and check whether X is in there in that linked list or not.

15
00:00:48,215 --> 00:00:49,665
 So, the time it takes us,

16
00:00:49,665 --> 00:00:52,785
 is proportional to this size of this linked list.

17
00:00:52,785 --> 00:00:54,445
 What's the size of this linked list?

18
00:00:54,445 --> 00:00:56,215
 It's the load at this bin.

19
00:00:56,215 --> 00:00:58,995
 If we think of the elements of S as balls,

20
00:00:58,995 --> 00:01:00,750
 these are getting assigned to bins,

21
00:01:00,750 --> 00:01:02,220
 which are their hash values.

22
00:01:02,220 --> 00:01:04,440
 The time it takes us to answer a query is

23
00:01:04,440 --> 00:01:07,480
 proportional to the load size at the hash value.

24
00:01:07,480 --> 00:01:09,225
 Let's introduce some notation.

25
00:01:09,225 --> 00:01:13,035
 Let M be the size of our dictionary of unacceptable passwords,

26
00:01:13,035 --> 00:01:16,310
 and let little n, be the size of our hash table.

27
00:01:16,310 --> 00:01:18,660
 So, in our balls in bins analogy,

28
00:01:18,660 --> 00:01:21,654
 little m is the number of balls that we're throwing in,

29
00:01:21,654 --> 00:01:24,515
 and little n is the number of bins.

30
00:01:24,515 --> 00:01:28,210
 Now, if m equals n, so the number of balls is the same as the number of bins.

31
00:01:28,210 --> 00:01:30,470
 This is the toy problem that we analyzed before,

32
00:01:30,470 --> 00:01:34,680
 and what we saw is that the max load is order log n, with high probability.

33
00:01:34,680 --> 00:01:36,580
 Of course, in the worst case it might be,

34
00:01:36,580 --> 00:01:39,700
 order n or n might be the max load,

35
00:01:39,700 --> 00:01:41,230
 but that's an unlikely event.

36
00:01:41,230 --> 00:01:44,650
 With high probability, the max load is going to be order log n,

37
00:01:44,650 --> 00:01:46,960
 which means in the query time in the worst case,

38
00:01:46,960 --> 00:01:50,040
 it's going to be order log n with high probability.

39
00:01:50,040 --> 00:01:51,460
 Now, when n is huge,

40
00:01:51,460 --> 00:01:55,090
 then order log n might be too slow for us.

41
00:01:55,090 --> 00:01:57,490
 So how can we achieve faster query time?

42
00:01:57,490 --> 00:02:00,895
 Well, one way is to try to increase the size of our hash table.

43
00:02:00,895 --> 00:02:05,675
 In order to decrease this max load from order log n to order one,

44
00:02:05,675 --> 00:02:10,020
 so that the query time will be order one constant time queries.

45
00:02:10,020 --> 00:02:12,460
 We're going to have to increase the size of the hash table

46
00:02:12,460 --> 00:02:16,245
 from order m to order m squared.

47
00:02:16,245 --> 00:02:18,430
 Now, that's quite a large price to pay.

48
00:02:18,430 --> 00:02:23,275
 So let's see if there are simpler ways to achieve reductions in the query time.

49
00:02:23,275 --> 00:02:25,540
 Now, our intuition for the following scheme is

50
00:02:25,540 --> 00:02:28,215
 comes from the balls and bins example from before.

51
00:02:28,215 --> 00:02:30,365
 This is a simple scheme that we use right now.

52
00:02:30,365 --> 00:02:32,975
 We're sending n balls into n bins.

53
00:02:32,975 --> 00:02:35,125
 Each ball is going into a random bin.

54
00:02:35,125 --> 00:02:38,080
 What do we use to improve that balls and bins scheme,

55
00:02:38,080 --> 00:02:39,690
 to improve the max load?

56
00:02:39,690 --> 00:02:41,635
 Well, we use the two choice scheme,

57
00:02:41,635 --> 00:02:46,180
 and what we saw is that the max load goes down to order log log n,

58
00:02:46,180 --> 00:02:50,910
 when we allow each ball to go to the least loaded of two random bins.

59
00:02:50,910 --> 00:02:50,910
 So, let's try and use a similar scheme now for hashing.

