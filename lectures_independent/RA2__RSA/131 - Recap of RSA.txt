Let's take a moment now to recap the RSA algorithm and also the mathematics behind the algorithm. We start with Fermat's little theorem, that was the basis of the whole algorithm. Let's recap that. So the setting is, we have a prime number p and we have another number z, where z and p are relatively prime to each other, which means that the GCD of z and p is one. This means that they're relatively prime if their GCD is one. Now, the theorem says, if we take z and raise it to the power p_minus_one and we look at it mod_p, then what are get? We get one. And that's true for any z, so take any z which is not a multiple of p and we raise it to power p_minus_one we get one_mod_p. Actually, we didn't use Fermat's little theorem, we used the generalization known as Euler's theorem. Now Euler's theorem is a general theorem that holds for any capital N, but we used it for the particular case where capital N was the product of two primes, p and q. So let's recap it for this particular case that we're interested in. So, for primes p and q, look at their product, capital N, and take a z, which is relatively prime to capital N. Now in this case, if we raise z to the power p_minus_one_q_minus_one, then we get the analog of Fermat's little theorem. This is going to be one, when we look at it, mod_N, where N is p_times_q. Now, where did this exponent p_minus_one_times_q_minus_one come from? Well, that came from, we looked at how many numbers between one and capital N? This is the capital N here. How many numbers between one and capital N are relatively prime to capital N? For the case where capital N is p, then all numbers from one to p_minus_one are relatively prime to this N. So that's why the exponent is p_minus_one. For the case where N is p_times_q, then the number of numbers between one and p_times_q, which are relatively prime to it, are p_minus_one_times_q_minus_one. That's what we should solve before