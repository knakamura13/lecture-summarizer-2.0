Now, let's just go ahead and detail the Pseudo-code for our dynamic programming algorithm for the shortest path, single source shortest path problem. This algorithm is called the Bellman-Ford algorithm. The input to the algorithm is a directed graph G, a star vertex S, and weights on the edges. This algorithm goes back to the 50s. It was devised by Richard Bellman and Lester Ford. Now one interesting note is, Richard Bellman who devised this algorithm, he's actually the one who developed dynamic programming approach in the 1940s, long before there was any programming on personal computers or anything like that. So let's start with the base case which is the case i=0. And we're going to initial D(o,s) so going from S to itself using in most zero edges that's going to be of length zero. Now, we're going to work up from i=1 up to i = n -1. We're going to go over the vertices of the graph Z. We're going to initialize D(i, z) to be D(i-1,z). This is saying, that if we look at the minimum length path using the most i edges, we're going to first consider using the most i-1 edges and then we'll look at the scenario using i edges. To consider the scenario where we use the i edges, we look at all choices for the penultimate vertex with this Y. And we're considering those Ys which have an edge from y to z. Now we look at the path using Y and whether that path using Y is better than the current best solution. The current best solution is stored in D(i,z) and the path through Y has length D(i,-1,y) plus the length of this last edge W(y,z). If the length of this solution through Y D(i,-1,y) + W(y,z) is better than the current best solution, then we're going to update the current solution. Finally, what do we return? We return the case where i = n -1. And we're going to return it for all values of z. I just put a dot to denote this array of size n. So D(n-1)is an array of size n or if you think of it as two-dimensional table we're returning the last row of the table. Let's take a look at the algorithm a little bit more in detail. There's one slightly non-trivial step. Here, we're looking at the edges into z. Normally, when we have adjacency list we look at the edges out of Z. So how do we get the edges into a vertex? What we do is we look at the adjacency list for the reverse graph, so we flip all the edges. To construct this graph takes linear time O(n+m) time. And then we take the adjacency list for this reverse graph and that's going to give us the edges into z because in the reverse graph these are the edges out of Z. The edges in the reverse graph which are out of z are the edges into z in the original graph. Now, let's look at the running time with this algorithm. We have a for loop over i from one to n -1. This for loop is over order n choices. Then within this for loop, we're going over the vertices a graph and then we go over the edges into that vertex. So, really the key step is right here, this for loop. How many choices are we going over here? We're going over all edges of the graph once. So this is order m choices here and within for each edge of the graph, we do a simple if then statement which is order one time. So the total time for this for loop for this nested pair of for loops, we go over the vertices of the graph and then we go over the edges into that vertex. So the nested for loops combined go over all edges of the graph exactly once. So these inner four loops take order m time and the outer for loop takes order n time. So the total time is order n times m. So this algorithm is actually slower than Dijkstra's algorithm but it allows negative weight edges. Also, in addition, it's going to allow us to find negative weight cycles. So far, we've been assuming that there's no negative weight cycles in the graph so that the shortest path from S to every other vertex is well defined. Now let's go back and see if we can figure out whether there is a negative weight cycle in the graph or not and detect it. And if there is one output it.