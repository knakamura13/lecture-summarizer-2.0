Now, Euler's theorem was the basis for RSA algorithm. Now, let's go ahead in detail again the RSA algorithm. The first step is to choose a pair of primes p and q. These are the ones that we haven't seen actually how to do. We're going to explain how to choose prime numbers, after we review the RSA algorithm. Now, after we choose the pair of primes p and q, we look at their product. Hence let N be the product of p and q. The next step is to find an e which is relatively prime to (p-1)(q-1). By relatively prime, again we mean that the gcd of e and (p-1) and (q-1) is one. So they have no common factors. Now, why did this (p-1)(q-1) come up? Because recall Euler's theorem, that's the exponent here. So, what is the key implication of the fact that e is relatively prime to (p-1)(q-1)? That means that e has an inverse. So, the third step is to find the inverse of e relative to (p-1)(q-1). So, let d be the inverse of e mod (p-1)(q-1). We know it exists, because e is relatively prime to (p-1)(q-1). How do we find this inverse? We use the extended Euclid algorithm. Now, we can publish our public key N and e. We tell the whole world this public key N and e and anybody that wants to send us a message will encrypt that message using this public key, but nobody is going to know our private key little d. We're going to keep this private key d secret, because anybody that finds this private key d can decrypt messages. Now, anybody that wants to send us a message, let's say, m, they're going to encrypt the message using our public key. They take that message m, they raise it to power of e and look at a mod N. And then they send that Y, which is congruent to m to the e mod N. They send that message Y and the whole world can see that message Y, but only we can decrypt it, because only we know little d. Finally, we receive this message Y, this encrypted message. How do we decrypt it? We use little d in the following way. We take this encrypted message Y, we raise it to the power of little d and we look at that mod N. And it turns out that this equals m. What are the algorithms that we need to use? Well, first off, to find this e, which is relatively prime to (p-1)(q-1), what do we do? We try e equals three, five, seven, 11, 13, at some point we give up. For each of those e's, though, how do we check whether it's relatively prime to (p-1)(q-1)? We check its gcd which we do using Euclid's algorithm. Then once we find an e which is relatively prime, we compute its inverse. How do we do that? We used the extended Euclid algorithm, and we publish our key, usually e is small, so that taking m to the e mod N is relatively easy. If it's not, then we can use repeated squaring, our fast modular exponentiation algorithm, and definitely here, when we're raising this encrypted message Y to the power d, that's probably going to be to a huge power. So, how do we do Y to the d mod N? Here we need to use our fast modular exponentiation algorithm. The algorithm based on repeated squaring, and that's going to take time which is polynomial in little N, the number of bits in these numbers Y and d and N. Finally, the key thing about why this works is look at what's happening to the message. We're raising the message m to the power e and then to the power d. And recall that e times d is congruent to one mod (p-1)(q-1). So, when we apply Euler's theorem what we're going to get out is, we're going to get the message m back out. So, m raised to the power e times d modulo N is congruent to little m, because of Euler's theorem. What remains? We need to look at how we choose these prime numbers p and q. The other thing is let's just make an aside about why this algorithm is hard to break. Notice the whole world knows N, which is p times q, but only we know (p-1)(q-1), and therefore only we can compute the inverse of e mod (p-1)(q-1). The point is, can you get (p-1)(q-1) from N without knowing p and q, individually? The assumption is that no, we can not do that, that the only way to get (p-1)(q-1) is to get factor N into p and q. If you don't know how to factor N into the pair of primes which compose it, then you cannot get (p-1)(q-1). That's our assumption. So, this algorithm is as hard as factoring N. We don't know any other way to get (p-1)(q-1). And our assumption is that factoring is difficult, computationally difficult to solve. Now, to finish off the RSA algorithm, let's look at how we find prime numbers p and q.