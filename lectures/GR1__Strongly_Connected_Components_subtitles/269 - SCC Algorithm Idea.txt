Now, let's look at the main idea for our strongly connected component algorithm. Now, we're going to find these strongly connected components in topological ordering. So let's go back and look at our topological ordering algorithm for DAGs. Now, let's look at the topological ordering of a DAG where vertex V happens to be first and vertex W happens to be at the end. Now, what do we know about vertex W? We know it has to be a sink vertex. It might have some edges in but it can't have any edges out because those edges would go backwards in the ordering. Similarly, vertex V must be a source vertex. It can have edges out but it can't have any edges in. We have this alternative approach for topologically sorting a DAG. We could find a sink vertex, output it, rip it out, and repeat. Find a new sink in the resulting graph and repeat. Or, we could find a source vertex, put it at the beginning, rip it out of the graph, and repeat. Find a new source vertex in the resulting graph and so on. We can either work left to right, or right to left. Finding sink vertices and moving on, or finding source vertices and moving on. We're going to do a similar idea here but instead of finding a single vertex, we're going to find a sink strongly connected component. This is a component which is a sink vertex in a meta graph on strongly connected components. We're going to find a sink strongly connected component then we're going to output it. That's going to be at the end of our ordering. We're going to remove it from the graph, so we're going to remove all vertices from this strongly connected component from the graph and then we're going to repeat. We're going to find a sink component in this resulting graph, output it, remove it, and repeat until the graph is empty. Now, why do we do sink strongly connected components? Why not do source strongly connected components? For the topological ordering of the DAG, it didn't matter whether we started with sinks and worked that way backwards, or if we started with source and work forward. But for SCC it matters. Sinks are easier to work with. Why are sinks easier to deal with? Well, take any vertex which lies in a sink SCC. So S is a sink and strongly connected component, V is the vertex lying in that component. Now run Explorer from V. This is the basic procedure in the DFS algorithm. Suppose this is the first vertex that you explore from, which vertices do you visit when you explore from V? Well, take our earlier example where we had this sink strongly connected component which was H through L. Say we run explore from any of these vertices, what's going to happen when we run Explorer? We're going to visit all the vertices in this sink component but we're not going to visit any other components because we can't reach any other components from this component because it's a sink strongly connected component. So we visit all of this component and we visit nothing else. We don't see any other vertices, we just see this component itself. So if we can find a vertex which is guaranteed to be in a sink strongly connected component, then we can run Explorer from that vertex, and we're going to visit and we're going to find exactly that sink component. That's the key property about sink components. We just need to find a vertex which lies in that component, then when we explore from it, we're going to find the component itself and we're going to see nothing else. Therefore, we can mark all the vertices that we visited from this Explorer as lying in this sink component, then we can rip out those visited vertices and we can repeat the algorithm. Find a vertex in a sink of the resulting graph, run Explorer from it, mark those vertices as being in that component, and repeat. Now, what if we could find a vertex lying in the source component? For example, what if we can find vertex A? And we know that A is guaranteed to be in a source component, while in our earlier example, A happened to be a source component by itself. But suppose there are other vertices in this component and we want to figure out who are the other vertices in this component? When we run Explorer from vertex A, what happens? All we know is that from A we can reach many vertices. It's a source. So in fact, we can reach the whole graph from A. The whole graph is going to be visited. So we have no way of marking which vertices happen to be in this SCC and which vertices lie in other SCCs. But if we run Explorer from a vertex which lies in a sink SCC, we only visit that component and nothing else. That's the key property about sink components. Now, how can we find a vertex V which is guaranteed to lie in a sink component? That's our key task. Once we can find a vertex which is guaranteed to lie in a sink component, then we can run Explorer from that vertex, we'll find that sink component, rip it out, and repeat the algorithm. We'll find a sink component in the resulting graph, rip it out, repeat and so on.