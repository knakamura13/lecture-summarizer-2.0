1
00:00:00,000 --> 00:00:04,575
 Let's first address whether a knapsack problem lies in the class NP or not.

2
00:00:04,575 --> 00:00:08,990
 In order to lie in the class NP we have to be able to verify solutions.

3
00:00:08,990 --> 00:00:11,410
 We have to be able to do the following efficiently.

4
00:00:11,410 --> 00:00:14,430
 We have to take a particular input to the knapsack problem.

5
00:00:14,430 --> 00:00:18,165
 An input is given by a set of weights, a set of values,

6
00:00:18,165 --> 00:00:20,913
 and a total capacity to the for the backpack,

7
00:00:20,913 --> 00:00:23,530
 and we have to take a solution for that input.

8
00:00:23,530 --> 00:00:25,325
 Now, in polynomial time,

9
00:00:25,325 --> 00:00:30,655
 can we check whether this solution is in fact correct for this input?

10
00:00:30,655 --> 00:00:33,455
 In order for S to be a solution for this input,

11
00:00:33,455 --> 00:00:35,065
 what do we need to check?

12
00:00:35,065 --> 00:00:37,950
 Well, we have the constraint that the total weight of the objects in

13
00:00:37,950 --> 00:00:41,070
 this solution is at most B so we have to check

14
00:00:41,070 --> 00:00:47,495
 that the sum of objects in this subset of the or individual ways is at most B.

15
00:00:47,495 --> 00:00:49,395
 Or this is quite straightforward to do.

16
00:00:49,395 --> 00:00:54,090
 We're just summing up at most n numbers so this takes at most order n time.

17
00:00:54,090 --> 00:00:55,980
 The second thing that we need to check is that

18
00:00:55,980 --> 00:00:59,205
 this subset is optimal in the following sense,

19
00:00:59,205 --> 00:01:02,570
 that it maximizes the sum of the values.

20
00:01:02,570 --> 00:01:04,590
 It's easy to check what the total value is,

21
00:01:04,590 --> 00:01:06,190
 we just sum up the values,

22
00:01:06,190 --> 00:01:09,360
 but how do we check that has maximum total value?

23
00:01:09,360 --> 00:01:11,850
 How do we check that the value of this subset is

24
00:01:11,850 --> 00:01:14,790
 better or at least as good as any other subset?

25
00:01:14,790 --> 00:01:16,110
 For the MST problem,

26
00:01:16,110 --> 00:01:18,630
 we could check that it has optimal value,

27
00:01:18,630 --> 00:01:21,360
 it had minimum weight tree by running

28
00:01:21,360 --> 00:01:24,690
 a polynomial time algorithm such as Kruskal's or Prim's.

29
00:01:24,690 --> 00:01:29,490
 We checked the output of that algorithm and we look at the total weight of the tree

30
00:01:29,490 --> 00:01:31,890
 produced and we compare that to the weight of

31
00:01:31,890 --> 00:01:35,400
 the tree that we're considering in our proposed solution.

32
00:01:35,400 --> 00:01:37,260
 Now, we had an algorithm for the knapsack problem that

33
00:01:37,260 --> 00:01:39,870
 we looked at and the dynamic programming section.

34
00:01:39,870 --> 00:01:44,750
 The running time of our dynamic programming algorithm was order n times B.

35
00:01:44,750 --> 00:01:48,240
 The problem is that this running time is not polynomial time.

36
00:01:48,240 --> 00:01:50,390
 It's not polynomial in the input size.

37
00:01:50,390 --> 00:01:53,895
 Recall the input of size at least n to represent

38
00:01:53,895 --> 00:01:58,303
 these n objects and how big is the representation of this one number B.

39
00:01:58,303 --> 00:02:00,990
 Well, that takes log B bits.

40
00:02:00,990 --> 00:02:03,600
 In order to be polynomial in the input size,

41
00:02:03,600 --> 00:02:08,915
 we need an algorithm which runs in time polynomial in n and log B.

42
00:02:08,915 --> 00:02:13,860
 So a dynamic programming algorithm which is actually exponential in the input size.

43
00:02:13,860 --> 00:02:16,485
 We need a way to efficiently check solutions,

44
00:02:16,485 --> 00:02:20,855
 so we can't run that dynamic programming algorithm because that's exponential time.

45
00:02:20,855 --> 00:02:23,100
 We have no way of verifying that

46
00:02:23,100 --> 00:02:27,610
 our proposed solution is optimal that it's a maximum total value.

47
00:02:27,610 --> 00:02:29,025
 What is our conclusion?

48
00:02:29,025 --> 00:02:31,850
 Is the knapsack problem in NP or not?

49
00:02:31,850 --> 00:02:33,965
 Well the final statement is a bit subtle.

50
00:02:33,965 --> 00:02:35,370
 If you said that true,

51
00:02:35,370 --> 00:02:38,770
 knapsack is in NP, that is incorrect.

52
00:02:38,770 --> 00:02:41,905
 We don't know how to show that knapsack is in NP.

53
00:02:41,905 --> 00:02:44,350
 Now is knapsack not in np?

54
00:02:44,350 --> 00:02:46,430
 Well we can't prove that at the moment.

55
00:02:46,430 --> 00:02:48,374
 If we could prove that knapsack is not in NP,

56
00:02:48,374 --> 00:02:50,850
 that would imply that P is not equal to NP.

57
00:02:50,850 --> 00:02:52,140
 It could be the case that there is

58
00:02:52,140 --> 00:02:55,680
 a polynomial time algorithm for the knapsack problem and then we could

59
00:02:55,680 --> 00:03:00,690
 check this maximisation in polynomial time. What can we say?

60
00:03:00,690 --> 00:03:03,665
 We can say that if you said knapsack is in NP,

61
00:03:03,665 --> 00:03:07,620
 that is incorrect and as for a knapsack not being in NP,

62
00:03:07,620 --> 00:03:09,740
 well, we don't know whether or not that's true.

63
00:03:09,740 --> 00:03:11,085
 So the best we can say is that,

64
00:03:11,085 --> 00:03:15,910
 as far as we know right now knapsack is not known to be in the class NP.

65
00:03:15,910 --> 00:03:18,845
 Similarly, if you ask for the class P,

66
00:03:18,845 --> 00:03:20,130
 well, as far as we know,

67
00:03:20,130 --> 00:03:25,310
 knapsack is not known to be in the class P. Could it be that knapsack is in P?

68
00:03:25,310 --> 00:03:29,605
 Sure it might be. There might be a polynomial time algorithm for knapsack,

69
00:03:29,605 --> 00:03:34,204
 P might equal NP in which case knapsack will lie in NP,

70
00:03:34,204 --> 00:03:35,775
 but as of right now,

71
00:03:35,775 --> 00:03:37,860
 knapsack is not known to be in

72
00:03:37,860 --> 00:03:41,970
 the class P. There is a simple variant of the knapsack problem,

73
00:03:41,970 --> 00:03:44,580
 which is in the class NP.

74
00:03:44,580 --> 00:03:45,930
 Let's take a look at that variant.

75
00:03:45,930 --> 00:03:48,030
 What we're going to have to do is drop

76
00:03:48,030 --> 00:03:52,665
 this optimization part and we're going to add in another input parameter.

77
00:03:52,665 --> 00:03:54,960
 That additional input parameter is going to be

78
00:03:54,960 --> 00:03:57,810
 our goal for the total value and then we're going to

79
00:03:57,810 --> 00:04:03,060
 check whether our total value of our subset is at least the goal.

80
00:04:03,060 --> 00:04:05,875
 Then, we can do binary search on that additional parameter.

81
00:04:05,875 --> 00:04:07,975
 The goal for the total value.

82
00:04:07,975 --> 00:04:07,975
 Let's go ahead and formalize that now.

