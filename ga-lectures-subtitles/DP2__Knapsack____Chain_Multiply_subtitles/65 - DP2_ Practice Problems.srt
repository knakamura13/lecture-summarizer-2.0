1
00:00:00,000 --> 00:00:02,580
 At this point you're prepared to approach any of

2
00:00:02,580 --> 00:00:05,680
 the problems in chapter six of the textbook.

3
00:00:05,680 --> 00:00:09,575
 But let me point out a few particular ones which are especially useful.

4
00:00:09,575 --> 00:00:10,950
 Once again, these are problems from

5
00:00:10,950 --> 00:00:14,375
 the desk Gupta Papademetriou Abaza Ronnie algorithms textbook

6
00:00:14,375 --> 00:00:17,460
 and I'm using the numbering from the print version.

7
00:00:17,460 --> 00:00:21,654
 Problem 6.17, problem 17 in chapter 6,

8
00:00:21,654 --> 00:00:23,105
 is about change making.

9
00:00:23,105 --> 00:00:24,415
 Given a set of coins,

10
00:00:24,415 --> 00:00:26,910
 a set of denominations and a particular value,

11
00:00:26,910 --> 00:00:31,300
 can you make change for that value using that set of denominations?

12
00:00:31,300 --> 00:00:35,175
 In fact, there are three variants of the change making problem in the textbook.

13
00:00:35,175 --> 00:00:36,890
 I suggest doing all three.

14
00:00:36,890 --> 00:00:42,615
 Another good problem is problem 20 which is about building an optimal binary search tree.

15
00:00:42,615 --> 00:00:47,575
 There's problem 7 which is about finding the longest palindrome subsequence,

16
00:00:47,575 --> 00:00:49,980
 and you might also try the variant where instead of doing

17
00:00:49,980 --> 00:00:53,820
 a palindrome subsequence you look for a palindrome substring.

18
00:00:53,820 --> 00:00:55,765
 So they have to be contiguous.

19
00:00:55,765 --> 00:00:58,600
 Now, to summarize some of what we learned in this lecture,

20
00:00:58,600 --> 00:01:03,015
 when you're devising your subproblem, try prefixes first.

21
00:01:03,015 --> 00:01:04,568
 If that doesn't work,

22
00:01:04,568 --> 00:01:08,610
 you might be led in the direction of substrings.

23
00:01:08,610 --> 00:01:11,670
 Now, one important note to keep in mind is that if you do use

24
00:01:11,670 --> 00:01:15,180
 substrings and you get it to work and you get a valid solution,

25
00:01:15,180 --> 00:01:19,590
 then I often go back and look at whether substrings were actually

26
00:01:19,590 --> 00:01:24,650
 necessary or could I have simplified it and used prefixes.

27
00:01:24,650 --> 00:01:27,150
 This might lead to a faster algorithm,

28
00:01:27,150 --> 00:01:29,633
 but it's good to get a valid solution first.

29
00:01:29,633 --> 00:01:33,980
 Get a polynomial time algorithm using substrings if necessary and

30
00:01:33,980 --> 00:01:38,945
 then go back and check and think about whether actually substrings were required or not.

31
00:01:38,945 --> 00:01:40,980
 It's better to have a correct algorithm which is a bit

32
00:01:40,980 --> 00:01:43,750
 slower than an incorrect algorithm.

33
00:01:43,750 --> 00:01:45,870
 Once again, the key for getting fluent in

34
00:01:45,870 --> 00:01:49,610
 dynamic programming is to do lots of practice problems.

35
00:01:49,610 --> 00:01:51,915
 There are a lot of practice problems in the textbook,

36
00:01:51,915 --> 00:01:56,925
 but there are a lot available in the web too from other courses and from other books.

37
00:01:56,925 --> 00:02:00,930
 Do as many as you can and at some point you'll get the hang of it and they'll feel easy.

38
00:02:00,930 --> 00:02:03,770
 The solutions will start to seem similar to each other

39
00:02:03,770 --> 00:02:07,380
 but the only way to get to that point is to do lots of practice problems.

40
00:02:07,380 --> 00:02:07,380
 So good luck. I hope you start to enjoy it once you get.

