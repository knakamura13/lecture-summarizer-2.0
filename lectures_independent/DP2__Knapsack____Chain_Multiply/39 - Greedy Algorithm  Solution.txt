For this example, the maximum value that we can obtain is 18, and that is obtained by using objects two and three. The total weight of these objects is 22,12 + 10 and the value we obtained from them, the total value is 10 + 8 is 18. Now, let's compare this to the greedy algorithm. What would a greedy approach do? A greedy approach would take the most valuable object and try to fill up the backpack as much as possible with that most valuable object. What is the most valuable object? That's not the one with the total maximum total value. It's instead the one with the maximum value per unit of weight. If the weights are in pounds or kilograms and the value is in dollars, then we're looking at the object with maximum to the other value per pound or per kilogram. In summary, the greedy approach would sort the objects by their value per unit of weight, which is this, quantity ri, which is states value divided by its weight. In this example the objects are already sorted by that ratio. We have that r1 > r2, > r3, > r4. So now what would a greedy approach do? The greedy approach would try to add object one, if it can, in this case it can, then we go to object two, and it would try to add object two if it can put. In this example, once you add in object one, you have 15 units of weight. You only have seven units of weight remaining, so you can no longer add in object two. Then we go to object three. The next most valuable object. We would try to add it in, does it fit? No it doesn't fit. Then we try to add object four, if it can. In this example it can because 15 + 5 is 20. It fits in the backpack so the greedy approach could obtain the solution using objects one and object four. Notice that the total value of this solution, object one and object four is 15 + 1, so it has total value 16, whereas our optimal solution has total value 18. This example illustrates why the greedy approach fails. It would try to add an object one, and once it does that, it's filling up the backpack too much and it can no longer fit in object two or three, and it ends up being more useful to skip object one and, instead, add in objects two and three. If you want to make a sub optimal choice at the beginning to allow you to squeeze in more objects later on. Now, let's go back and try to make our dynamic programming solution for this problem.