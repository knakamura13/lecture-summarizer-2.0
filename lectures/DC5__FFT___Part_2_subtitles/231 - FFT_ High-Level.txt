>> We now have all the pieces to define the FFT algorithm. Let's start with the high level idea of the algorithm once again. We're given a polynomial of X. We're given this polynomial by its coefficients. Let's assume this polynomial is of a degree, at most N minus 1. Where N is power of K. We want to evaluate this polynomial N points. Now in the end, when we do polynomial multiplication, we actually want this polynomial A of X at two N points. In order to obtain at two N points instead of N points, we can just pad the polynomial, the coefficients with zeros, so that we view the polynomial as a degree two N minus one polynomial. Now what are the N points that we're going to choose? We're going to choose the Nth roots of unity as our end points, which we're going to evaluate the polynomial of A X at. Now since N is a power of two, so N equals two to the K for some positive integer k. Then we know that these N points the, Nth roots of unity, satisfy the plus minus property. So the first N over two are opposite of the last N over two. And the other property is, that the square of the Nth roots are the N over second roots. Now we're going to take this polynomial A of X, and we're going to define a pair of polynomials, A even, and A odd. We take the even coefficients, and that defines this polynomial A even. We take the odd coefficients of A of X, and that defines this polynomial A odd. And the degree of these two polynomials is at most, N over 2 minus 1. So we went down from a polynomial of N minus one degree, to two polynomials of degree at most N over 2 minus 1. Now what we saw earlier is that in order to attain A of X at these N points, we need to evaluate A even and A odd at the square of these points. So what we do is we recursively evaluate A even and A odd, at the square of Nth roots. What's one of the key properties of the Nth roots of unity? It's that the square of the Nth roots equals the N over second roots. And there are N over two such roots. So in order to obtain A of X at N points, we need to evaluate these two polynomials, A even and A odd, of half the degree, at N over two points. So we've got two subproblems of exactly half the size, and these subproblems are of the same form. We want A of X at the Nth roots, A even and A odd at the N over second roots. Finally, given A even and A odd at these N over second roots, it takes order and time to get A of X at the Nth roots. We simply use this formula from before. A of X equals A even at X square, plus X times A odd at X squared. So it takes order one time, to compute A of X for each X, in the order N axis. So it takes order N total total time to compute A of X at the Nth roots of unity. Finally, what will be the running time of this algorithm? Well, for the original problem of size N, we define two subproblems of size N over two. We recursively solve those to get the polynomials A even and A odd at the N over 2nd roots. And then it takes us order N time to merge the answers, to get A of X at the Nth roots. This is the common recurrence, that you've seen many times probably for merge short and stuff like that. And this solves to order NlogN. And this is the sketch of the algorithm to take a polynomial in the coefficients form, and give return, the valuation of the polynomial at N points, where the N points are the Nth roots of unity. And it does so in time order NlogN.