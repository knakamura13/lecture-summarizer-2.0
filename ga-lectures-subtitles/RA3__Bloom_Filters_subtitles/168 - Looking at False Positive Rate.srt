1
00:00:00,000 --> 00:00:03,630
 Recall our setting. We have a database of size M and we have

2
00:00:03,630 --> 00:00:08,215
 a hash table of size C times M for some C strictly greater than one.

3
00:00:08,215 --> 00:00:11,205
 What we just showed is that the false positive probability

4
00:00:11,205 --> 00:00:14,520
 is approximately .6185 raised to

5
00:00:14,520 --> 00:00:21,004
 the power of C. This .6185 corresponded to one half raised to the power LN two.

6
00:00:21,004 --> 00:00:24,810
 Let's now look at some specific examples to see how this performs.

7
00:00:24,810 --> 00:00:26,400
 Let's suppose we did the naive scheme,

8
00:00:26,400 --> 00:00:27,780
 where K equals one.

9
00:00:27,780 --> 00:00:32,675
 So, we didn't do the optimal choice of K. We just set one hash function.

10
00:00:32,675 --> 00:00:37,130
 And let's look at the case where we do 10 times larger or 100 times larger.

11
00:00:37,130 --> 00:00:40,110
 Now, this expression for the false positive probability was assuming

12
00:00:40,110 --> 00:00:44,430
 the optimal choice of K. In order to analyze this case where K equals one,

13
00:00:44,430 --> 00:00:47,610
 we have to go back to our expression of F of K. If you look

14
00:00:47,610 --> 00:00:51,240
 back at that expression and you plug in K equals one and C equal's 10,

15
00:00:51,240 --> 00:00:53,025
 or C equal's a 100, you get the following.

16
00:00:53,025 --> 00:00:57,360
 In the first case, the false positive probability is .095.

17
00:00:57,360 --> 00:01:00,900
 And in the second case it's point.00995.

18
00:01:00,900 --> 00:01:03,360
 Now, suppose we do the optimal choice of K. So,

19
00:01:03,360 --> 00:01:06,265
 then our false positive probability is going to be this expression.

20
00:01:06,265 --> 00:01:07,710
 Let's look at C equals 10.

21
00:01:07,710 --> 00:01:10,666
 What do we get? We get.0082.

22
00:01:10,666 --> 00:01:13,384
 A reasonable gain. But not that much better than C

23
00:01:13,384 --> 00:01:16,690
 equal's a 100 with this simple K equals one case.

24
00:01:16,690 --> 00:01:18,455
 Let's try to C equals a 100.

25
00:01:18,455 --> 00:01:22,320
 Sorry. Hash table is a 100 times bigger than the database we're trying to store.

26
00:01:22,320 --> 00:01:24,730
 But this is just a binary string, right?

27
00:01:24,730 --> 00:01:29,210
 So, it's very reasonable to consider a hash table which is 100 times bigger.

28
00:01:29,210 --> 00:01:33,780
 Now, the false positive probability is 1.3 times ten to the minus 21.

29
00:01:33,780 --> 00:01:37,530
 The key thing is that this is exponential in C. So,

30
00:01:37,530 --> 00:01:40,080
 taking C equals to a 100, it's tiny.

31
00:01:40,080 --> 00:01:42,180
 This is really a minuscule probability.

32
00:01:42,180 --> 00:01:43,690
 And if this is not small enough for you,

33
00:01:43,690 --> 00:01:45,330
 you can go C equals to 200,

34
00:01:45,330 --> 00:01:47,550
 or 300 and you're going to get a really,

35
00:01:47,550 --> 00:01:50,410
 really tiny probability of a false positive.

36
00:01:50,410 --> 00:01:55,170
 So, if you're willing to have a very small probability of a false positive,

37
00:01:55,170 --> 00:01:58,500
 then you have this very simple data structure

38
00:01:58,500 --> 00:02:01,525
 which just corresponds to having a binary string.

39
00:02:01,525 --> 00:02:03,570
 It's very simple to maintain and is

40
00:02:03,570 --> 00:02:08,460
 very fast query times and the false positive probability is very small.

41
00:02:08,460 --> 00:02:10,770
 The downside of this data structure is that occasionally,

42
00:02:10,770 --> 00:02:13,380
 you might have some false positives and

43
00:02:13,380 --> 00:02:17,470
 also it doesn't easily allow for deletions from the database.

44
00:02:17,470 --> 00:02:20,865
 Though, there are some heuristics for allowing deletions,

45
00:02:20,865 --> 00:02:24,790
 these are modifications which are called Counting Bloom Filters.

46
00:02:24,790 --> 00:02:28,110
 Well, that completes our description of Bloom Filters.

47
00:02:28,110 --> 00:02:30,030
 I look forward to seeing your projects where you're going to

48
00:02:30,030 --> 00:02:32,160
 implement Bloom Filters and you're going to

49
00:02:32,160 --> 00:02:32,160
 explore whether these approximations that we did in our analysis were reasonable or not.

