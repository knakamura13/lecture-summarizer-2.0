So, let's try to do our dynamic programming solution to this version of knapsack where we have a single parameter. The single parameter is going to be, little b, corresponding to the total weight available. And this little b is going to vary between the maximum capacity available, capital B, and zero. Now, we can define our subproblem. We define K(b) as the max value obtainable using total weight, at most, little b. And we allow ourselves to use a subset of all n objects or actually a multiset of all n objects, whereas, in the previous subproblem, we have an extra parameter i, and we only allowed ourselves to use a subset of the first i objects. I was trying to write a recurrence for this new subproblem definition. For the previous subproblem definition, in order to write a recurrence, we decided whether to include object i or not. Now, in this case, we don't have an object i, the last object. So, we want to try all possibilities for the last object to add. So, the recurrence for k of b is going to be, we're going to try all possibilities for the last object to add and we're going to take the best of those. How do we get the best? We take the max, and we'll use i to denote the last object that we're trying to add. So, last object that we're going at is going to be object i, and we'll consider all i between one and n. If we add in object i, we gain value, Vi. And in addition, we gain the optimal solution to the subproblem where the total weight goes down by Wi. This is expressed in K(b-Wi). And we're trying all possibilities for i between one and n. But we need that the ith object fits in the backpack. We can have this weight, this could possibly be a negative number. So, we need that Wi's and most little b. So, we're trying all possibilities for the last object to add where that last object can be anything between object one and object n, trying all these n objects. And, if that object fits in the current capacity, so Wi is smaller than Little b. We look at adding that objects. So, we gain value Vi4 and then our capacity available goes down by Wi. So, with the remaining capacity, we take the best solution. Now, since it's a one-dimensional table, be a straightforward to write the pseudo code. The table is one dimensional. There's not much choice in how we fill up the table. We're just going to fill it starting from K of 0 up to K of B. An this last entry is the solution to our problem. Let's go ahead and write the pseudo code for this algorithm just to detail it.