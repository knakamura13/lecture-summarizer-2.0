1
00:00:00,000 --> 00:00:03,145
 Now, Euler's theorem was the basis for RSA algorithm.

2
00:00:03,145 --> 00:00:06,900
 Now, let's go ahead in detail again the RSA algorithm.

3
00:00:06,900 --> 00:00:09,915
 The first step is to choose a pair of primes p and q.

4
00:00:09,915 --> 00:00:12,720
 These are the ones that we haven't seen actually how to do.

5
00:00:12,720 --> 00:00:15,135
 We're going to explain how to choose prime numbers,

6
00:00:15,135 --> 00:00:18,620
 after we review the RSA algorithm.

7
00:00:18,620 --> 00:00:20,760
 Now, after we choose the pair of primes p and q,

8
00:00:20,760 --> 00:00:22,230
 we look at their product.

9
00:00:22,230 --> 00:00:25,775
 Hence let N be the product of p and q.

10
00:00:25,775 --> 00:00:30,600
 The next step is to find an e which is relatively prime to (p-1)(q-1).

11
00:00:30,600 --> 00:00:38,430
 By relatively prime, again we mean that the gcd of e and (p-1) and (q-1) is one.

12
00:00:38,430 --> 00:00:40,490
 So they have no common factors.

13
00:00:40,490 --> 00:00:43,320
 Now, why did this (p-1)(q-1) come up?

14
00:00:43,320 --> 00:00:45,260
 Because recall Euler's theorem,

15
00:00:45,260 --> 00:00:46,965
 that's the exponent here.

16
00:00:46,965 --> 00:00:52,830
 So, what is the key implication of the fact that e is relatively prime to (p-1)(q-1)?

17
00:00:52,830 --> 00:00:55,470
 That means that e has an inverse.

18
00:00:55,470 --> 00:01:02,665
 So, the third step is to find the inverse of e relative to (p-1)(q-1).

19
00:01:02,665 --> 00:01:07,555
 So, let d be the inverse of e mod (p-1)(q-1).

20
00:01:07,555 --> 00:01:11,501
 We know it exists, because e is relatively prime to (p-1)(q-1).

21
00:01:11,501 --> 00:01:13,470
 How do we find this inverse?

22
00:01:13,470 --> 00:01:16,080
 We use the extended Euclid algorithm.

23
00:01:16,080 --> 00:01:22,270
 Now, we can publish our public key N and e. We tell the whole world this public key N and

24
00:01:22,270 --> 00:01:24,690
 e and anybody that wants to send us

25
00:01:24,690 --> 00:01:28,745
 a message will encrypt that message using this public key,

26
00:01:28,745 --> 00:01:32,040
 but nobody is going to know our private key little

27
00:01:32,040 --> 00:01:36,060
 d. We're going to keep this private key d secret,

28
00:01:36,060 --> 00:01:41,420
 because anybody that finds this private key d can decrypt messages.

29
00:01:41,420 --> 00:01:43,795
 Now, anybody that wants to send us a message,

30
00:01:43,795 --> 00:01:48,085
 let's say, m, they're going to encrypt the message using our public key.

31
00:01:48,085 --> 00:01:51,090
 They take that message m, they raise it to power of e and

32
00:01:51,090 --> 00:01:54,810
 look at a mod N. And then they send that Y,

33
00:01:54,810 --> 00:01:57,930
 which is congruent to m to the e mod N. They send

34
00:01:57,930 --> 00:02:01,500
 that message Y and the whole world can see that message Y,

35
00:02:01,500 --> 00:02:03,030
 but only we can decrypt it,

36
00:02:03,030 --> 00:02:06,540
 because only we know little d. Finally,

37
00:02:06,540 --> 00:02:09,595
 we receive this message Y, this encrypted message.

38
00:02:09,595 --> 00:02:10,950
 How do we decrypt it?

39
00:02:10,950 --> 00:02:13,400
 We use little d in the following way.

40
00:02:13,400 --> 00:02:15,645
 We take this encrypted message Y,

41
00:02:15,645 --> 00:02:20,240
 we raise it to the power of little d and we look at that mod N.

42
00:02:20,240 --> 00:02:25,110
 And it turns out that this equals m. What are the algorithms that we need to use?

43
00:02:25,110 --> 00:02:27,135
 Well, first off, to find this e,

44
00:02:27,135 --> 00:02:30,975
 which is relatively prime to (p-1)(q-1), what do we do?

45
00:02:30,975 --> 00:02:32,460
 We try e equals three, five,

46
00:02:32,460 --> 00:02:37,110
 seven, 11, 13, at some point we give up.

47
00:02:37,110 --> 00:02:38,505
 For each of those e's, though,

48
00:02:38,505 --> 00:02:42,795
 how do we check whether it's relatively prime to (p-1)(q-1)?

49
00:02:42,795 --> 00:02:47,190
 We check its gcd which we do using Euclid's algorithm.

50
00:02:47,190 --> 00:02:49,924
 Then once we find an e which is relatively prime,

51
00:02:49,924 --> 00:02:51,150
 we compute its inverse.

52
00:02:51,150 --> 00:02:52,415
 How do we do that?

53
00:02:52,415 --> 00:02:54,840
 We used the extended Euclid algorithm,

54
00:02:54,840 --> 00:02:56,490
 and we publish our key,

55
00:02:56,490 --> 00:02:57,917
 usually e is small,

56
00:02:57,917 --> 00:03:02,805
 so that taking m to the e mod N is relatively easy.

57
00:03:02,805 --> 00:03:06,090
 If it's not, then we can use repeated squaring,

58
00:03:06,090 --> 00:03:08,790
 our fast modular exponentiation algorithm,

59
00:03:08,790 --> 00:03:15,175
 and definitely here, when we're raising this encrypted message Y to the power d,

60
00:03:15,175 --> 00:03:17,725
 that's probably going to be to a huge power.

61
00:03:17,725 --> 00:03:20,510
 So, how do we do Y to the d mod N?

62
00:03:20,510 --> 00:03:24,120
 Here we need to use our fast modular exponentiation algorithm.

63
00:03:24,120 --> 00:03:26,165
 The algorithm based on repeated squaring,

64
00:03:26,165 --> 00:03:30,210
 and that's going to take time which is polynomial in little N,

65
00:03:30,210 --> 00:03:33,690
 the number of bits in these numbers Y and d and N.

66
00:03:33,690 --> 00:03:38,685
 Finally, the key thing about why this works is look at what's happening to the message.

67
00:03:38,685 --> 00:03:43,530
 We're raising the message m to the power e and then to the power d. And

68
00:03:43,530 --> 00:03:49,370
 recall that e times d is congruent to one mod (p-1)(q-1).

69
00:03:49,370 --> 00:03:53,245
 So, when we apply Euler's theorem what we're going to get out is,

70
00:03:53,245 --> 00:03:56,885
 we're going to get the message m back out.

71
00:03:56,885 --> 00:04:01,425
 So, m raised to the power e times d

72
00:04:01,425 --> 00:04:06,685
 modulo N is congruent to little m, because of Euler's theorem.

73
00:04:06,685 --> 00:04:08,795
 What remains?

74
00:04:08,795 --> 00:04:12,815
 We need to look at how we choose these prime numbers p and q.

75
00:04:12,815 --> 00:04:18,450
 The other thing is let's just make an aside about why this algorithm is hard to break.

76
00:04:18,450 --> 00:04:20,950
 Notice the whole world knows N,

77
00:04:20,950 --> 00:04:22,860
 which is p times q,

78
00:04:22,860 --> 00:04:26,535
 but only we know (p-1)(q-1),

79
00:04:26,535 --> 00:04:32,040
 and therefore only we can compute the inverse of e mod (p-1)(q-1).

80
00:04:32,040 --> 00:04:40,080
 The point is, can you get (p-1)(q-1) from N without knowing p and q, individually?

81
00:04:40,080 --> 00:04:42,240
 The assumption is that no, we can not do that,

82
00:04:42,240 --> 00:04:50,110
 that the only way to get (p-1)(q-1) is to get factor N into p and q.

83
00:04:50,110 --> 00:04:55,185
 If you don't know how to factor N into the pair of primes which compose it,

84
00:04:55,185 --> 00:04:59,450
 then you cannot get (p-1)(q-1). That's our assumption.

85
00:04:59,450 --> 00:05:02,610
 So, this algorithm is as hard as factoring

86
00:05:02,610 --> 00:05:07,370
 N. We don't know any other way to get (p-1)(q-1).

87
00:05:07,370 --> 00:05:09,900
 And our assumption is that factoring is difficult,

88
00:05:09,900 --> 00:05:12,075
 computationally difficult to solve.

89
00:05:12,075 --> 00:05:14,580
 Now, to finish off the RSA algorithm,

90
00:05:14,580 --> 00:05:14,580
 let's look at how we find prime numbers p and q.

