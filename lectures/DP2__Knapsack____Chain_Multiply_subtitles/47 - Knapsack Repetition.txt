Now, let's look at the other version of the knapsack problem. We gave a dynamic programming algorithm for the version of the problem where we have one copy of each object, so we can use each object at most, one time. Now, we'll look at the version of the problem where we have unlimited supply of every object. Here, we can use an object as many times as we'd like as opposed to the other version of the problem where we can use an object at most once. Now, let's go ahead with our recipe for designing a dynamic programming algorithm. The first step is to define the subproblem. And, let's go ahead and try the same subproblem as what we used for the other version of the problem and see if that works. Again, try to gain some insight. So, our subproblem for the previous version of knapsack was K(i,b) is the max value we can obtain using a subset of objects 1 through i with total weight, at most, little b. Now in this version, we're allowed to use objects multiple times. So instead of a subset where an object appears at most once, we're going to consider a multiset where an object can appear multiple times in the set. That's the only difference from the previous definition of the subproblem.