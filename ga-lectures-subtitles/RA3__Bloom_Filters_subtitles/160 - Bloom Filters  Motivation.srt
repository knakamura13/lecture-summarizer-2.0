1
00:00:00,000 --> 00:00:02,645
 Now we can finally describe Bloom filters.

2
00:00:02,645 --> 00:00:07,690
 Let's keep in mind this running example from before the case of unacceptable passwords.

3
00:00:07,690 --> 00:00:11,370
 We're going to describe a new data structure that has faster queries.

4
00:00:11,370 --> 00:00:15,480
 Recall in the traditional hashing scheme that we previously described,

5
00:00:15,480 --> 00:00:19,620
 the query time was order log in for the simple scheme or order log log

6
00:00:19,620 --> 00:00:24,090
 in for the more advanced scheme which used the power of two choices that are ideal.

7
00:00:24,090 --> 00:00:26,745
 Here we're going to achieve query time order one.

8
00:00:26,745 --> 00:00:28,513
 So constant query time,

9
00:00:28,513 --> 00:00:30,315
 and this is guaranteed.

10
00:00:30,315 --> 00:00:34,965
 Recall that the other query times were probabilistic statements.

11
00:00:34,965 --> 00:00:39,414
 So with high probability the query time was order log in or order log log in.

12
00:00:39,414 --> 00:00:41,850
 In the worst case it was order N. But

13
00:00:41,850 --> 00:00:45,300
 here it's guaranteed to always be constant query time.

14
00:00:45,300 --> 00:00:50,565
 This data structure will be very simple and it will use less space than before.

15
00:00:50,565 --> 00:00:52,915
 There are no linked lists or anything like that.

16
00:00:52,915 --> 00:00:55,830
 It will just be a simple binary array.

17
00:00:55,830 --> 00:00:56,970
 Now there are a lot of benefits.

18
00:00:56,970 --> 00:01:00,585
 It's simpler, less space, faster queries.

19
00:01:00,585 --> 00:01:04,915
 Now there must be some cost for this simplicity and this faster time.

20
00:01:04,915 --> 00:01:07,815
 So what is the cost, what is the tradeoff for this scheme?

21
00:01:07,815 --> 00:01:09,790
 Well, this scheme is not always correct.

22
00:01:09,790 --> 00:01:12,000
 Occasionally, there are false positives,

23
00:01:12,000 --> 00:01:14,725
 and this happens with some probability that we'll analyze.

24
00:01:14,725 --> 00:01:19,280
 We'll try to figure out what is this probability of false positives occurring.

25
00:01:19,280 --> 00:01:21,865
 What exactly do we mean by false positive?

26
00:01:21,865 --> 00:01:26,370
 We have an element X which is not in our dictionary of unacceptable passwords.

27
00:01:26,370 --> 00:01:28,405
 So this is an acceptable password,

28
00:01:28,405 --> 00:01:30,615
 but our algorithm occasionally says,

29
00:01:30,615 --> 00:01:33,630
 yes this X is in the dictionary.

30
00:01:33,630 --> 00:01:36,955
 In this setting false positives are acceptable.

31
00:01:36,955 --> 00:01:43,740
 Why? Because we have an acceptable password but we say that the password is unacceptable.

32
00:01:43,740 --> 00:01:45,840
 It's in our dictionaries. So we falsely say that

33
00:01:45,840 --> 00:01:49,470
 the password is in our dictionary of unacceptable passwords.

34
00:01:49,470 --> 00:01:53,215
 So somebody types in a password and we say, no that's not allowed.

35
00:01:53,215 --> 00:01:54,855
 Ideally, it should have been allowed,

36
00:01:54,855 --> 00:01:56,815
 but we said that, no is not allowed.

37
00:01:56,815 --> 00:01:59,245
 So then the user has to enter a new password.

38
00:01:59,245 --> 00:02:02,970
 But in exchange for these false positives we have guaranteed query time.

39
00:02:02,970 --> 00:02:07,315
 So we answer the question of whether it was an acceptable password or not quickly.

40
00:02:07,315 --> 00:02:10,316
 And in this setting false positives are reasonable.

41
00:02:10,316 --> 00:02:12,797
 False negatives that would have been a big cost,

42
00:02:12,797 --> 00:02:15,625
 that would have been unacceptable in this setting.

43
00:02:15,625 --> 00:02:19,220
 When we have an unacceptable password we definitely want to say it's unacceptable.

44
00:02:19,220 --> 00:02:21,795
 If we have an acceptable password, okay.

45
00:02:21,795 --> 00:02:25,963
 If we occasionally say that it's an unacceptable password that's okay.

46
00:02:25,963 --> 00:02:28,230
 So in this setting it's reasonable to have false

47
00:02:28,230 --> 00:02:31,635
 positive with some small probability that we'll try to bound.

48
00:02:31,635 --> 00:02:36,015
 In other settings it may be unacceptable to have false positives.

49
00:02:36,015 --> 00:02:39,745
 In which case bloom filters might be a bad idea.

50
00:02:39,745 --> 00:02:41,975
 So this is not a universal scheme.

51
00:02:41,975 --> 00:02:46,710
 You have to look at your setting and determine whether the price of having

52
00:02:46,710 --> 00:02:52,720
 a simpler and faster scheme is worth the cost of having false positives.

53
00:02:52,720 --> 00:02:52,720
 Is it acceptable to have false positives with some small probability?

