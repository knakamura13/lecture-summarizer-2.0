Let's first address whether a knapsack problem lies in the class NP or not. In order to lie in the class NP we have to be able to verify solutions. We have to be able to do the following efficiently. We have to take a particular input to the knapsack problem. An input is given by a set of weights, a set of values, and a total capacity to the for the backpack, and we have to take a solution for that input. Now, in polynomial time, can we check whether this solution is in fact correct for this input? In order for S to be a solution for this input, what do we need to check? Well, we have the constraint that the total weight of the objects in this solution is at most B so we have to check that the sum of objects in this subset of the or individual ways is at most B. Or this is quite straightforward to do. We're just summing up at most n numbers so this takes at most order n time. The second thing that we need to check is that this subset is optimal in the following sense, that it maximizes the sum of the values. It's easy to check what the total value is, we just sum up the values, but how do we check that has maximum total value? How do we check that the value of this subset is better or at least as good as any other subset? For the MST problem, we could check that it has optimal value, it had minimum weight tree by running a polynomial time algorithm such as Kruskal's or Prim's. We checked the output of that algorithm and we look at the total weight of the tree produced and we compare that to the weight of the tree that we're considering in our proposed solution. Now, we had an algorithm for the knapsack problem that we looked at and the dynamic programming section. The running time of our dynamic programming algorithm was order n times B. The problem is that this running time is not polynomial time. It's not polynomial in the input size. Recall the input of size at least n to represent these n objects and how big is the representation of this one number B. Well, that takes log B bits. In order to be polynomial in the input size, we need an algorithm which runs in time polynomial in n and log B. So a dynamic programming algorithm which is actually exponential in the input size. We need a way to efficiently check solutions, so we can't run that dynamic programming algorithm because that's exponential time. We have no way of verifying that our proposed solution is optimal that it's a maximum total value. What is our conclusion? Is the knapsack problem in NP or not? Well the final statement is a bit subtle. If you said that true, knapsack is in NP, that is incorrect. We don't know how to show that knapsack is in NP. Now is knapsack not in np? Well we can't prove that at the moment. If we could prove that knapsack is not in NP, that would imply that P is not equal to NP. It could be the case that there is a polynomial time algorithm for the knapsack problem and then we could check this maximisation in polynomial time. What can we say? We can say that if you said knapsack is in NP, that is incorrect and as for a knapsack not being in NP, well, we don't know whether or not that's true. So the best we can say is that, as far as we know right now knapsack is not known to be in the class NP. Similarly, if you ask for the class P, well, as far as we know, knapsack is not known to be in the class P. Could it be that knapsack is in P? Sure it might be. There might be a polynomial time algorithm for knapsack, P might equal NP in which case knapsack will lie in NP, but as of right now, knapsack is not known to be in the class P. There is a simple variant of the knapsack problem, which is in the class NP. Let's take a look at that variant. What we're going to have to do is drop this optimization part and we're going to add in another input parameter. That additional input parameter is going to be our goal for the total value and then we're going to check whether our total value of our subset is at least the goal. Then, we can do binary search on that additional parameter. The goal for the total value. Let's go ahead and formalize that now.