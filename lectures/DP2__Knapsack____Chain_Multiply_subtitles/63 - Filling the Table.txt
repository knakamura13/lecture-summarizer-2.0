Before we detail the Pseudocode for this dynamic programming algorithm, let's go back and look at our recurrence a little more carefully, and see how we're going to fill the table up. This recurrence is a little different from earlier examples, so how we're going to fill the table up is actually going to be a little bit more complicated than before. We're looking at this two-dimensional table C, and we're trying to compute the upper diagonal of this table. So those entries where j is at least i. Now, what was our base case? Our base case was diagonal, these are the entries C(i, i). This is the first thing we're going to fill in. What is the next thing that we're going to fill in? The next entries we're going to fill in are the entries C(i,i+1). Look at the recurrence for these entries. L is going to vary between i and that's it, that's the only choice for L. And then what are subproblems looks like? Our subproblems are C(i,i) and (i+1, i+1). So to compute this entry, we use these diagonal entries which are there in our base case. What is this? What are these entries correspond to in our table? These are the off diagonals, these are the second type of entries that we're going to fill in. So we're going to first do the diagonal and then we're going to do these off diagonal. And in order to compute the off diagonal, we use the diagonal entries. What is the next ones we're going to do? C(i,i+2). Look at the recurrence in order to compute these, we're going to use either diagonal entries or the off diagonal entries. So there are going to be there on the table. Finally, what is the last one we're going to compute? It's this one right here that corresponds to C(1,n) what is that? That's our final answer. That's the one we're trying to compute. This is the minimum cost to compute the product of matrices from A_1 up to A_n. So what our algorithm is going to do? It's going to start at this diagonal, and then it's going to move up, okay? How do we index that in our algorithm? Well, look. Look at this difference between the j and i. Let's call it the width and let's call that S. So S is j minus i. For the diagonal entries which are a base case, the width is S = 0. The off diagonals which we do next are have S = 1, they have width one, then we have width two, and so on until we get to width n-1. So we're going to vary the width from zero up to n-1. Now, we can go ahead and detail our Pseudocode for our dynamic programming algorithm.