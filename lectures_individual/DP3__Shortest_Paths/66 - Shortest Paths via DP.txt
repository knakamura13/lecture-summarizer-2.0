In this lecture, we'll look at several versions of shortest path problems and we'll use dynamic programming to design fast algorithms for these problems. The setting is that we have a directed graph G and we'll put the arrow on top to denote that it's a directed graph. And in addition, we have weights on the edges which is denoted by W(e). Here's an example of a directed graph on six vertices. Let's add in some edge weights. So this edge from s to b has weight five, three and some of the edges will have negative weights. So let's assign this edge from A to E weight negative two and we can have these anti-parallel edges. So we have an edge from A to D and from D to A and they might have the same or different weights. Now, these anti-parallel edges such as from A to D and D to A are quite useful. They allow us to encode an undirected graph as a directed graph. So if we have an undirected graph, we can replace the edge between A and D by this pair of anti-parallel edges. And in this way, this directed graph problem is more general than the undirected graph problem because we can encode any undirected graph as a directed graph by replacing each edge in this undirected graph by this pair of anti-parallel edges. In our first problem, we have a designated start for text which will denote as S. So let's fix our start vertex S and we're going to look at the length of the shortest path from S to every other vertex in this graph. Therefore, we're going to define the following function. So for every other vertex in the graph will denoted by Z. We're going to define this function dist(z). This is defined as the length of the shortest path from s to z. Now, dist(z) is defined for every vertex in the graph. So it's an array of length n. And our goal is to compute this array. To compute the distance of Z for every vertex Z. So we want to output this array of length n. Let's take a look at this function for this example. The simplest case is dist(s). What's the length of the shortest path from s to itself? Well, this is length zero. What's the length from s to b? Well, it's five. S to a, is of length eight, five plus three. The shortest path length to e is of length six and so on. The shortest path to D is 12 The shortest path to F is 11. The classical algorithm for this problem is Dijkstra's algorithm. You probably seen it many times before. Now, I'm not going to subject you to another lecture about Dijkstra's algorithm but let me give you a quick recap or a quick reminder about what Dijkstra's algorithm accomplishes. So Dijkstra's algorithm takes a directed graph with edge weights and a designated start vertex. That's the input to Dijkstra's algorithm. The output is this distance array. It outputs the distance of Z for all vertices in the graph. Once again, this is the length of the shortest path from s to this vertex Z. Now, how does Dijkstra's algorithm work? Well, it works in a manner similar to BFS, Breath For Search. It explores the graph in this layered approach. Now, recall BFS as in DFS takes linear time, so takes order (n+m) time, where n is the number of vertices and m is the number of edges. Now, in Dijkstra's algorithm, we have weights on the edges so we have to use a min heap data structure or priority queue. Each operation in these data structures takes order log(n) time. So there's an additional overhead over BFS and Dijkstra's algorithm takes (n+m) times log (n). And this is the total runtime for Dijkstra's algorithm to find this distance array. Now, there is one big limitation in Dijkstra's algorithm, it requires that all the edge weights are positive. Now, why does it require positive edge lengths? Well, because it might find this distance to be S five. But if there is negative edge weights, then it might find a shorter path to b. But once it outputs its distance, it doesn't recompute a shorter path, is it finds a new shorter path to B then it has to re-explore the edges out of that vertex again. So Dijkstra's algorithm is not guaranteed to produce the correct output when the edge weights are allowed to be negative. We're going to look at this more general problem where the edge weights are allowed to be negative, such as in this example. And we're going to design a dynamic programming algorithm to solve the shortest path problem when the edge weights are allowed to be negative because Dijkstra's algorithm no longer is guaranteed to work.