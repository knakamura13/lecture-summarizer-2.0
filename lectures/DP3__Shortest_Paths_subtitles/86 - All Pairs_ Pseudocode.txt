So now we can write our pseudo code for the all pairs shortest path problem. This algorithm is called the Floyd-Warshall algorithm. The input to the problem is a directed graph G and a set of weights on the edges. And these edge weights are allowed to be positive or negative. Now we'll start with the base case. What is the base case? The base case was the case D of zero S, T. So we want to iterate through all S and all T and fill in the entries D of 0, S, T. Recall our vertices are numbered one through N, so to iterate through all possible choices of S, we just have a for loop where S goes from one to N. Similarly, to go through all possible choices for T, we're going to have a for loop that varies T from one to N. Now to fill in the entry D of zero S, T, we got to check whether there is an edge from S to T. So if S, T is an edge, then this entry D of zero S, T is exactly the weight of this edge from S to T. In the other case where S to T is not an edge, then we're going to set D of zero S, T to be infinite. Now we go ahead and do the general case, where I is at least one. So we're going to vary from one to N. We're going to try to fill the entry D of I, S, T. So once again, we're going to go very overall, choices for S and all choices for T. So we're going have for loop going over the choices for S and a for loop going over the choices for T. Finally we can fill in the entry D of I, S, T. Now let's go ahead and write the recurrence for D of I, S, T. This is the recurrence that we just defined on the previous line. There are two cases and we're going to take the min or the best of the two cases. The two cases depend on whether vertex I is on the path or is not on the path. If it's not on the path then D of I, S, T is exactly D of I minus one, S, T. In the other case, when vertex I is on the path, we can break up that path into two parts. The first part goes from S to I and the second part goes from I to T and we take the sum of those two parts. Finally, what do we return? We return the case where I equals N. So we turn this matrix D of N, for all possible choices S and all possible choices T. I put these dots that signifies we're varying over all possible choices for that index. So we want all possible choices for S and all possible choices for T. If you think of this as a three dimensional array, then we're returning the slice corresponding to I equals N which isn't two dimensional array. It has N squared entries. This details the Floyd-Warshall algorithm. Now let's go ahead and analyze the writing time of the algorithm.