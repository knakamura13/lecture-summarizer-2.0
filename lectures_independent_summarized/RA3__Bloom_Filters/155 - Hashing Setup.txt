Hashing is being used to manage a database of unacceptable passwords, which are to be screened from user submissions quickly. The universe of all possible passwords (U) is vast; considering passwords of length 'A', there are 52^A possibilities. Storing all potential passwords is unfeasible, therefore only a subset (S) containing the unacceptable passwords is maintained. The required data structure must swiftly determine whether a user's proposed password (X) is in the unacceptable set S. Chain hashing employs a hash table (H) with an array of linked lists and a hash function (h) that maps each password to one of the N bins in H. Insertions involve calculating the hash of the element and linking it in the corresponding bin; queries require searching the linked list in the bin determined by the hash of the queried password. The hash function is assumed to distribute passwords randomly and independently across the bins, akin to placing balls in random bins. Notation is defined with the universe size as capital N, table size as little n, and size of the unacceptable password subset as little m. Capital N is exponentially larger than little n, and it is ideal if the hash table isn't much larger than the size of S, implying little n should be at least little m. The ultimate objective is to answer queries whether a password is acceptable or not by efficiently maintaining this dataset with a hash table's size managed just above little M.