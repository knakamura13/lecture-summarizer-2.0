1
00:00:00,000 --> 00:00:03,810
 In this lecture, we'll look at several versions of shortest path problems and

2
00:00:03,810 --> 00:00:07,650
 we'll use dynamic programming to design fast algorithms for these problems.

3
00:00:07,650 --> 00:00:10,530
 The setting is that we have a directed graph G

4
00:00:10,530 --> 00:00:14,033
 and we'll put the arrow on top to denote that it's a directed graph.

5
00:00:14,033 --> 00:00:18,060
 And in addition, we have weights on the edges which is denoted by W(e).

6
00:00:18,060 --> 00:00:21,215
 Here's an example of a directed graph on six vertices.

7
00:00:21,215 --> 00:00:23,015
 Let's add in some edge weights.

8
00:00:23,015 --> 00:00:25,775
 So this edge from s to b has weight five,

9
00:00:25,775 --> 00:00:29,070
 three and some of the edges will have negative weights.

10
00:00:29,070 --> 00:00:31,395
 So let's assign this edge from A to

11
00:00:31,395 --> 00:00:36,125
 E weight negative two and we can have these anti-parallel edges.

12
00:00:36,125 --> 00:00:38,565
 So we have an edge from A to D and from D

13
00:00:38,565 --> 00:00:41,635
 to A and they might have the same or different weights.

14
00:00:41,635 --> 00:00:47,640
 Now, these anti-parallel edges such as from A to D and D to A are quite useful.

15
00:00:47,640 --> 00:00:51,500
 They allow us to encode an undirected graph as a directed graph.

16
00:00:51,500 --> 00:00:52,980
 So if we have an undirected graph,

17
00:00:52,980 --> 00:00:58,685
 we can replace the edge between A and D by this pair of anti-parallel edges.

18
00:00:58,685 --> 00:01:01,860
 And in this way, this directed graph problem is more

19
00:01:01,860 --> 00:01:05,730
 general than the undirected graph problem because we can encode

20
00:01:05,730 --> 00:01:09,690
 any undirected graph as a directed graph by replacing

21
00:01:09,690 --> 00:01:14,575
 each edge in this undirected graph by this pair of anti-parallel edges.

22
00:01:14,575 --> 00:01:16,920
 In our first problem, we have a designated start for

23
00:01:16,920 --> 00:01:20,220
 text which will denote as S. So let's fix our

24
00:01:20,220 --> 00:01:22,980
 start vertex S and we're going to look at the length of

25
00:01:22,980 --> 00:01:26,630
 the shortest path from S to every other vertex in this graph.

26
00:01:26,630 --> 00:01:28,945
 Therefore, we're going to define the following function.

27
00:01:28,945 --> 00:01:32,490
 So for every other vertex in the graph will denoted by Z.

28
00:01:32,490 --> 00:01:35,245
 We're going to define this function dist(z).

29
00:01:35,245 --> 00:01:39,490
 This is defined as the length of the shortest path from s to z.

30
00:01:39,490 --> 00:01:42,735
 Now, dist(z) is defined for every vertex in the graph.

31
00:01:42,735 --> 00:01:46,985
 So it's an array of length n. And our goal is to compute this array.

32
00:01:46,985 --> 00:01:50,605
 To compute the distance of Z for every vertex Z.

33
00:01:50,605 --> 00:01:52,545
 So we want to output this array of length

34
00:01:52,545 --> 00:01:55,650
 n. Let's take a look at this function for this example.

35
00:01:55,650 --> 00:01:57,850
 The simplest case is dist(s).

36
00:01:57,850 --> 00:02:01,020
 What's the length of the shortest path from s to itself?

37
00:02:01,020 --> 00:02:02,775
 Well, this is length zero.

38
00:02:02,775 --> 00:02:06,355
 What's the length from s to b? Well, it's five.

39
00:02:06,355 --> 00:02:10,100
 S to a, is of length eight, five plus three.

40
00:02:10,100 --> 00:02:14,525
 The shortest path length to e is of length six and so on.

41
00:02:14,525 --> 00:02:19,495
 The shortest path to D is 12 The shortest path to F is 11.

42
00:02:19,495 --> 00:02:22,575
 The classical algorithm for this problem is Dijkstra's algorithm.

43
00:02:22,575 --> 00:02:24,535
 You probably seen it many times before.

44
00:02:24,535 --> 00:02:26,340
 Now, I'm not going to subject you to another lecture

45
00:02:26,340 --> 00:02:28,170
 about Dijkstra's algorithm but let me give you

46
00:02:28,170 --> 00:02:32,780
 a quick recap or a quick reminder about what Dijkstra's algorithm accomplishes.

47
00:02:32,780 --> 00:02:36,090
 So Dijkstra's algorithm takes a directed graph with

48
00:02:36,090 --> 00:02:39,860
 edge weights and a designated start vertex.

49
00:02:39,860 --> 00:02:41,940
 That's the input to Dijkstra's algorithm.

50
00:02:41,940 --> 00:02:44,730
 The output is this distance array.

51
00:02:44,730 --> 00:02:48,600
 It outputs the distance of Z for all vertices in the graph.

52
00:02:48,600 --> 00:02:52,560
 Once again, this is the length of the shortest path from s to this vertex Z.

53
00:02:52,560 --> 00:02:54,510
 Now, how does Dijkstra's algorithm work?

54
00:02:54,510 --> 00:02:58,580
 Well, it works in a manner similar to BFS, Breath For Search.

55
00:02:58,580 --> 00:03:01,795
 It explores the graph in this layered approach.

56
00:03:01,795 --> 00:03:05,940
 Now, recall BFS as in DFS takes linear time,

57
00:03:05,940 --> 00:03:08,415
 so takes order (n+m) time,

58
00:03:08,415 --> 00:03:11,990
 where n is the number of vertices and m is the number of edges.

59
00:03:11,990 --> 00:03:13,655
 Now, in Dijkstra's algorithm,

60
00:03:13,655 --> 00:03:16,050
 we have weights on the edges so we have to

61
00:03:16,050 --> 00:03:19,395
 use a min heap data structure or priority queue.

62
00:03:19,395 --> 00:03:23,010
 Each operation in these data structures takes order log(n) time.

63
00:03:23,010 --> 00:03:26,940
 So there's an additional overhead over BFS and

64
00:03:26,940 --> 00:03:31,385
 Dijkstra's algorithm takes (n+m) times log (n).

65
00:03:31,385 --> 00:03:35,375
 And this is the total runtime for Dijkstra's algorithm to find this distance array.

66
00:03:35,375 --> 00:03:38,967
 Now, there is one big limitation in Dijkstra's algorithm,

67
00:03:38,967 --> 00:03:41,670
 it requires that all the edge weights are positive.

68
00:03:41,670 --> 00:03:44,510
 Now, why does it require positive edge lengths?

69
00:03:44,510 --> 00:03:48,505
 Well, because it might find this distance to be S five.

70
00:03:48,505 --> 00:03:50,040
 But if there is negative edge weights,

71
00:03:50,040 --> 00:03:52,380
 then it might find a shorter path to b.

72
00:03:52,380 --> 00:03:54,615
 But once it outputs its distance,

73
00:03:54,615 --> 00:03:56,900
 it doesn't recompute a shorter path,

74
00:03:56,900 --> 00:03:58,695
 is it finds a new shorter path to

75
00:03:58,695 --> 00:04:02,815
 B then it has to re-explore the edges out of that vertex again.

76
00:04:02,815 --> 00:04:05,850
 So Dijkstra's algorithm is not guaranteed to produce

77
00:04:05,850 --> 00:04:09,540
 the correct output when the edge weights are allowed to be negative.

78
00:04:09,540 --> 00:04:11,220
 We're going to look at this more general problem

79
00:04:11,220 --> 00:04:13,140
 where the edge weights are allowed to be negative,

80
00:04:13,140 --> 00:04:15,248
 such as in this example.

81
00:04:15,248 --> 00:04:17,745
 And we're going to design a dynamic programming algorithm

82
00:04:17,745 --> 00:04:20,172
 to solve the shortest path problem

83
00:04:20,172 --> 00:04:22,275
 when the edge weights are allowed to be negative

84
00:04:22,275 --> 00:04:22,275
 because Dijkstra's algorithm no longer is guaranteed to work.

