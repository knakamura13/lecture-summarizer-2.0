Let's go ahead and detail the pseudocode for this faster multiplication algorithm. Now this is the algorithm from before. This is the order n square time algorithm, which utilized four recursive subproblems. This new algorithm is fairly similar. It's just that it differs at the end. Just this last bit is different. So let's get rid of the last bit of the algorithm. Let's change the name of this algorithm from Easy Multiply to Fast Multiply. Basic set up of the algorithm stays the same. The input is two n-bit integers x and y, and the output is the product. We partition the input x into the first n over two bits and the last n over Two bits that's XL and XR. And we also do similarly for y. We partition it into YL and YR. Now we're going to recursively compute the product of three pairs of n over two bit numbers. The first pair, as before, is XL times YL. The second pair, as before, is XR times YR. We are going to store those in A and B, as before. Now the new term is we're going to compute XL plus XR and we're going to multiply that by YL plus YR and we're going to store that in C. This is where we're utilizing Gauss's idea. Now we utilize the expression from the last slide. Z, the product of x times y is equal to two to the n times A which is XL times YL plus two to the n over two times the quantity C minus A minus B. This is where we are utilizing Gauss's idea. Finally, we add in B. Then we return Z, which is equal to the product of x and y. This completes our algorithm, and the key fact is that now we have three subproblems that we're recursively computing.