1
00:00:00,000 --> 00:00:04,370
 Let's recap the recurrence that the L Y J satisfies.

2
00:00:04,370 --> 00:00:08,310
 Now we're looking at the case with the two strings are non-empty.

3
00:00:08,310 --> 00:00:10,860
 So I has at least one and J is at least one.

4
00:00:10,860 --> 00:00:12,780
 Now we had two cases here.

5
00:00:12,780 --> 00:00:16,865
 We had the case X I is not equal to the Y J,

6
00:00:16,865 --> 00:00:18,340
 the last characters are different,

7
00:00:18,340 --> 00:00:20,820
 and we have the case where the last characters are the same.

8
00:00:20,820 --> 00:00:22,375
 In the case where they are the same,

9
00:00:22,375 --> 00:00:25,090
 we had the simple recurrence.

10
00:00:25,090 --> 00:00:27,550
 We depend on X I Y J,

11
00:00:27,550 --> 00:00:29,720
 and therefore get a plus one for that,

12
00:00:29,720 --> 00:00:31,920
 and then we take the optimal solution to

13
00:00:31,920 --> 00:00:35,950
 the smaller sub-problem with one less character in each string.

14
00:00:35,950 --> 00:00:37,560
 Now in the case where they are not equal,

15
00:00:37,560 --> 00:00:40,355
 we took the best of two scenarios.

16
00:00:40,355 --> 00:00:42,930
 We either drop the last character from X,

17
00:00:42,930 --> 00:00:45,065
 or we drop the last character from Y.

18
00:00:45,065 --> 00:00:48,390
 And we take the larger of these two solutions,

19
00:00:48,390 --> 00:00:50,070
 and we also had the base cases,

20
00:00:50,070 --> 00:00:53,070
 where one of the two strings was empty,

21
00:00:53,070 --> 00:00:55,980
 in which case the length is 0.

22
00:00:55,980 --> 00:00:59,840
 Finally, now we can state our dynamic programming algorithm.

23
00:00:59,840 --> 00:01:01,770
 The pseudocode for the algorithm.

24
00:01:01,770 --> 00:01:04,880
 And now, notice we have a two dimensional table now.

25
00:01:04,880 --> 00:01:08,070
 L is a two dimensional array. How are we going to fill it up?

26
00:01:08,070 --> 00:01:11,740
 We're going to fill it up row by row.

27
00:01:11,740 --> 00:01:14,340
 And now when we're looking at this entry L I J,

28
00:01:14,340 --> 00:01:17,215
 what are the entries that we're going to need for it?

29
00:01:17,215 --> 00:01:20,490
 We're going to need either this diagonal.

30
00:01:20,490 --> 00:01:23,365
 It's right here, L I-1J-1,

31
00:01:23,365 --> 00:01:26,440
 which will be there because we filled in the previous row,

32
00:01:26,440 --> 00:01:29,125
 or we'll need the entry just above,

33
00:01:29,125 --> 00:01:32,820
 or we'll need the entry just to the left.

34
00:01:32,820 --> 00:01:35,005
 So we're just gonna look at these three entries,

35
00:01:35,005 --> 00:01:38,545
 which will all be there, because we are filling it up row by row.

36
00:01:38,545 --> 00:01:42,835
 So earlier in this row will be completed and the previous row will be completed.

37
00:01:42,835 --> 00:01:42,835
 And now we can go ahead and state our dynamic programming algorithm.

