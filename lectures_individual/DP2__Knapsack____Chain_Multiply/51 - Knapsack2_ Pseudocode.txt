So, here's a Pseudocode for our repeat solution for this version of knapsack. This is a knapsack version where we allow objects to be used multiple times. So, the repeat version of the knapsack. As before, the input to the problem are the weights of the n objects W1 through Wn, the values of the n objects V1 through Vn, and the total capacity available capital B. Now, it's a one-dimensional table so has no base case to worry about. And now, we're just going to go through that one-dimensional array from bottom up. Little b is going to be the index for our current position in the array. We start off by setting it equal to zero, in case there are no objects which fit in the current capacity available. Now, we go through each object and we consider that object as a last object to add it in the backpack. And we see if that gives us a better solution than anything we've obtained before. First, we need to check whether this object, object i, fits in the current capacity of (l,b). So, it's if Wi is, at most, little b. And now, if it is, we check whether this obtains a solution which is better than anything we've seen previously for this index. So, the previous best solution is K(b) and the new solution we obtain is Vi, for adding object i, plus the best solution for capacity (b-Wi) which is K(B-Wi). So, this is the solution we obtain now by using object i. And this is the previous best solution. So, if the new solution is better than the previous best, then we're going to update the current best. Now finally, we just returned the last entry of the table and that's our solution to our problem. That's the max value we can obtain using total weight, at most, capital B, which is the solution to the original problem.