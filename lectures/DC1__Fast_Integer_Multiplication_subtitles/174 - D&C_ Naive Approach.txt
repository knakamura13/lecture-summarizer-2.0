Let's get back to our original problem multiplying n-bit integers. And let's look at the straightforward divide and conquer approach for this problem. The input to the problem are two integers x and y which are both n-bits long. And for simplicity, we're going to assume that n is a power of 2. This is a common assumption in divide and conquer algorithms. It allows us to get rid of floors and ceilings in our algorithm description and in the analysis of the running time. And our goal is to compute the product, x times y. We want to look at our running times in terms of n. N is the number of bits for these two integers x and y. It's the space required to represent these two numbers. Now what's the standard divide and conquer idea? Think about merge sort. What do you do? You break the input, the n numbers that you're trying to sort, you break them into two halves. The left half and the right half. Then you recursively solve the problem on the two halves. So for merge sort, that means sort the left half and sort the right half and then you combine the answers together. You merge them together. Now, how do we apply that same idea here for multiplying these two n-bit integers? How do we break the input into two halves? Well, we can't break it into x separately from y. So what do we do instead? We break x into two halves. The left half of x and the right half of x and similarly for y. X is n-bit number, how do we break it into two halves? Well, we looked at the first n over 2 bits and the last n over 2 bits. And we take these first n over 2 bits and we call that a new number, x_l. That's the left side of x. And we take the last n over 2 bits. And that's another number. x_r, corresponding to the right side of x. Similarly for y, we do the same thing. Take the first n over 2 bits and the last n over 2 bits. So we're going to break x into the first n over 2 bits. That's going to be this new number x_l and we're going to break it into the last n over 2 bits. That's going to be this number x_r. Similarly for y, we're going to break it into the first n over 2 bits, call that y_l. And the last n over 2 bits, call that y_r. Let's look at this specific example to see what this partition of x into two halves is going to signify. Let's look at x equal to 182. In binary, this is 1011 0110. This is 8-bits long. So we're going to break it into the first 4 bits and the last 4 bits. This is the first 4 bits, that's going to be x_l. The last 4 bits are going to be x_r. So x_l equals 1011 in binary. In decimal, that corresponds to 11, x_r is 0110 in binary which is 6. How does 182 relate to 11 and 6? Well, notice 182 is the same as 11 times 2 to the 4, 16 plus 6. And in general, x satisfies. We take this number x_l and we multiply it by 2 to the n over 2. That corresponds to shifting it, n over 2 times and then we add in x_r. Which means add in these n over 2 bits.