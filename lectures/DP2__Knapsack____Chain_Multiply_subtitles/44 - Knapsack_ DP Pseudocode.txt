Now, let's write the pseudocode for our algorithm. We are solving the knapsack version where objects can get used in most once. So its the no repeat version of knapsack that we're solving. Now, the input to the algorithm are the weights for the N objects W1 through Wn, the values for the N objects, V1 through Vn, and the total capacity available capital B. Now let's start with the base cases which are going to be the first row in the first column of the table. For the first row of the table, as we mentioned before, the entries are all going to be zero because we have a subset of the empty set which we are using. The first column of the table, we have total capacity zero available. So once again, we have the max value is zero. Now let's fill the interior of the table and we'll do it row by row. So, we have a for loop where i varies from 1 to N. This will be the current row. And then we'll vary the parameter little b from 1 to capital B. This will bring us along the current row. To fill the entry K(i, b), we have to first check whether fits in the current capacity available which is little b. So, we need to check whether the weight of the ith object which is Wi is smaller than little b or not. If the weight is smaller, then we have two scenarios. We can either include object i, or we don't include object i, and we're going to take the best of those two scenarios. If we include object i, we gain value Vi4, and we gain the value from the optimal solution to a subset of the first i-1 objects, and with total capacity available B-Wi. Or if we don't include object i, we gain value K(i-1,b) which is the optimal solution, which is a subset of the first i-1 objects, with the same capacity available. And we are going to take the best of those two. So we're going to take the maxi of those two entries. And the other scenario where object i does not fit in the current capacity available, then we know that the entry K(i, b) is just the same as the previous row, K(i-1, b), since the optimal solution, since it doesn't include object i, will be a subset of the first i-1 objects. And finally, what is our algorithm going to return? It's going to return the bottom right entry of the table. This is the max value which we can obtain using a subset of objects 1 through N, and the total capacity capital B. This is our original problem that we're trying to solve, and that's the solution that we're trying to obtain. Now, we can go and look at the running time of our algorithm. We first have our base cases, the first for loop is over capital B entries, that's over the first row. That takes time, order capital B. Second for loop is over the first column, that's of size order N. Now we have our nested for loops which are going over the interior of the table. First one is of size order N, the second nested for loop is of size order Capital B. And then, within this nested for loops is an if-then-else statement which is going to be order one time. This is order one time. This one is order capital B. Our loop is of size order N. And so the total run time of these nested for loops is order N and times capital B. So, the total run time is order N times capital B. That completes the algorithm for the case where objects can be used at most once, and then we'll go back and we'll look at the solutions to the problem when we allow the object to be used multiple times.