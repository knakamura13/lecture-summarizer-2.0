Outlets formally state the recurrence for L of i in terms of smaller subproblems. L of i requires that ai is included in the subsequence. Therefore we get 1 for including element ai in it. And then we take the longest subsequence that we can append on to the beginning. So we're going to take the max over all earlier indices of the length of the subsequence ending at that character aj. Now that earlier subsequence allows us to append ai onto the end of it only if aj is strictly smaller than ai. So you only want to consider j's where aj is strictly smaller than ai. And then we can take that earlier subsequence ending at aj and append ai onto the end of it and we get L of j for that earlier subsequence plus 1 for ai. And of course, we need that j is earlier in the input array than ai. Just in case the mathematical notation is confusing for anybody let me re-express it with slightly different notation and re-explain what it's saying in words. So L of i, the length of the longest increasing subsequence on the first i elements, which includes ai. So we get one for that element ai and then we're taking, we have ai here. Then we're going to take the longest increasing subsequence that we can put at the beginning. It's going to end at some element aj. Okay. So we're going to try all possibilities for that j. Now, we need that index j is earlier in the input array. So we're going to try j's between i minus 1 and 1. And we only want to try j's where aj is strictly smaller than ai. So we're doing a max over j. J is the variable that we're varying. We're trying j's where it's between 1 and i minus 1 in such that aj is strictly smaller than ai and we're taking the value L of j. Finally, we have our sub-problem definition and we have our recursive relation that the sub-problems satisfy. Now to be straightforward to detail our dynamic programming algorithm. So let's give this pseudocode for a dynamic programming algorithm and then analyze its running time and then we'll have completed this problem.