1
00:00:00,000 --> 00:00:02,875
 Now, let's look at the other version of the knapsack problem.

2
00:00:02,875 --> 00:00:04,770
 We gave a dynamic programming algorithm for

3
00:00:04,770 --> 00:00:08,310
 the version of the problem where we have one copy of each object,

4
00:00:08,310 --> 00:00:11,070
 so we can use each object at most, one time.

5
00:00:11,070 --> 00:00:12,915
 Now, we'll look at the version of the problem

6
00:00:12,915 --> 00:00:15,600
 where we have unlimited supply of every object.

7
00:00:15,600 --> 00:00:18,600
 Here, we can use an object as many times as we'd like as

8
00:00:18,600 --> 00:00:22,345
 opposed to the other version of the problem where we can use an object at most once.

9
00:00:22,345 --> 00:00:26,234
 Now, let's go ahead with our recipe for designing a dynamic programming algorithm.

10
00:00:26,234 --> 00:00:28,815
 The first step is to define the subproblem.

11
00:00:28,815 --> 00:00:32,040
 And, let's go ahead and try the same subproblem as what we

12
00:00:32,040 --> 00:00:35,290
 used for the other version of the problem and see if that works.

13
00:00:35,290 --> 00:00:37,055
 Again, try to gain some insight.

14
00:00:37,055 --> 00:00:42,090
 So, our subproblem for the previous version of knapsack was K(i,b) is the max value

15
00:00:42,090 --> 00:00:47,200
 we can obtain using a subset of objects 1 through i with total weight,

16
00:00:47,200 --> 00:00:48,815
 at most, little b.

17
00:00:48,815 --> 00:00:50,100
 Now in this version,

18
00:00:50,100 --> 00:00:52,610
 we're allowed to use objects multiple times.

19
00:00:52,610 --> 00:00:56,655
 So instead of a subset where an object appears at most once,

20
00:00:56,655 --> 00:01:02,105
 we're going to consider a multiset where an object can appear multiple times in the set.

21
00:01:02,105 --> 00:01:02,105
 That's the only difference from the previous definition of the subproblem.

