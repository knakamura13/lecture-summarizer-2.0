For Bellman-Ford, first off, takes O(nm) time for each run. Now, I'm terrible at memorizing these things, so actually, the name itself, Bellman-Ford, is not important. What's important is we had the single source shortest path algorithm using dynamic programming. And if you want to reconstruct the running time in your head, then what you can do is you can try to remember how it worked, the basic idea. So the basic idea was we conditioned on the number of edges in the path. So we went and we had this variable I which went from zero to n minus one. So we had a for loop over I, which had n choices. Okay, that's the order_n. And then in each step, we conditioned on the last edge in the path. So we had a for loop over the edges of the graph, and that gave us the m factor. So the total run time was O(nm). And now, we're running this algorithm n times, so the total run time is going to be order_n_squared_m. What we're going to do now is that direct algorithm for this problem, and this algorithm is called Floyd-Warshall algorithm, and the running time is going to be order_n_cubed. So it's better than this because in this case, m the number of edges of the graph can be up to n_squared. And if the graph is connected, it's going to be at least n minus one. So, this is possibly n to the fourth, whereas this is n_cubed. Now, just to clarify, I'm not expecting you to memorize the names of these algorithms. What I want you to do is to understand the basic approach in the two algorithms and then using that basic high level intuition, you can reconstruct the running time for these algorithms, and if you need be with enough sufficient time you can reconstruct the actual algorithms, okay? But I myself get confused all the time, which one is Bellman-Ford, which one is Floyd-Warshall, that's not the important aspect for here. I want you to understand the high level idea, and I'm illustrating these algorithms because they both have some nice dynamic programming approaches which are slightly different than the approaches that we've seen in the past. So now let's dive into this Floyd-Warshall algorithm and see how we get this n_cubed.