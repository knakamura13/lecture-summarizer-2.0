Now, let's detail our dynamic programming algorithm for computing the nth Fibonacci number. Here's our second attempt at an algorithm for computing the nth Fibonacci number. Recall, we're going to create an order array F which is going to store the Fibonacci numbers and we're going to start at the small indices namely. At the first two indices, we store the two base cases, zero and one, which are the first two Fibonacci numbers in the sequence. Then we have a for loop which goes from two up to n which is our goal. And using the recursive formula, the ith Fibonacci number is the sum of the previous two which are already stored in our array. Finally, we return the nth Fibonacci number which is stored in the last index in our array. This completes our algorithm. Notice the key thing is that our algorithm has no recursion in it. We have a recursive formula which defines the Fibonacci numbers but our algorithm has no recursion in it. Finally, let's analyze the running time of our algorithm. Once again, the base cases take order one time each. Then we have a for loop of size order n. The one step of the for loop takes order one time. Therefore, the total time of the for loop is order n time and the total run time of our algorithm is order n time. This completes our algorithm and gives us a glimpse of a dynamic programming algorithm.