let's look back at our earlier example and now we can illustrate our algorithm for finding strongly connected components in this example here's our input graph G now this graph G had to sink strongly connected components D by itself and these five vertices formed a strongly connected component now our main observation from before was if we ran DFS starting from one of these vertices in the sink SEC so suppose we ran DFS starting from this vertex K well initially everybody's marked as unvisited we want we set K to be visited then we visit L I J and H and noticed no other vertices in the graph are visited so the only visited vertices are exactly this strongly connected component containing K so we can mark all the vertices that were visited so far as component 1 and then we can rip it out of the graph and we can look at the remainder of the graph and we can find a sink SCC and the remainder of the graph for example D will run explore from it will find this component then the remainder of the graph and we'll find one of these vertices or an explore from it find this component and continue that's how our algorithm is gonna work now how do we find this vertex in a sink SCC well to do that we look at the reverse graph here's the reverse graph it's got the same vertex set we simply flipped all the edges so this has an edge from B to D this has an edge from D to B now what we claimed is that if we run DFS on this graph of the reverse graph the vertex with the highest post number is gonna lie in a source SCC in this graph what are the source strongly connected components in this reverse graph it's these five vertices and D so the sink SEC is over here in the original input graph our source SCC is over here in the reverse graph the vertex with the highest post number is gonna lie in one of these source strongly connected components and therefore it lies in our sink SCC in the original graph so let's run DFS on this graph here's an example run of DFS on this reversed graph and I'll make arbitrary choices for the order on the vertices and on the neighbors so let's choose a vertex to start DFS from let's say we start from vertex C we'll give see pre-order number one and then from see we visit G and we give it pre-order number two then we go to F from F there's nobody left to explore so we give it its pre-order number and it's post order number only popped back up to G and so on let me skip ahead from C these are the vertices that we can visit we can see G F B a and E and this is one example of the DFS tree that we see and these are the preorder and postorder numbers that will get now DFS will continue to an unfitted vertex let's say D from D we can't get anywhere so it'll just stop I'll give it a preorder and postorder number then finally we'll get one of these five vertices starting from L this is the DFS tree we get for this component and here's the preorder and postorder numbers and notice the vertex with the highest post order number is vertex L which is in this source SCC well you may think well the go-to started at vertex C if he would have started at one of these vertices then the vertex with the highest post order number would not lie in this component but in fact if we would have started the DFS from one of these five vertices then who can be visited from that vertex well we can visit all this graph except for D so all these other vertices will be in the subtree say of L so they'll all get post order numbers which are smaller than L and then finally we'll go to D and D will be the last vertex visited it'll have the highest post order number so we'll still get a vertex with the highest post order number lying in a source SCC so let's take this vertex L it has the highest post order number in this DFS run that's the important property that we needed now later we're gonna explore all these vertices in this component and then we're gonna need the vertex with the highest post order number of the remaining vertices so in order to obtain that it'll be useful to have all these vertices sorted by their decreasing post order number so let's do that so this is a list of vertices of the original graph or the reverse graph sorted by decreasing post order number from this DFS run on the reverse graph and now we're done with the reverse graph and we can go back to our original graph here's our input graph once again now what are we gonna do we're gonna run DFS starting from this vertex L when we run from L who do we visit we visit i j k and h now as we visit these vertices let's cross them out to mark that they're visited and let's assign them a strongly connected component number so our mark these five vertices are strongly connected component number one now we need to continue DFS who do we want to continue from we want to look at this graph and we want to find a sink in this remaining graph so who are we gonna choose we're gonna choose the vertex with the highest post order number of the remaining vertices in this case it's D so we run DFS from D we Explorer from D D becomes visited and we mark it with component number two then we run from C we see these three vertices and we mark them with component number three then we take the highest post order number of the unvisited vertices B in this case we explore from B who do we see we see B and E that would be component 4 finally a that's component 5 valla we have our strongly connected components and the vertices are labeled by their strongly connected component number and one other very cool feature what do you notice about these strongly connected component numbers here are the five strongly connected components notice there's an edge from meta vertex 3 to meta vertex 1 from 4 to 1 and so on these are the rest of the edges in the meta graph now what do you notice about these edges they all go right to left so notice we've outputted these strongly connected ponens in Reverse topological order so it's quite amazing we've done two runs of DFS one on the reverse graph and one on the original graph and what we found are the strongly connected components of the original graph and we output it these strongly connected components in topological order or to be precise in Reverse topological order so we can take any directed graph a general directed graph and with two runs of DFS we can find it's strongly connected components and we can structure these strongly connected components in topological order let's formalize this algorithm