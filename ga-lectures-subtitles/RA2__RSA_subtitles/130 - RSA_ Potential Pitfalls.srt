1
00:00:00,030 --> 00:00:01,260
 let's look at some of the issues that

2
00:00:01,260 --> 00:00:03,179
 can arise when we're implementing RSA

3
00:00:03,179 --> 00:00:05,730
 first off suppose in our message little

4
00:00:05,730 --> 00:00:08,580
 m is not relatively prime to capital n

5
00:00:08,580 --> 00:00:12,630
 so the GCD of little m and capital n is

6
00:00:12,630 --> 00:00:15,089
 greater than 1 now capital n is a

7
00:00:15,089 --> 00:00:17,940
 product of two primes P and Q so it's

8
00:00:17,940 --> 00:00:20,730
 only divisors are P and Q so what can be

9
00:00:20,730 --> 00:00:23,100
 the common divisor of m and capital n

10
00:00:23,100 --> 00:00:25,650
 it's got to be either P or Q so let's

11
00:00:25,650 --> 00:00:28,349
 suppose that GCD of little m and capital

12
00:00:28,349 --> 00:00:31,769
 n is P now what happens in the RSA

13
00:00:31,769 --> 00:00:34,410
 protocol or we take this message m raise

14
00:00:34,410 --> 00:00:36,930
 it to the power E and look at that mod

15
00:00:36,930 --> 00:00:39,870
 capital N and then the receiver takes

16
00:00:39,870 --> 00:00:42,270
 this encrypted message raises it to the

17
00:00:42,270 --> 00:00:45,750
 power D and then takes it mod N and what

18
00:00:45,750 --> 00:00:47,520
 do we get back well this equals the

19
00:00:47,520 --> 00:00:49,920
 original message M now we didn't prove

20
00:00:49,920 --> 00:00:51,480
 this case we proved the case when

21
00:00:51,480 --> 00:00:52,860
 they're relatively prime to each other

22
00:00:52,860 --> 00:00:55,079
 and then if followed by Euler's theorem

23
00:00:55,079 --> 00:00:57,270
 and we claim that this case when they're

24
00:00:57,270 --> 00:00:59,370
 not relatively prime followed by the

25
00:00:59,370 --> 00:01:01,379
 Chinese remainder theorem this is in

26
00:01:01,379 --> 00:01:03,270
 fact true but there's a potential

27
00:01:03,270 --> 00:01:05,519
 problem in this case what's the problem

28
00:01:05,519 --> 00:01:08,850
 well P divides m and N and if we look at

29
00:01:08,850 --> 00:01:11,640
 the encrypted message Y which is m to

30
00:01:11,640 --> 00:01:15,270
 the e mod n or of P divides M and it

31
00:01:15,270 --> 00:01:17,729
 divides n then it's also going to divide

32
00:01:17,729 --> 00:01:21,600
 Y so the GCD of Y and capital n is also

33
00:01:21,600 --> 00:01:23,490
 going to be P what does this mean well

34
00:01:23,490 --> 00:01:25,229
 anybody that's eavesdropping is gonna

35
00:01:25,229 --> 00:01:27,420
 see this encrypted message and from this

36
00:01:27,420 --> 00:01:29,460
 encrypted message and the public key

37
00:01:29,460 --> 00:01:32,610
 capital n by simply running Euclid's

38
00:01:32,610 --> 00:01:34,799
 algorithm they can take the GCD of these

39
00:01:34,799 --> 00:01:37,799
 two numbers and they find that the GCD

40
00:01:37,799 --> 00:01:41,280
 is little P prime P and once they know

41
00:01:41,280 --> 00:01:43,979
 prime P then they can factorize n and

42
00:01:43,979 --> 00:01:45,570
 therefore they can break the RSA

43
00:01:45,570 --> 00:01:48,090
 cryptosystem they can find the

44
00:01:48,090 --> 00:01:51,360
 decryption key little T so before using

45
00:01:51,360 --> 00:01:53,700
 this message m and sending the encrypted

46
00:01:53,700 --> 00:01:56,070
 version of it we have the first chat

47
00:01:56,070 --> 00:01:59,399
 that m and n are relatively prime to

48
00:01:59,399 --> 00:02:01,159
 each other if they share a common factor

49
00:02:01,159 --> 00:02:03,899
 then anybody will be able to use this

50
00:02:03,899 --> 00:02:06,210
 encrypted message to break this crypto

51
00:02:06,210 --> 00:02:08,250
 system what are some other issues that

52
00:02:08,250 --> 00:02:11,069
 can arise we need that little m is not

53
00:02:11,069 --> 00:02:13,230
 too large in particular we need that

54
00:02:13,230 --> 00:02:13,890
 little m

55
00:02:13,890 --> 00:02:16,050
 is strictly less than capital n now

56
00:02:16,050 --> 00:02:18,270
 typically our message is text so we

57
00:02:18,270 --> 00:02:19,890
 first have to convert it into a number

58
00:02:19,890 --> 00:02:22,140
 how might we do that well we can take

59
00:02:22,140 --> 00:02:23,850
 the binary version of the text

60
00:02:23,850 --> 00:02:25,590
 now the binary version of the text is

61
00:02:25,590 --> 00:02:27,660
 gonna be a huge number so what we do is

62
00:02:27,660 --> 00:02:30,150
 we break this huge number into n bit

63
00:02:30,150 --> 00:02:32,400
 segments these are segments of length

64
00:02:32,400 --> 00:02:35,910
 little N and therefore little m will be

65
00:02:35,910 --> 00:02:38,310
 at most strictly less than 2 to the

66
00:02:38,310 --> 00:02:40,800
 little n so if we break the message into

67
00:02:40,800 --> 00:02:44,220
 little n bit strings then we get this

68
00:02:44,220 --> 00:02:46,440
 property and if we ensure that P and Q

69
00:02:46,440 --> 00:02:48,660
 are sufficiently large so we ensure that

70
00:02:48,660 --> 00:02:51,570
 they're leading bit is 1 then if we look

71
00:02:51,570 --> 00:02:54,540
 at capital n we know that capital n will

72
00:02:54,540 --> 00:02:57,090
 be at least 2 to the N and therefore

73
00:02:57,090 --> 00:02:59,970
 little m will be strictly smaller than

74
00:02:59,970 --> 00:03:02,459
 capital n so this property that little m

75
00:03:02,459 --> 00:03:04,769
 is not too large as easy to insure but

76
00:03:04,769 --> 00:03:07,560
 we also need that m is not too small why

77
00:03:07,560 --> 00:03:09,180
 is that the case well suppose that

78
00:03:09,180 --> 00:03:11,880
 little e equals 3 which is a common

79
00:03:11,880 --> 00:03:14,010
 practice and suppose that M is very

80
00:03:14,010 --> 00:03:16,590
 small number so m cubed is strictly

81
00:03:16,590 --> 00:03:18,840
 smaller than n or when we look at M

82
00:03:18,840 --> 00:03:21,720
 cubed mod n what do we get

83
00:03:21,720 --> 00:03:23,250
 well the mod n isn't doing anything

84
00:03:23,250 --> 00:03:26,070
 because M cubed is smaller than n so M

85
00:03:26,070 --> 00:03:29,940
 cubed or m to the e is the same as m to

86
00:03:29,940 --> 00:03:32,700
 the e without the mod n so this mod n is

87
00:03:32,700 --> 00:03:34,799
 not doing anything when this number m is

88
00:03:34,799 --> 00:03:36,720
 too small and that means that our

89
00:03:36,720 --> 00:03:38,310
 encrypted message the message we're

90
00:03:38,310 --> 00:03:41,370
 sending in clear text is simply M cubed

91
00:03:41,370 --> 00:03:43,560
 the Madonna isn't doing anything now if

92
00:03:43,560 --> 00:03:46,140
 we see this message m cubed how do we

93
00:03:46,140 --> 00:03:48,150
 decrypt it we just take the cube root so

94
00:03:48,150 --> 00:03:50,310
 anybody seeing this encrypted message

95
00:03:50,310 --> 00:03:53,160
 can simply take to the to brood and we

96
00:03:53,160 --> 00:03:54,989
 get the original message back so it's

97
00:03:54,989 --> 00:03:56,820
 easy to decrypt it's easy to break this

98
00:03:56,820 --> 00:03:59,130
 crypto system in this case cube roots

99
00:03:59,130 --> 00:04:01,079
 are difficult to do when we're doing it

100
00:04:01,079 --> 00:04:03,600
 with respect to modular arithmetic but

101
00:04:03,600 --> 00:04:06,030
 in real arithmetic cube roots are easy

102
00:04:06,030 --> 00:04:08,280
 to do so how do we avoid this issue when

103
00:04:08,280 --> 00:04:10,500
 we have a small message well we can

104
00:04:10,500 --> 00:04:12,660
 choose a random number R and we can look

105
00:04:12,660 --> 00:04:16,260
 at M plus R or M exclusive or with R and

106
00:04:16,260 --> 00:04:19,079
 we can send this new message this padded

107
00:04:19,079 --> 00:04:21,630
 message and we can also send a second

108
00:04:21,630 --> 00:04:24,870
 message which is just R itself so we

109
00:04:24,870 --> 00:04:27,730
 send two messages the padded message

110
00:04:27,730 --> 00:04:30,310
 are itself and as long as our is not too

111
00:04:30,310 --> 00:04:33,190
 small then this will be okay and if our

112
00:04:33,190 --> 00:04:35,050
 is too small just choose a new random

113
00:04:35,050 --> 00:04:36,670
 string until we get an R which is

114
00:04:36,670 --> 00:04:38,860
 sufficiently large now there's one last

115
00:04:38,860 --> 00:04:41,020
 issue I want to point out if we use the

116
00:04:41,020 --> 00:04:43,480
 same message multiple times then we have

117
00:04:43,480 --> 00:04:45,730
 a potential problem suppose we have the

118
00:04:45,730 --> 00:04:47,560
 same message that we want to send to

119
00:04:47,560 --> 00:04:49,390
 three different people each of these

120
00:04:49,390 --> 00:04:51,220
 three people have a different public key

121
00:04:51,220 --> 00:04:53,860
 but they're all using a equals two three

122
00:04:53,860 --> 00:04:56,650
 suppose the first recipient has e equals

123
00:04:56,650 --> 00:05:00,970
 to 3 and n one second recipient has n 2

124
00:05:00,970 --> 00:05:03,520
 and e equals to three third recipient

125
00:05:03,520 --> 00:05:06,910
 has n 3 and e equal to three and suppose

126
00:05:06,910 --> 00:05:09,370
 we use the same message m to send to

127
00:05:09,370 --> 00:05:11,110
 these three people now the encrypted

128
00:05:11,110 --> 00:05:12,940
 messages are going to be different the

129
00:05:12,940 --> 00:05:14,740
 first encrypted message is going to be M

130
00:05:14,740 --> 00:05:17,890
 cubed mod and 1 the second encrypted

131
00:05:17,890 --> 00:05:20,770
 message is going to be M cubed mod and 2

132
00:05:20,770 --> 00:05:24,550
 the third one is going to be M cubed mod

133
00:05:24,550 --> 00:05:26,530
 and 3 so we got three different

134
00:05:26,530 --> 00:05:30,700
 encrypted messages y1 y2 and y3 but it

135
00:05:30,700 --> 00:05:33,160
 turns out that if somebody sees these

136
00:05:33,160 --> 00:05:35,920
 three encrypted messages which all come

137
00:05:35,920 --> 00:05:38,800
 from the same message same number M then

138
00:05:38,800 --> 00:05:40,810
 they can decrypt they can figure out M

139
00:05:40,810 --> 00:05:44,710
 from y1 y2 and y3 how do they do that

140
00:05:44,710 --> 00:05:46,900
 they use the Chinese remainder theorem

141
00:05:46,900 --> 00:05:48,250
 this is a homework problem in the

142
00:05:48,250 --> 00:05:50,350
 textbook in the desc coupe 2 textbook in

143
00:05:50,350 --> 00:05:53,650
 Chapter 1 is problem 44 now all that

144
00:05:53,650 --> 00:05:56,170
 remains for specifying the RSA protocol

145
00:05:56,170 --> 00:05:58,390
 is to describe how we do primarily

146
00:05:58,390 --> 00:05:58,390
 testing so let's dive into that

