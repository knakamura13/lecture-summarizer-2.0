1
00:00:00,000 --> 00:00:05,160
 Now, let's go ahead and try to define our dynamic programming algorithm for this problem.

2
00:00:05,160 --> 00:00:08,520
 The first step in our recipe is to define the subproblem in

3
00:00:08,520 --> 00:00:12,615
 words and we'll always try prefixes as our first attempt.

4
00:00:12,615 --> 00:00:15,810
 Therefore, we let c of i be the minimum cost for

5
00:00:15,810 --> 00:00:19,590
 computing the product of the first i matrices in the input.

6
00:00:19,590 --> 00:00:24,100
 Now, let's go back and see if we can define a recurrence for this subproblem definition.

7
00:00:24,100 --> 00:00:26,520
 Let's look at our graphical view, our root,

8
00:00:26,520 --> 00:00:30,715
 which we're trying to compute is A1 times A2 times up to An,

9
00:00:30,715 --> 00:00:32,880
 the product of these n matrices.

10
00:00:32,880 --> 00:00:36,825
 In our graphical view, we're going to have a left child and right child.

11
00:00:36,825 --> 00:00:39,850
 The left child is going to correspond to some prefix.

12
00:00:39,850 --> 00:00:44,890
 It's going to be the product of A1 times A2 up to Ai for some i.

13
00:00:44,890 --> 00:00:51,245
 The right child is going to correspond to the product of Ai plus one up to An.

14
00:00:51,245 --> 00:00:53,610
 Now, let's look at a recurrence which is going to tell us

15
00:00:53,610 --> 00:00:58,145
 the minimum cost for computing A1 times A2 up through An.

16
00:00:58,145 --> 00:01:00,780
 What we're going to do is we're going to try all possibilities for

17
00:01:00,780 --> 00:01:03,290
 the split i and then we're going to

18
00:01:03,290 --> 00:01:08,220
 recursively look up what is the minimal cost for computing this subtree,

19
00:01:08,220 --> 00:01:11,000
 which has root A1 times A2 up to Ai.

20
00:01:11,000 --> 00:01:14,450
 And we're going to look up, hopefully, recursively,

21
00:01:14,450 --> 00:01:17,540
 what is the minimum cost for computing this subtree,

22
00:01:17,540 --> 00:01:20,435
 which has a root A plus one through An.

23
00:01:20,435 --> 00:01:22,115
 Now, we're aiming for prefixes,

24
00:01:22,115 --> 00:01:24,920
 but this subproblem is a suffix.

25
00:01:24,920 --> 00:01:25,970
 So, you might think, well,

26
00:01:25,970 --> 00:01:27,410
 instead of just doing prefixes,

27
00:01:27,410 --> 00:01:29,915
 why don't we just do prefixes and suffixes?

28
00:01:29,915 --> 00:01:32,375
 Well, let's go one more level in this tree,

29
00:01:32,375 --> 00:01:34,790
 in this binary tree and we'll see that it gets worse.

30
00:01:34,790 --> 00:01:36,801
 Let's look at the children of this node.

31
00:01:36,801 --> 00:01:40,715
 There's going to be some split here at some j,

32
00:01:40,715 --> 00:01:46,275
 index j and the left's child is gonna correspond to the product of Ai plus one up to

33
00:01:46,275 --> 00:01:52,500
 Aj and the right child is going to correspond to the product of Aj plus one up to An.

34
00:01:52,500 --> 00:01:58,100
 Now, we'd like to try all possibilities for the split index j and then we'd like

35
00:01:58,100 --> 00:02:01,610
 to look up in our table the minimum cost

36
00:02:01,610 --> 00:02:05,260
 for this subtree and the minimum costs for this subtree.

37
00:02:05,260 --> 00:02:08,465
 Well, this subtree is a suffix. That's good.

38
00:02:08,465 --> 00:02:10,095
 But what is this tree?

39
00:02:10,095 --> 00:02:11,690
 This is not a prefix or suffix.

40
00:02:11,690 --> 00:02:13,255
 This is a substring.

41
00:02:13,255 --> 00:02:14,825
 That's the key thing, is that

42
00:02:14,825 --> 00:02:18,230
 all the intermediate computations are going to correspond to substrings.

43
00:02:18,230 --> 00:02:20,985
 It's going to be some index i and some index j.

44
00:02:20,985 --> 00:02:23,930
 And we're going to look at the product from i to j.

45
00:02:23,930 --> 00:02:27,800
 And this is going to suffice to consider substrings.

46
00:02:27,800 --> 00:02:31,060
 So, we're going to have to go back and revise our subproblem definitions,

47
00:02:31,060 --> 00:02:33,075
 so that we don't consider prefixes,

48
00:02:33,075 --> 00:02:33,075
 we're going to look at substring-

