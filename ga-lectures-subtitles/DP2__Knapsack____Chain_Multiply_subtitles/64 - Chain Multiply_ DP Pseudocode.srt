1
00:00:00,000 --> 00:00:02,395
 Now, let's go ahead and detail the pseudocode for

2
00:00:02,395 --> 00:00:04,770
 our dynamic programming algorithm to compute

3
00:00:04,770 --> 00:00:07,980
 the minimum cost for multiplying these and matrices.

4
00:00:07,980 --> 00:00:10,365
 Recall the input to the problem are the sizes.

5
00:00:10,365 --> 00:00:14,410
 These n+1 numbers representing the sizes of the N matrices.

6
00:00:14,410 --> 00:00:17,220
 M zero, M one, up to Mn.

7
00:00:17,220 --> 00:00:20,010
 Let's start with the base case which corresponds to diagonal entering.

8
00:00:20,010 --> 00:00:25,140
 The cost for these diagonal entries is zero since there's no computation to be done.

9
00:00:25,140 --> 00:00:27,285
 Now, we're going to use our width parameter S.

10
00:00:27,285 --> 00:00:30,030
 We already did the case where the width is zero.

11
00:00:30,030 --> 00:00:35,180
 So we're going to start with one and go up two with n-1 which is our final solution.

12
00:00:35,180 --> 00:00:38,370
 Then we have a parameter i which corresponds to the row.

13
00:00:38,370 --> 00:00:40,965
 Notice that the rows are getting truncated at the end.

14
00:00:40,965 --> 00:00:44,425
 Let's look at our matrix just to see what we mean by this.

15
00:00:44,425 --> 00:00:46,735
 Our diagonal as these entries.

16
00:00:46,735 --> 00:00:50,620
 And then, when we do the off diagonal,

17
00:00:50,620 --> 00:00:52,760
 I'm going to start at this entry one,

18
00:00:52,760 --> 00:01:01,100
 two and is going to end at this entry n-1.

19
00:01:01,100 --> 00:01:04,070
 So it doesn't go down to the bottom row, okay?

20
00:01:04,070 --> 00:01:09,010
 So that's why it stops at n-s. Once it tell you the index i and it tell you the width,

21
00:01:09,010 --> 00:01:12,905
 then that defines the index j which is the end of the substring.

22
00:01:12,905 --> 00:01:14,910
 Therefore, we let j, b,

23
00:01:14,910 --> 00:01:18,930
 i + s. Now we're going to compute the entry c, i, j.

24
00:01:18,930 --> 00:01:21,595
 We're going to take a min and we're going to vary over

25
00:01:21,595 --> 00:01:24,525
 L and keep track of the current min so far.

26
00:01:24,525 --> 00:01:26,280
 So we're going to initialize the min,

27
00:01:26,280 --> 00:01:28,795
 the value, the current minimum to infinity.

28
00:01:28,795 --> 00:01:31,280
 If using infinity makes you

29
00:01:31,280 --> 00:01:34,550
 uncomfortable you can think of setting this to some huge number.

30
00:01:34,550 --> 00:01:37,280
 Now, we're going to vary over the choices for the split at

31
00:01:37,280 --> 00:01:41,770
 L. Recall L can vary between i and j -1.

32
00:01:41,770 --> 00:01:44,975
 Now, for that split at L let's look at the cost,

33
00:01:44,975 --> 00:01:49,950
 let's define a variable cur which is the current cost for the current index

34
00:01:49,950 --> 00:01:55,590
 L. Because Mi -1 ml mj to combine the left and right subtrees.

35
00:01:55,590 --> 00:02:00,830
 C(i,l) for the left subtree and C(l+1,j) for the right subtree.

36
00:02:00,830 --> 00:02:03,650
 And we want to compare this to the current best.

37
00:02:03,650 --> 00:02:08,210
 So the current best is larger than this value cur,

38
00:02:08,210 --> 00:02:13,640
 then we're going to reset the current best to this current value. Then, the for loop.

39
00:02:13,640 --> 00:02:17,060
 This is in this for loop, this is in this for loop.

40
00:02:17,060 --> 00:02:18,843
 We have a bunch of nested for loops.

41
00:02:18,843 --> 00:02:20,562
 Finally, what we return,

42
00:02:20,562 --> 00:02:24,510
 our final answer is the top right of our matrix.

43
00:02:24,510 --> 00:02:29,010
 We return this entry (C(1,n)) which corresponds to the cost,

44
00:02:29,010 --> 00:02:33,305
 the minimum cost for computing the product of the matrices A1 through An.

45
00:02:33,305 --> 00:02:35,555
 That completes our dynamic programming algorithm.

46
00:02:35,555 --> 00:02:37,625
 Now let's take a look at the running time.

47
00:02:37,625 --> 00:02:41,240
 We have this base case computation which takes order and time.

48
00:02:41,240 --> 00:02:44,565
 Now, we have this first for loop which is of size order n. Then,

49
00:02:44,565 --> 00:02:46,995
 we have another nested for loop which is the size at most n.

50
00:02:46,995 --> 00:02:51,470
 And now we have another for loop which is of size at most n, again.

51
00:02:51,470 --> 00:02:53,555
 And then within these for loops,

52
00:02:53,555 --> 00:02:56,510
 it takes order one time for this computation.

53
00:02:56,510 --> 00:02:59,620
 So we have three nested for loops of size order n each.

54
00:02:59,620 --> 00:03:03,620
 So the total run time is order n q total time.

55
00:03:03,620 --> 00:03:07,225
 So that completes our chain multiply dynamic programming algorithm.

56
00:03:07,225 --> 00:03:08,850
 And the key thing here was that we,

57
00:03:08,850 --> 00:03:15,110
 instead of using prefixes we had to move on to substrings for the subproblem definition.

58
00:03:15,110 --> 00:03:18,055
 And then, how we filled in the table was a little bit more complicated.

59
00:03:18,055 --> 00:03:20,090
 Usually, it's straightforward to fill in the table,

60
00:03:20,090 --> 00:03:21,375
 we'd go row by row.

61
00:03:21,375 --> 00:03:24,920
 But for this, when we were using substrings we have to go from

62
00:03:24,920 --> 00:03:24,920
 the diagonal and then work our way up to the top right.

