Now, let's detail the pseudo code for a linear time median algorithm. The input to the algorithm is unsorted array A, of size n, and an integer k. Where the integer k lies between one and little n. And the output of the algorithm is the k-th smallest element of the array A. The first thing we need to do is find a good pivot. To do that we break A into n over five groups of five elements each. Now to be precise, we should say the ceiling of n over five groups, because little n might not be a multiple of five. But let's ignore floors and ceilings in this pseudo code. Let's denote these n over five groups as G_1, G_2 up to G_n over five. Now, how exactly do we break a into these n over five groups. Well, we can do it in any arbitrary way we like. The easiest way to do it, is to take the first five elements of A and put those into group one, take the next five elements of A and put those in group G_2 and so on. Now we have chosen one representative from each of these groups. Here's a for loop to go over the n over five groups. For the ith group, group G_i, we want to find the median. To do that we first sort this group. There's only five elements so we can take any algorithm we like to sort it. And then we take the median of these five elements. And let's let mi denote the median of group G_i. Now we want to look at these n over five medians which we found in step two. Let's let capital S denote this set of n over five medians. Next, we want to find the median of this set S. This will be our pivot P. How do we find this pivot P? How do we find the median of this set? Well, we recursively call this same algorithm Fast select, on this subset S. Now S has n over five elements, we want to find its median, therefore we look for K equal to n over 10. The n over 10 smallest element of S, is the median of this set S. And we store that in element P. Now we use P as our pivot. We partition the original set A into three sets. Those elements less than pivot P, those equal to the pivot P, and those bigger than the pivot P. This requires just one scan over the set A. Now we can use the quick select approach from before. Based on the sizes of these three sets, we either recursively search in small set, the big set, or we simply output P. In particular, if the size of the small set is at least as large as k, then we know that the k-th smallest lies in this small set. So, we recursively run this same fast select algorithm on the small set, looking for the k-th smallest. Now if k is big enough, in particular, if k is bigger than the size of a small set, plus the equal set, then we know the k-th smallest lies in this big set. So, we recursively run fast select on the big set with this K scale. So, we set k equal to k minus the size of a small set and the size of the equal set the part that we discarded. Finally, if neither of these two cases held, then we know that the k-th smallest lies in the equal set, and therefore we simply output P. Now these three cases are simply the same as we detailed before for the quick select algorithm. This completes the pseudo code for our algorithm. Now we can analyze this running time assuming that this pivot P that we found is a good pivot. And then we'll go back and prove that this pivot P is in fact guaranteed to be a good pivot.