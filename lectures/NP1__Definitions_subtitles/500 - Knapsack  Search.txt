Now, we're going to look at the version of knapsack which is a search problem. Now, the input starts off the same as before. So, we'll have integer weights W1 through Wn, integer values V1 through Vn and a total capacity, capital B. All of these is the same as before for the original knapsack problem, but there's an additional input parameter which is our goal which will denote as little g. Our output is a subset as just as before where the total weight of this subset S is at most capital B. So, if I sum over the objects in the subset of their individual weights that's at most capital B. That's just as before and we look at the total value of this subset. Previously, we were trying to maximize this total value, but now we're going to just check whether this total value meets our goal. How is the immediate goal? Well, we just want that the total value is at least g. We're trying to maximize the total value. So, we wanted to be at least our goal. If we made it at most our goal that would be easy, that would be trivial. We could just output the empty set. And if we do better than our goal that's even better. That's why we make it at least g. But now, what happens if there's no subset which meets our goal? Well, if there's no solution to this problem, so there's no subset which meets this goal, then we simply output "NO". This is the correct form for our search problem. Notice that if we can solve this knapsack search version in polynomial time, then we can solve the original optimization version in polynomial time. How? Well, in the original version we were maximizing this sum of the total value. Here we're simply finding a subset whose total value is at least little g. Now, suppose that we could solve this version in polynomial time. How do we solve the maximization version? Well, we can simply do binary search over this little g and by doing binary search over the little g and we find the maximum little g which has a solution, then that tells us the maximum total value which we can achieve. How many rounds in our binary search are we going to have to run? How many of these knapsacks search version problems are we going to have to run in order to solve the optimization problem? Well, let's look at the sum of these values. Let's let capital V be the sum of all the values. Certainly the max of this total value that we can achieve is at most capital V. So, we're going to do binary search on little g ranging between one and capital V. So, the total number of rounds in our binary search algorithm is going to be at most order log V. What is the size of the input to represent these numbers? Well, it's log V. So, this algorithm, this binary search algorithm is polynomial in the input size. So, we can solve the knapsack search version in polynomial time, then we can solve the optimization version in polynomial time.